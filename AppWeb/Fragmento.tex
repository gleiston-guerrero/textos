					\item \textbf{Interceptor HTTP \texttt{core/http/auth}.}
\begin{itemize}
	\item \emph{Definición:} Filtro que intercepta solicitudes/respuestas HTTP para añadir cabeceras o tratar errores.
	\item \emph{Características:} Se registra como proveedor; compatible con \texttt{HttpClient}; cadena de interceptores.
	\item \emph{Funcionalidades:} Inserta \texttt{Authorization: Bearer <token>}; reintenta (\emph{retry}); centraliza manejo de 401/403/500.
	\item \emph{Ejemplo de uso:} Leer \texttt{localStorage} y clonar la petición con \texttt{setHeaders}; redirigir a \texttt{/login} en 401.
\end{itemize}

\item \textbf{Pruebas unitarias (\emph{unit tests}).}
\begin{itemize}
	\item \emph{Definición:} Conjunto de \texttt{*.spec.ts} que validan componentes, servicios y \emph{pipes} aisladamente.
	\item \emph{Características:} \emph{TestBed} para montar componentes; \emph{mocks}/\emph{spies} para dependencias; ejecución en navegador o headless.
	\item \emph{Funcionalidades:} Detectar regresiones; medir cobertura; integrar en CI.
	\item \emph{Ejemplo de uso:} Probar que \texttt{ProductosService.listar()} emite una colección y que la plantilla muestra el conteo esperado.
\end{itemize}

\item \textbf{Pruebas \emph{end-to-end} (E2E).}
\begin{itemize}
	\item \emph{Definición:} Escenarios funcionales que automatizan la UI completa (navegación, formularios, respuestas del servidor).
	\item \emph{Características:} Ejecución en navegador real; \emph{selectors} robustos; \emph{stubs} de red (\emph{fixtures}).
	\item \emph{Funcionalidades:} Validar \emph{happy paths} y casos de error; garantizar integridad del flujo crítico antes de desplegar.
	\item \emph{Ejemplo de uso:} Caso “crear producto”: abrir formulario, completar campos, enviar, verificar notificación y presencia en la lista.
\end{itemize}

\item \textbf{Linter (análisis estático, ESLint).}
\begin{itemize}
	\item \emph{Definición:} Reglas automáticas para estilo y calidad de código TypeScript/HTML.
	\item \emph{Características:} Reglas recomendadas para Angular; autofix; integración con editores y CI.
	\item \emph{Funcionalidades:} Estándares consistentes; detección temprana de \emph{anti-patterns}.
	\item \emph{Ejemplo de uso:} Bloquear un \emph{pull request} si la base no cumple reglas; ejecutar \emph{autofix} localmente.
\end{itemize}

\item \textbf{Paquete de componentes de interfaz (Angular Material).}
\begin{itemize}
	\item \emph{Definición:} Biblioteca oficial de UI basada en Material Design (botones, \emph{dialogs}, \emph{tables}, formularios).
	\item \emph{Características:} Temas (claro/oscuro), tipografía, \texttt{CDK}; componentes accesibles (ARIA).
	\item \emph{Funcionalidades:} Acelera la construcción de interfaces consistentes; integra \texttt{MatTable}, \texttt{MatFormField}, \texttt{MatDialog}.
	\item \emph{Ejemplo de uso:} Implementar un \emph{table} de productos con paginación/filtro y \emph{dialog} para crear/editar.
\end{itemize}

\item \textbf{Actualización de versión y migraciones (Angular \emph{update}).}
\begin{itemize}
	\item \emph{Definición:} Proceso asistido para pasar a versiones más recientes del framework y dependencias.
	\item \emph{Características:} \emph{Schematics} que ajustan código y configuración; reporte de \emph{breaking changes}.
	\item \emph{Funcionalidades:} Mantener la base al día con mejoras de rendimiento, seguridad y nuevas APIs.
	\item \emph{Ejemplo de uso:} Migrar a una versión mayor, aplicar cambios en \texttt{tsconfig}, rutas y \texttt{standalone APIs} automáticamente.
\end{itemize}

\item \textbf{Despliegue (\emph{deploy}) de artefactos de \texttt{dist/}.}
\begin{itemize}
	\item \emph{Definición:} Publicación de la aplicación ya construida en un entorno de producción o \emph{staging}.
	\item \emph{Características:} Integración con \emph{builders} de despliegue (p.\,ej., a Firebase, GitHub Pages, servicios de hosting); soporte para rutas base (\texttt{baseHref}).
	\item \emph{Funcionalidades:} Automatizar envío de \texttt{dist/} a un servidor; configurar cabeceras de caché y compresión en el destino.
	\item \emph{Ejemplo de uso:} Desplegar la SPA en un bucket estático con CDN y \emph{fallback} a \texttt{index.html} para el enrutador del cliente.
\end{itemize}
\subsubsection{Estructura Final del Proyecto}
\begin{verbatim}
	tienda-app/
	├── src/
	│ ├── app/
	│ │ ├── app.component.ts
	│ │ ├── app.component.html
	│ │ ├── app.component.scss
	│ │ ├── app.module.ts
	│ │ ├── app-routing.module.ts
	│ │ ├── auth/
	│ │ │ ├── auth.guard.ts
	│ │ │ └── auth.service.ts
	│ │ ├── core/
	│ │ │ ├── productos.service.ts
	│ │ │ └── models/
	│ │ │   └── producto.model.ts
	│ │ ├── dashboard/
	│ │ │ ├── dashboard.component.ts
	│ │ │ ├── dashboard.component.html
	│ │ │ └── dashboard.component.scss
	│ │ ├── forbidden/
	│ │ │ ├── forbidden.component.ts
	│ │ │ ├── forbidden.component.html
	│ │ │ └── forbidden.component.scss
	│ │ ├── login/
	│ │ │ ├── login.component.ts
	│ │ │ ├── login.component.html
	│ │ │ └── login.component.scss
	│ │ └── productos/
	│ │   └── lista/
	│ │ 	├── lista.component.ts
	│ │ 	├── lista.component.html
	│ │ 	└── lista.component.scss
	│ ├── assets/
	│ ├── environments/
	│ │ ├── environment.ts
	│ │ └── environment.prod.ts
	│ └── main.ts
	├── angular.json
	├── package.json
	├── tsconfig.json
	└── README.md
\end{verbatim}
\subsection{Buenas prácticas generales con gestores.}

\begin{itemize}
	\item \emph{No mezclar gestores} en un mismo proyecto: use \textbf{uno} y mantenga su \emph{lockfile} (\texttt{package-lock.json}, \texttt{pnpm-lock.yaml}, \texttt{yarn.lock} o \texttt{bun.lockb}) bajo control de versiones.
	\item \emph{Instalación reproducible:} en CI prefiera \texttt{npm ci}, \texttt{pnpm install --frozen-lockfile} o equivalentes, para respetar versiones exactas.
	\item \emph{Scripts uniformes:} ejecute tareas vía \texttt{npm run}/\texttt{pnpm run}/\texttt{yarn run}/\texttt{bun run} y documente los scripts en \texttt{package.json}.
	\item \emph{Compatibilidad Angular--Node:} antes de actualizar Node o Angular, consulte la tabla de compatibilidades de Angular y actualice la CLI con \texttt{ng update} siguiendo los pasos sugeridos por el \emph{schematic}.
\end{itemize}

\subsection{Ecosistema, Pruebas y Despliegue}
Angular CLI automatiza \emph{scaffolding}, pruebas, linting y compilación (Vite + esbuild en versiones recientes); la documentación oficial cubre guías de arquitectura, \emph{i18n}, accesibilidad y pruebas \cite{AngularCLI2025,AngularSetupLocal2025}.

\subsubsection{Accesibilidad y SEO}
Priorice semántica (roles ARIA, orden de tabulación, manejo de foco), contraste de color y etiquetas de formulario. Para SEO en SPA, gestione metadatos (\texttt{title}, \texttt{meta}) a nivel de ruta (p.\,ej., \texttt{react-helmet-async}) o emplee SSR/SSG cuando el \emph{crawler} lo requiera \cite{ReactA11y,HelmetAsync}.

\subsubsection{Comandos Frecuentes (front-end).}
\begin{lstlisting}[mathescape=false]
	# crear/servir/construir
	ng new <app> [--routing --style=scss]
	ng serve -o
	ng build --configuration production
	
	# generar artefactos
	ng generate component productos/lista
	ng generate service core/productos
	ng generate guard auth/auth
	ng generate interceptor core/http/auth
	
	# utilidades
	ng test
	ng e2e
	ng lint
	ng add @angular/material
	ng update
	ng deploy \end{lstlisting}

\subsubsection{Comandos Frecuentes (back-end con Spring Boot).}
\begin{lstlisting}[mathescape=false]
	# Maven
	mvn spring-boot:run
	mvn clean package
	mvn test
	mvn clean package -DskipTests
	
	# Gradle
	./gradlew bootRun
	./gradlew build
	
	# Inicialización del proyecto (web)
	# https://start.spring.io (Spring Initializr)
\end{lstlisting}

\subsection{Rendimiento y Escalabilidad}

\subsubsection{Estrategias Clave (Teoría $\rightarrow$ Práctica).}
\begin{enumerate}
	\item \textbf{División de código por rutas (lazy loading)} para reducir el TTI inicial.\vspace{0.3cm}
	\textit{Ejemplo} (carga diferida de \texttt{productos}):
	\begin{lstlisting}[mathescape=false]
		// app.routes.ts
		export const routes = [
		{ path: '', loadComponent: () => import('./home/home.component') },
		{
			path: 'productos',
			loadChildren: () => import('./productos/routes').then(m => m.PRODUCT_ROUTES)
		}
		];
		
		// productos/routes.ts
		import { Routes } from '@angular/router';
		export const PRODUCT_ROUTES: Routes = [
		{ path: '', loadComponent: () => import('./lista/lista.component') },
		{ path: 'nuevo', loadComponent: () => import('./form/form.component') }
		];\end{lstlisting}
	\item \textbf{Cambio de detección eficiente}. Use el flujo reactivo (\emph{signals}/RxJS) y vistas diferibles para evitar trabajo innecesario; en listas, emplee \texttt{track} en el nuevo control de flujo para minimizar \emph{DOM diff}.
	\textit{Ejemplo}:
	\begin{lstlisting}[mathescape=false]
		<!-- Angular control flow moderno -->
		@for (p of productos; track p.id) {
			<app-item [producto]="p" />
	} \end{lstlisting}
	
	\item \textbf{Uso correcto de RxJS} (evitar fugas y \emph{work duplication}). \\\textit{Ejemplo}: cachear lecturas con \texttt{shareReplay(1)} y cancelar peticiones con \texttt{switchMap} \cite{RxJSObservableGuide,RxJSOperators}.
	\begin{lstlisting}[mathescape=false]
		productos$ = this.http.get<Producto[]>(`${env.api}/productos`)
		.pipe(shareReplay({ bufferSize: 1, refCount: true }));
		
		buscar(term$: Observable<string>) {
			return term$.pipe(
			debounceTime(250),
			0	distinctUntilChanged(),
			switchMap(q => this.http.get<Producto[]>(`${env.api}/productos`, { params: { q } }))
			);
	} \end{lstlisting}
	
	\item \textbf{Immutabilidad y \emph{pure pipes}} para minimizar renders; preferir funciones \emph{puras} en plantillas.
	
	\item \textbf{Optimizaciones de build}: \texttt{ng build --configuration production} activa minificación, eliminación de código muerto y presupuestos de \emph{bundles}. Configurar \texttt{budgets} para detectar regresiones.
	
	\item \textbf{SSR e hidratación} cuando SEO/TTFB son críticos. Angular v19+ añade hidratación incremental y mejoras en SSR; v20 estabiliza y acelera partes del \emph{pipeline} \cite{AngularReleasesV20}.
\end{enumerate}
\subsection{Seguridad, Pruebas e Integración Continua}

\subsubsection{Técnicas y Tecnologías Recomendadas}
\begin{enumerate}
	\item \textbf{Mitigaciones integradas de Angular}:
	\begin{itemize}
		\item \textit{Escapado en plantillas} por defecto y sanitización de HTML; evitar \texttt{bypassSecurityTrustXxx} salvo casos justificados \cite{AngularSecurity2025}.
		\item \textit{XSRF/CSRF cookie-to-header}: configure \texttt{withXsrfConfiguration} para alinear nombre de cookie/cabecera con el servidor (\texttt{XSRF-TOKEN}/\texttt{X-XSRF-TOKEN}) \cite{HttpClientXsrfConfig,AngularSecurity2025}.
		\begin{lstlisting}[mathescape=false]
			// main.ts
			provideHttpClient(
			withFetch(),
			withXsrfConfiguration({
				cookieName: 'XSRF-TOKEN',
				headerName: 'X-XSRF-TOKEN'
			})
			);
		\end{lstlisting}
	\end{itemize}
	
	\item \textbf{CORS bien definido en el back-end} (Spring Boot) \cite{SpringCorsGuide,SpringRESTTutorial}:
	\begin{lstlisting}[mathescape=false]
		// Java / Spring Security 6+
		@Bean
		SecurityFilterChain security(HttpSecurity http) throws Exception {
			http.csrf(csrf -> csrf.disable())
			.cors(Customizer.withDefaults())
			.authorizeHttpRequests(auth -> auth.anyRequest().permitAll());
			return http.build();
		}
		
		@Bean
		CorsConfigurationSource corsConfigurationSource() {
			var config = new CorsConfiguration();
			config.setAllowedOrigins(List.of("http://localhost:4200"));
			config.setAllowedMethods(List.of("GET","POST","PUT","DELETE"));
			config.setAllowedHeaders(List.of("Content-Type","Authorization","X-XSRF-TOKEN"));
			var source = new UrlBasedCorsConfigurationSource();
			source.registerCorsConfiguration("/**", config);
			return source;
		}
	\end{lstlisting}
	
	\item \textbf{Autenticación/JWT mediante \textit{interceptor}} en Angular \cite{AngularInterceptors2025}.
	\begin{lstlisting}[mathescape=false]
		// auth.interceptor.ts
		export const authInterceptor: HttpInterceptorFn = (req, next) => {
			const token = localStorage.getItem('token');
			const authReq = token
			? req.clone({ setHeaders: { Authorization: `Bearer ${token}` } })
			: req;
			return next(authReq);
		};
	\end{lstlisting}
	
	\item \textbf{CSP y Trusted Types} (cabeceras en servidor) para endurecer el DOM frente a XSS; Angular integra soporte con buenas prácticas modernas \cite{AngularSecurity2025,TrustedTypesMDN,TrustedTypesCaseStudy}.
	
	\item \textbf{Pruebas y CI/CD}: unitarias (\texttt{ng test}), \emph{e2e} (Cypress/Playwright), \emph{lint} (ESLint). Ejemplo mínimo de \textit{pipeline} GitHub Actions:
	\begin{lstlisting}[mathescape=false]
		# .github/workflows/ci.yml
		name: CI fullstack
		on: [push, pull\_request]
		jobs:
		frontend:
		runs-on: ubuntu-latest
		steps:
		- uses: actions/checkout@v4
		- uses: actions/setup-node@v4
		with: { node-version: '22' }
		- run: npm ci
		- run: npm run lint \&\& npm test -- --watch=false
		- run: npm run build
		backend:
		runs-on: ubuntu-latest
		steps:
		- uses: actions/checkout@v4
		- uses: actions/setup-java@v4
		with: { distribution: 'temurin', java-version: '21' }
		- run: mvn -B -DskipTests clean package
		- run: mvn test\end{lstlisting}
\end{enumerate}

\subsection{Fortalezas de Angular}

\begin{itemize}
	\item \textbf{Consistencia de arquitectura y tipado}: componentes, DI y \emph{routing} uniformes; HttpClient tipado y formularios reactivos estrictamente tipados reducen defectos \cite{AngularHTTP2025,AngularFormsReactive2025}.
	\item \textbf{\emph{Tooling} moderno y rendimiento de \emph{build}}: CLI con Vite/esbuild, soporte para división de código y presupuestos; mejoras continuas en v19--v20 \cite{AngularCLI2025,AngularReleasesV20}.
	\item \textbf{Seguridad por diseño}: sanitización, XSRF, guías de mejores prácticas y alineamiento con CSP/Trusted Types \cite{AngularSecurity2025}.
	\item \textbf{Ecosistema y documentación oficial extensa}: guías completas para \emph{routing}, HTTP, formularios, pruebas y despliegue \cite{AngularOverview2025,AngularRouting2025,AngularHTTP2025,AngularFormsReactive2025}.
\end{itemize}

% ----------------------------------------------------------------
% Ejemplo completo (de cero a proyecto funcional con LTS y CLI)
% Requisitos sugeridos en el preámbulo:
% ----------------------------------------------------------------

\subsection{Proyecto Funcional con Node LTS y Angular CLI}
El siguiente procedimiento crea un entorno reproducible con \textbf{Node.js LTS} y \textbf{Angular CLI}, genera una aplicación inicial, la ejecuta en desarrollo y produce artefactos listos para despliegue. Se incluyen rutas para \emph{Windows} (con \texttt{nvm-windows}) y para \emph{Linux/macOS} (con \texttt{nvm}).

\subsubsection{Preparación del Entorno (Selección de Node LTS)}
La preparación del entorno es el primer paso crítico en cualquier proyecto de desarrollo. Seleccionar la versión adecuada de Node.js garantiza que las librerías utilizadas por Angular funcionen de manera estable, ya que las versiones LTS (Long Term Support) son mantenidas con actualizaciones de seguridad y correcciones de errores durante un largo período. De este modo se evitan problemas de incompatibilidad al instalar dependencias y se asegura que el entorno de ejecución sea predecible y uniforme en diferentes equipos.

\paragraph{Windows (PowerShell) con \texttt{nvm-windows}.}
En el caso de Windows, la herramienta recomendada es \texttt{nvm-windows}, un gestor que permite instalar y cambiar entre distintas versiones de Node.js sin conflictos. Esto es especialmente útil para quienes trabajan en múltiples proyectos con requerimientos diferentes. El uso de comandos sencillos como \texttt{nvm install lts} y \texttt{nvm use lts} permite mantener el control sobre la versión en uso, evitando dependencias rotas o errores durante la compilación.

\begin{lstlisting}[mathescape=false]
	nvm install lts        # instala la última versión LTS disponible
	nvm use lts            # activa la versión LTS instalada
	node -v                # verifica versión activa de Node
	npm -v                 # verifica versión activa de npm \end{lstlisting}

\subsubsection{Linux/macOS con \texttt{nvm}.}
En sistemas Linux y macOS, el gestor equivalente es \texttt{nvm} (Node Version Manager). Su instalación habilita una administración flexible de las versiones de Node.js en entornos basados en Unix. De esta forma, el desarrollador puede probar aplicaciones en diferentes versiones sin necesidad de reinstalar manualmente el software. Esto es esencial para equipos distribuidos que buscan asegurar la reproducibilidad del entorno de desarrollo en distintos sistemas operativos.

\begin{lstlisting}[language=bash]
	# instalar NVM (si no lo tienes) y cargarlo en tu shell
	# consulta la doc oficial de nvm para el comando de instalación más reciente
	# luego:
	nvm install --lts
	nvm use --lts
	node -v
	npm -v \end{lstlisting}

\subsection{Instalar Angular CLI (Global) y Elegir Gestor de Paquetes}
Una vez que Node.js está instalado, el siguiente paso es incorporar la herramienta principal de Angular: la CLI (Command Line Interface). Esta interfaz permite generar proyectos, crear componentes, ejecutar pruebas y construir la aplicación de forma automática. Instalar la CLI de manera global simplifica el flujo de trabajo, ya que el desarrollador puede usar los comandos desde cualquier directorio sin configuración adicional.

\subsubsection{Instalación con \texttt{npm} (Opción Sencilla para Comenzar).}
La verificación posterior a la instalación es una práctica recomendable que asegura que la CLI se ha configurado correctamente. El comando \texttt{ng version} ofrece un resumen del entorno de trabajo, mostrando la versión activa de Angular CLI y las dependencias relacionadas. Esta comprobación resulta de gran utilidad para identificar inconsistencias y confirmar que el entorno cumple con los requisitos del proyecto.

\begin{lstlisting}[mathescape=false]
	npm install -g @angular/cli
	ng version             # verifica la CLI y versiones asociadas
\end{lstlisting}

\subsubsection{(Opcional) Establecer Gestor de Paquetes Preferido.}
Además de npm, Angular es compatible con otros gestores de paquetes modernos como \texttt{pnpm} y \texttt{yarn}, los cuales ofrecen mejoras en velocidad y eficiencia de almacenamiento. Mediante la herramienta Corepack, integrada en versiones recientes de Node.js, es posible habilitar y cambiar entre estos gestores sin necesidad de instalaciones externas. Esto otorga flexibilidad a los equipos de desarrollo y facilita la integración con distintos flujos de trabajo.

\begin{lstlisting}[mathescape=false]
	# si prefieres pnpm o yarn, actívalo con Corepack (Node 16.13+)
	corepack enable
	corepack prepare pnpm@latest --activate
	# o: corepack prepare yarn@stable --activate
\end{lstlisting}

\subsection{Crear el proyecto Angular}
La creación del proyecto Angular con la CLI ofrece una base sólida y organizada desde el inicio. Esta estructura incluye carpetas para los componentes, configuraciones para entornos, y archivos de compilación, lo que evita que el desarrollador tenga que construir manualmente la arquitectura inicial. Gracias a esto, se promueve la uniformidad en los proyectos y se reduce la probabilidad de errores de configuración.

\subsubsection{Estructura Inicial con Enrutamiento y \texttt{SCSS}.}
El uso de parámetros como \texttt{--routing} y \texttt{--style=scss} al generar el proyecto permite que la aplicación esté lista para soportar navegación entre páginas y trabajar con hojas de estilo más avanzadas. Estas opciones ahorran tiempo y simplifican tareas comunes en proyectos modernos, haciendo que incluso los principiantes puedan trabajar con prácticas recomendadas desde el inicio.

\begin{lstlisting}[mathescape=false]
	ng new tienda-app --routing --style=scss
	# si deseas fijar un gestor específico al crear:
	# ng new tienda-app --routing --style=scss --package-manager=pnpm
	cd tienda-app \end{lstlisting}

\subsubsection{Comprobación del Arranque en Desarrollo.}
Una vez creado el proyecto, es fundamental confirmar que el servidor de desarrollo se ejecute correctamente. El comando \texttt{ng serve} no solo levanta la aplicación en el navegador, sino que también habilita la recarga automática ante cambios en el código. Esto crea un ciclo de desarrollo rápido e interactivo, permitiendo validar cada ajuste de manera inmediata.

\begin{lstlisting}[mathescape=false]
	ng serve -o            # abre la app en http://localhost:4200 \end{lstlisting}

\subsection{Consumir una API (\texttt{mock} o Back-End Real) Durante el Desarrollo}
Para simular un back-end en las primeras etapas de desarrollo, se puede utilizar una herramienta ligera como \texttt{json-server}. Este paquete permite crear un servidor REST a partir de un archivo JSON, evitando la necesidad de implementar un servidor real. De esta forma, se facilita la validación de vistas y la integración de componentes de front-end sin depender de un sistema complejo.

\subsubsection{Opción A: Servidor simulado con \texttt{json-server}.}
El archivo de datos definido para \texttt{json-server} actúa como base de la API simulada. Su estructura imita la respuesta que un servidor real entregaría en formato JSON, lo que resulta ideal para que los principiantes comprendan cómo funcionan las peticiones HTTP. Esta aproximación acelera el desarrollo inicial, al mismo tiempo que prepara el terreno para integrar posteriormente un back-end completo.

\begin{lstlisting}[mathescape=false]
	npm i -D json-server
	# archivo de datos, p. ej. dev-data.json
	# {
		# "productos": [
		#   { "id": 1, "nombre": "Teclado", "precio": 25.9 },
		#   { "id": 2, "nombre": "Ratón",   "precio": 15.5 }
		# ]
		# }
	npx json-server --watch dev-data.json --port 3001 \end{lstlisting}

\subsubsection{Proxy de Desarrollo para Evitar \texttt{CORS}.}
El desarrollo moderno de aplicaciones web se encuentra con restricciones de seguridad como CORS (Cross-Origin Resource Sharing), que limitan las peticiones entre dominios distintos. Para facilitar la comunicación entre el front-end y un servidor simulado o real, Angular permite configurar un proxy que actúa como intermediario. Esta práctica es muy útil para evitar problemas de acceso durante la etapa de desarrollo local.

El archivo \texttt{proxy.conf.json} define cómo se deben redirigir las peticiones a rutas específicas, como \texttt{/api}, hacia el servidor adecuado. Este mecanismo elimina errores comunes relacionados con CORS y simplifica la comunicación entre la aplicación Angular y la API, ofreciendo un flujo de trabajo mucho más fluido.

Crea \texttt{proxy.conf.json} en la raíz del proyecto:
\begin{lstlisting}[mathescape=false]
	{
		"/api": {
			"target": "http://localhost:3001",
			"secure": false,
			"changeOrigin": true,
			"pathRewrite": { "^/api": "" }
		}
} \end{lstlisting}
Al ejecutar el servidor con el parámetro \texttt{--proxy-config}, Angular aplica la configuración de redirección definida en el archivo JSON. De esta manera, el desarrollador puede trabajar con rutas relativas como \texttt{/api/productos} sin preocuparse por las direcciones reales del back-end. Esto facilita la colaboración y el despliegue posterior, ya que la lógica de redirección queda centralizada.

Sirve la aplicación usando el proxy:
\begin{lstlisting}[mathescape=false]
	ng serve --proxy-config proxy.conf.json \end{lstlisting}

\subsubsection{Servicio Angular Mínimo para Consumir el \texttt{mock}.}
La generación automática de servicios y componentes mediante la CLI acelera el desarrollo y mantiene la consistencia del proyecto. Al crear un servicio como \texttt{ProductosService}, se logra separar la lógica de negocio de la interfaz, lo que permite un código más limpio y fácil de mantener. Del mismo modo, los componentes encapsulan la vista y la lógica asociada en una estructura modular.

Crea un servicio y un componente de lista:
\begin{lstlisting}[mathescape=false]
	ng generate service core/productos
	ng generate component productos/lista \end{lstlisting}

El servicio Angular se encarga de gestionar las solicitudes HTTP y devolver los datos al componente correspondiente. Al usar tipado fuerte y observables, se obtiene un código más confiable y expresivo, lo que simplifica el manejo de errores y la actualización de datos en tiempo real. Este patrón es especialmente útil en aplicaciones que dependen de múltiples fuentes de datos.

Ejemplo de \texttt{productos.service.ts}:

\begin{lstlisting}[language=bash]
	import { Injectable } from '@angular/core';
	import { HttpClient } from '@angular/common/http';
	import { Observable } from 'rxjs';
	
	export interface Producto { id: number; nombre: string; precio: number; }
	
	@Injectable({ providedIn: 'root' })
	export class ProductosService {
		private base = '/api/productos';
		constructor(private http: HttpClient) {}
		listar(): Observable<Producto[]> { return this.http.get<Producto[]>(this.base); }
} \end{lstlisting}
El componente de lista actúa como puente entre la interfaz y el servicio. Su responsabilidad principal es suscribirse a los datos expuestos por el servicio y mostrarlos de manera estructurada en la vista. De esta forma, el desarrollador se concentra únicamente en cómo presentar la información, delegando toda la lógica de acceso a datos al servicio.

Ejemplo de \texttt{lista.component.ts} y plantilla:
\begin{lstlisting}[mathescape=false]
	import { Component } from '@angular/core';
	import { ProductosService } from '../../core/productos.service';
	
	@Component({
		selector: 'app-lista',
		templateUrl: './lista.component.html'
	})
	export class ListaComponent {
		productos$ = this.svc.listar();
		constructor(private svc: ProductosService) {}
} \end{lstlisting}

La plantilla del componente, escrita en HTML enriquecido con directivas de Angular, facilita la representación dinámica de los productos. Gracias a la directiva \texttt{@for}, es posible recorrer colecciones de manera eficiente y mostrar la información con un mínimo de código. Esto no solo ahorra tiempo, sino que también permite construir interfaces más interactivas y reactivas.

\begin{lstlisting}[mathescape=false]
	<!-- lista.component.html -->
	<h2>Productos</h2>
	@for (p of productos$ | async; track p.id) {
		<div class="card">
		<strong>{{ p.nombre }}</strong> — {{ p.precio | currency:'USD' }}
		</div>
} \end{lstlisting}

Cuando se cuenta con un back-end real, como uno construido en Spring Boot, el desarrollo se orienta hacia la integración directa con servicios ya existentes. En este escenario, Angular consume datos provenientes de un servidor que gestiona usuarios, productos u otros recursos. Esto brinda una experiencia de desarrollo más cercana a la realidad del despliegue final.

\subsubsection{Opción B: Back-end Real (p. ej., Spring Boot).}
La configuración adecuada de cabeceras y políticas de CORS en el back-end es esencial para permitir que la aplicación Angular acceda a los recursos sin restricciones. Además, alinear medidas de seguridad como tokens CSRF/XSRF refuerza la protección contra ataques comunes, asegurando que las peticiones realizadas desde el cliente sean legítimas.

\begin{itemize}
	\item Apunta \texttt{base} a \texttt{http://localhost:8080/api/productos} o configura un proxy análogo al anterior.
	\item Habilita CORS en el servidor y alinea cabeceras de seguridad (XSRF si aplica).
\end{itemize}

El archivo \texttt{main.ts} en Angular es el punto de arranque de la aplicación, y en él se pueden registrar proveedores globales como el \texttt{HttpClient}. Configurar aspectos de seguridad desde esta capa garantiza que todos los módulos y componentes se beneficien de manera uniforme. Esto es clave para centralizar la lógica de comunicación con el servidor y evitar configuraciones dispersas.

\subsection{Configurar HttpClient y Seguridad Básica}
El uso de configuraciones de seguridad como \texttt{withXsrfConfiguration} permite que las peticiones HTTP incluyan automáticamente tokens que protegen contra ataques de falsificación de solicitudes. Al establecer estas medidas desde el inicio, incluso un desarrollador con poca experiencia puede contar con prácticas seguras sin necesidad de implementar soluciones manuales.

En \texttt{main.ts}, registra \texttt{HttpClient} y, si se necesita, XSRF:
\begin{lstlisting}[mathescape=false]
	import { bootstrapApplication } from '@angular/platform-browser';
	import { provideRouter } from '@angular/router';
	import { provideHttpClient, withFetch, withXsrfConfiguration } from '@angular/common/http';
	import { AppComponent } from './app/app.component';
	import { routes } from './app/app.routes';
	
	bootstrapApplication(AppComponent, {
		providers: [
		provideRouter(routes),
		provideHttpClient(
		withFetch(),
		withXsrfConfiguration({ cookieName: 'XSRF-TOKEN', headerName: 'X-XSRF-TOKEN' })
		)
		]
	}); \end{lstlisting}

La construcción para producción implica optimizar la aplicación de forma que el código resultante sea lo más eficiente posible. Esto incluye reducir el tamaño de los archivos, eliminar fragmentos de código innecesario y mejorar el rendimiento en la carga inicial. Con este paso, la aplicación deja de estar en modo de desarrollo y se transforma en un conjunto de archivos listos para ser desplegados en un entorno real.

\subsection{Construcción Optimizada para Producción}
El proceso de compilación también prepara el proyecto para escalar. Al dividir el código en fragmentos cargados bajo demanda, la aplicación mejora la experiencia del usuario final, ya que solo se descarga lo necesario en cada interacción. Este enfoque reduce tiempos de carga y optimiza el consumo de recursos en dispositivos con capacidades limitadas.

\subsubsection{Compilación y Salida en \texttt{dist/}.}
El comando de construcción en Angular genera un conjunto de artefactos optimizados dentro de la carpeta \texttt{dist/}. Este proceso transforma el código fuente en archivos estáticos listos para ser servidos por cualquier servidor web. Para los desarrolladores principiantes, este paso es esencial porque marca la transición entre la fase de desarrollo y la fase de despliegue, garantizando que la aplicación esté compacta, eficiente y adecuada para entornos de producción.

\begin{lstlisting}[mathescape=false]
	ng build --configuration production
	# Artefactos listos para desplegar (HTML, JS, CSS minificado y dividido por rutas). \end{lstlisting}

La salida de la carpeta \texttt{dist/} contiene HTML, JavaScript y CSS ya procesados, lo que simplifica su publicación en servicios como Nginx, Firebase Hosting o GitHub Pages. Gracias a las técnicas de minificación y división por rutas, la aplicación carga más rápido y consume menos recursos en el navegador del usuario. Este tipo de optimización es clave para asegurar una buena experiencia incluso en dispositivos con hardware limitado o en redes con baja velocidad.

\subsection{(Opcional) Reinstalar Dependencias ante Cambios de Versión de Node}
En ocasiones, al cambiar de versión de Node.js o actualizar dependencias, se pueden producir inconsistencias en módulos que requieren compilación nativa. Para evitar problemas, se recomienda reinstalar las dependencias desde cero, garantizando que se construyan en coherencia con la versión activa de Node. Esto asegura que la aplicación continúe funcionando correctamente tras los cambios en el entorno.

Si cambias la versión de Node o notas inconsistencias con módulos nativos:
\begin{lstlisting}[mathescape=false]
	# El uso de \texttt{nvm} en Linux/macOS o \texttt{nvm-windows} en Windows permite establecer rápidamente la versión adecuada de Node. Esta práctica ofrece una manera sencilla de volver a un estado estable, especialmente tras actualizar librerías que dependen de binarios específicos. El cambio de versión de Node se vuelve así una operación segura y controlada, evitando conflictos en el entorno de desarrollo.
	
	# PowerShell (Windows) o bash (Linux/macOS) según tu sistema
	# 1) Asegura la versión LTS activa
	nvm use lts            # Windows (nvm-windows)
	# o: nvm use --lts      # Linux/macOS
	
	# La eliminación manual de la carpeta \texttt{node\_modules} y la reinstalación de dependencias con \texttt{npm ci} aseguran que se usen exactamente las versiones definidas en el archivo de bloqueo. Esto evita divergencias entre distintos equipos y minimiza errores relacionados con librerías no compatibles. Además, \texttt{npm rebuild} recompila módulos nativos, corrigiendo problemas derivados de incompatibilidades con la ABI. Con este procedimiento, el entorno queda limpio y estable para continuar el desarrollo.
	
	# 2) Reinstalación limpia (respetando lockfile) con npm:
	Remove-Item -Recurse -Force node_modules	# PowerShell
	# o: rm -rf node_modules                    # Linux/macOS
	npm ci
	npm rebuild                                 # recompila bindings nativos si aplica \end{lstlisting}

Una verificación rápida de calidad antes del despliegue permite asegurar que los principales aspectos de la aplicación funcionen como se espera. Ejecutar pruebas unitarias, análisis estáticos y pruebas end-to-end ayuda a identificar errores comunes y posibles regresiones. Con ello se garantiza que el producto liberado sea más estable y confiable para el usuario final.

\subsection{(Opcional) Verificación Rápida de Calidad}
Las pruebas y el análisis estático ofrecen beneficios complementarios. Mientras que las pruebas unitarias validan la lógica en aislamiento, las pruebas end-to-end simulan escenarios reales de interacción, asegurando la integridad de los flujos críticos. Por su parte, el \texttt{lint} refuerza la consistencia del código y ayuda a detectar malas prácticas. Estos pasos, aunque opcionales en la etapa temprana, son altamente recomendados para proyectos en crecimiento.

\begin{lstlisting}[mathescape=false]
	ng test			# pruebas unitarias (si están configuradas)
	ng lint         # análisis estático (ESLint)
	ng e2e          # pruebas end-to-end (si están configuradas) \end{lstlisting}

El despliegue es el paso final en el ciclo de desarrollo. Una vez construida la aplicación, los archivos optimizados deben publicarse en un servidor o servicio de hosting. Esta etapa implica también configurar políticas de caché, seguridad y rutas adecuadas para que la aplicación funcione correctamente en un entorno de producción. Con un despliegue exitoso, la aplicación se convierte en una herramienta disponible para los usuarios finales.

\subsection{Despliegue}
Existen múltiples alternativas para desplegar una aplicación Angular. Servicios de hosting gratuitos como GitHub Pages permiten mostrar proyectos de prueba de manera sencilla, mientras que soluciones más robustas como Firebase Hosting, Azure Static Web Apps o servidores propios con Nginx ofrecen mayor control y flexibilidad. La elección del destino depende de las necesidades del proyecto, pero en todos los casos el objetivo es garantizar disponibilidad, rendimiento y seguridad a los usuarios que accedan a la aplicación.

\begin{lstlisting}[mathescape=false]
	# Subir la carpeta dist/tienda-app/ a tu hosting/CDN/servidor estático.
	# Ejemplos: Nginx, Firebase Hosting, GitHub Pages, Azure Static Web Apps, etc. \end{lstlisting}


\section{React}
\noindent React se ha consolidado como una biblioteca versátil para construir interfaces modernas, escalables y mantenibles, gracias a su arquitectura basada en componentes funcionales, el uso de \emph{hooks} para gestionar estado y efectos, y un \emph{tooling} flexible que se integra con Vite, ESLint, y soluciones de pruebas. En el contexto de aplicaciones empresariales que consumen servicios RESTful, React ofrece un modelo declarativo de UI, enrutamiento mediante React Router, clientes HTTP (p.\,ej., \texttt{fetch}/\texttt{axios}) y utilidades para internacionalización, pruebas e integración continua, lo que facilita un flujo de trabajo coherente desde el prototipo hasta la puesta en producción.

A partir de React 18, el modelo concurrente permite diferenciar actualizaciones urgentes de las no urgentes mediante \texttt{startTransition} y suavizar interfaces con \texttt{useDeferredValue}. Estas capacidades mejoran la responsividad bajo cargas pesadas y preparan la app para renderizado con \emph{streaming} y arquitecturas híbridas cliente/servidor \cite{React18Concurrent,ReactStartTransition,ReactDeferredValue}.

\subsection{Descripción y Propósito}
React es una biblioteca de desarrollo \textit{front-end} mantenida por Meta y una gran comunidad que proporciona un conjunto mínimo pero potente de primitivas para construir aplicaciones web de una sola página (SPA) con TypeScript/JavaScript, HTML y CSS. Se orienta tanto a equipos pequeños como a bases de código grandes, con un fuerte énfasis en composición de componentes, programación declarativa y \emph{tooling} interoperable.

\subsubsection{Configuración del Ambiente de Desarrollo}
\begin{enumerate}
	\item \textbf{Instalar Node.js LTS} (versión LTS activa o mantenimiento LTS). El \emph{tooling} de React (Vite, Jest, ESLint) depende de Node y del gestor de paquetes (npm, pnpm, yarn o bun).
	\begin{itemize}
		\item \textbf{Node.js LTS (Long-Term Support).}
		\begin{itemize}
			\item \emph{Qué es:} Node.js es el entorno de ejecución de JavaScript en el lado del servidor sobre el que corre el \emph{tooling} moderno de React (creación, \emph{dev server}, pruebas, \emph{build}).
			\item \emph{Por qué usar LTS:} las herramientas del ecosistema publican compatibilidades específicas; la línea LTS garantiza parches de seguridad y una API estable. En general, se recomienda la \textbf{LTS activa} y, si no es posible, la \textbf{LTS en mantenimiento}.
			\item \emph{Comprobar e instalar:}
			\begin{lstlisting}[mathescape=false]
				#Instalar en Linux
				curl -fsSL https://deb.nodesource.com/setup_lts.x | sudo -E bash -
				sudo apt-get install -y nodejs
				# Este método instala la versión LTS más reciente de Node.js y npm.
				
				#Después de instalar nodejs
				node -v       # Verificar versión instalada
				npm -v        # Verificar npm (gestor por defecto) \end{lstlisting}
			En Windows: Instalación con el instalador oficial
			
			\begin{enumerate}
				\item Ir a https://nodejs.org
				\item Descargar el instalador .msi (versión LTS recomendada).
				\item Ejecutar el instalador → siguiente, aceptar licencia, dejar las opciones por defecto.
				\item Verificar instalación en PowerShell o CMD:
				\begin{lstlisting}[mathescape=false]
					node -v
					npm -v \end{lstlisting}
				\item \emph{Consejo:} tras instalar/actualizar Node LTS, reinstale dependencias del proyecto para evitar inconsistencias del binario nativo (ver sección \ref{sec:reinstalacion}).
			\end{enumerate}
		\end{itemize}
		\item \textbf{CLI y tooling para React.}
		\begin{itemize}
			\item \emph{Qué es:} Aunque React no impone una CLI monolítica, el flujo moderno usa \textbf{Vite} para crear/servir/construir proyectos, y herramientas como \textbf{ESLint}, \textbf{Prettier}, \textbf{Jest} y \textbf{React Testing Library}.
			\item \emph{Relación con Node:} Todo el tooling se ejecuta sobre Node; requiere una versión compatible.
			\item \emph{Usar un gestor concreto por proyecto:} puede fijarlo al crear o configurar:
			
			\begin{lstlisting}[mathescape=false]
				# ejemplo con pnpm
				pnpm create vite tienda-react --template react-ts
				cd tienda-react
				pnpm install \end{lstlisting}
		\end{itemize}
		
		\item \textbf{Gestores de paquetes (npm, pnpm, yarn, bun).}
		\begin{itemize}
			\item \textbf{npm}
			\begin{itemize}
				\item \emph{Definición:} Gestor que viene con Node por defecto; mantiene \texttt{package.json} y \texttt{package-lock.json}.
				\item \emph{Características:} Amplio soporte, comandos estándar (\texttt{install}, \texttt{run}, \texttt{update}); integración inmediata con Vite y herramientas de pruebas.
				\item \emph{Ejemplos:}
				\begin{lstlisting}[mathescape=false]
					npm ci                 # instalación limpia desde package-lock.json
					npm run build          # ejecutar script "build"
					npm create vite@latest tienda-react -- --template react-ts \end{lstlisting}
				\item \emph{Cuándo elegirlo:} opción segura y universal; ideal si el equipo ya está familiarizado con npm.
			\end{itemize}
			
			\item \textbf{pnpm}
			\begin{itemize}
				\item \emph{Definición:} Gestor con \emph{store} compartida y enlaces simbólicos; bloquea con \texttt{pnpm-lock.yaml}.
				\item \emph{Características:} Instalaciones rápidas y eficientes en espacio; aislamiento estricto por proyecto.
				\item \emph{Ejemplos:}
				\begin{lstlisting}[mathescape=false]
					corepack enable pnpm
					pnpm create vite tienda-react --template react-ts
					pnpm install
					pnpm run build \end{lstlisting}
				\item \emph{Cuándo elegirlo:} monorepos o equipos que buscan reproducibilidad y velocidad.
			\end{itemize}
			
			\item \textbf{yarn}
			\begin{itemize}
				\item \emph{Definición:} Alternativa popular; usa \texttt{yarn.lock}. Existen \emph{Yarn Classic} (v1) y \emph{Berry} (v2+).
				\item \emph{Características:} Caché agresiva, \emph{workspaces}, y en Berry \emph{plug’n’play}.
				\item \emph{Ejemplos:}
				\begin{lstlisting}[mathescape=false]
					corepack enable yarn
					yarn create vite tienda-react --template react-ts
					yarn install
					yarn build \end{lstlisting}
				\item \emph{Cuándo elegirlo:} proyectos que ya usan Yarn o que necesitan workspaces específicos.
			\end{itemize}
			
			\item \textbf{bun}
			\begin{itemize}
				\item \emph{Definición:} Runtime alternativo JS/TS con gestor propio (\texttt{bun add}); bloquea con \texttt{bun.lockb}.
				\item \emph{Características:} Énfasis en rendimiento de instalación y ejecución; buena compatibilidad.
				\item \emph{Ejemplos:}
				\begin{lstlisting}[mathescape=false]
					bun create vite tienda-react --template react-ts
					bun install
					bun run build \end{lstlisting}
				\item \emph{Cuándo elegirlo:} si su equipo lo estandarizó y verificó compatibilidad. Para principiantes, comience con npm o pnpm.
			\end{itemize}
		\end{itemize}
		
		\item \textbf{Buenas prácticas generales con gestores.}
		\begin{itemize}
			\item \emph{No mezclar gestores} en un mismo proyecto: use \textbf{uno} y mantenga su \emph{lockfile} bajo control de versiones.
			\item \emph{Instalación reproducible:} en CI prefiera \texttt{npm ci}, \texttt{pnpm install --frozen-lockfile} o equivalentes.
			\item \emph{Scripts uniformes:} ejecute tareas vía \texttt{npm run}/\texttt{pnpm run}/\texttt{yarn run}/\texttt{bun run} y documente los scripts en \texttt{package.json}.
			\item \emph{Compatibilidad React--Node:} antes de actualizar Node o dependencias clave, revise requisitos de Vite, Jest, ESLint y React Router.
		\end{itemize}
		
		\item \textbf{Ejemplo completo (de cero a proyecto funcional con LTS y tooling).}
		\begin{itemize}
			\item \emph{Pasos:}
			\begin{lstlisting}[mathescape=false]
				# 1) Instalar Node LTS (vía NVM recomendado) y verificar:
				node -v
				npm -v
				
				# 2) Crear proyecto React + TypeScript (Vite):
				npm create vite@latest tienda-react -- --template react-ts
				cd tienda-react
				npm install
				
				# 3) Servir en desarrollo:
				npm run dev
				
				# 4) Construcción de producción:
				npm run build \end{lstlisting}
			\item \emph{Resultado:} aplicación React lista para desarrollo local y con artefactos en \texttt{dist/} para desplegar.
		\end{itemize}
	\end{itemize}
	
	Verifique:
	\item \emph{Comprobar e instalar:}
	\begin{lstlisting}[mathescape=false]
		node -v       # Verificar versión instalada
		npm -v        # Verificar npm (gestor por defecto) \end{lstlisting}
	\item \emph{Gestionar versiones con NVM (recomendado):}
	\begin{lstlisting}[mathescape=false]
		# Linux/macOS
		nvm install --lts
		nvm use --lts
		nvm alias default lts/*
		# Windows: usar nvm-windows (comandos análogos). \end{lstlisting}
	\item \emph{Instalación global (ejemplos):}
	\begin{lstlisting}[mathescape=false]
		# para crear proyectos con Vite (no requiere instalación global estricta)
		npm create vite@latest
		# alternativas
		pnpm create vite
		yarn create vite
		bun create vite \end{lstlisting}
	\item \emph{Verificar entorno de tooling:}
	\begin{lstlisting}[mathescape=false]
		node -v   # se recomienda LTS activo (p. ej., 20.x o 22.x)
		npm -v \end{lstlisting}
	
	\item \textbf{Crear el proyecto} (con React + TS y Vite):
	\begin{lstlisting}[mathescape=false]
		npm create vite@latest tienda-react -- --template react-ts
		cd tienda-react
		npm run dev \end{lstlisting}
	
	\item \textbf{Extensiones útiles de editor}: React/TypeScript IntelliSense, ESLint, Prettier.
	
	\item \textbf{Habilitar cliente HTTP y rutas} (configuración típica):
	\begin{lstlisting}[mathescape=false]
		// src/main.tsx (React + Vite)
		import React from 'react'
		import ReactDOM from 'react-dom/client'
		import { BrowserRouter } from 'react-router-dom'
		import App from './App.tsx'
		
		ReactDOM.createRoot(document.getElementById('root')!).render(
		<React.StrictMode>
		<BrowserRouter>
		<App />
		</BrowserRouter>
		</React.StrictMode>
		) \end{lstlisting}
	
	\item {Enrutamiento con Data Routers (v6.4+).} React Router incorpora \emph{data routers} (loaders/actions) que integran la obtención/mutación de datos al ciclo de enrutamiento, evitando duplicación de lógica en componentes y mejorando el manejo de estados de carga/errores \cite{ReactRouterData}.
	\begin{lstlisting}[mathescape=false]
		// src/router.tsx
		import { createBrowserRouter, RouterProvider } from 'react-router-dom';
		import App from './App';
		import { listarProductos } from './api/productos';
		
		const router = createBrowserRouter([
		{
			path: '/',
			element: <App />,
			children: [
			{
				path: 'productos',
				loader: async () => ({ productos: await listarProductos() })
			}
			]
		}
		]);
		
		// en main.tsx
		ReactDOM.createRoot(document.getElementById('root')!).render(
		<React.StrictMode>
		<RouterProvider router={router} />
		</React.StrictMode>
		);
	\end{lstlisting}
\end{enumerate}
\subsection[Reinstalación de Dependencias]{Reinstalación de Dependencias para Evitar Inconsistencias de Binarios Nativos\label{sec:reinstalacion}}
Cada comando empleado en la reinstalación de dependencias dentro del ecosistema Node.js no sólo tiene un efecto técnico inmediato, sino que responde a motivaciones prácticas en distintos contextos de desarrollo. A continuación se amplía el sentido de cada uno de los comandos ya descritos, mostrando cómo contribuyen a la estabilidad, reproducibilidad y mantenimiento de proyectos modernos.

El uso de \texttt{nvm use --lts} o \texttt{nvm use lts} en Windows responde a la necesidad de mantener sincronizada la versión de Node.js con la que el proyecto fue desarrollado. Un cambio de versión de Node puede provocar que dependencias con binarios nativos fallen, ya que la ABI varía entre versiones. Activar la versión LTS garantiza que se utilice un entorno estable y con soporte extendido, reduciendo riesgos en producción. En equipos de trabajo, este comando asegura que todos los integrantes compilen con la misma versión, evitando discrepancias en la ejecución del código.

La verificación con \texttt{node -v} cumple la función de confirmar que el entorno se ha configurado de manera correcta. Puede parecer trivial, pero al trabajar con múltiples versiones mediante NVM o nvm-windows, este chequeo es la única forma de asegurar que las herramientas CLI estén apuntando a la versión correcta. Esta práctica evita invertir tiempo en depuración de errores que provienen únicamente de la incompatibilidad de versiones.

Los comandos \texttt{rm -rf node\_modules} en sistemas Unix y \texttt{Remove-Item -Recurse -Force node\_modules} en Windows representan una limpieza radical de las dependencias instaladas. Aunque destructivos, son cruciales cuando los paquetes han quedado en un estado inconsistente, como ocurre después de una instalación interrumpida, un cambio de sistema operativo o un conflicto de versiones. Eliminar la carpeta completa asegura que en la siguiente instalación se generará un entorno totalmente coherente con los archivos de definición y bloqueo.

El comando \texttt{npm ci} se introdujo específicamente para los entornos de integración continua. Al reinstalar dependencias basándose estrictamente en \texttt{package-lock.json}, asegura la reproducibilidad de un entorno que ya fue validado. Esto significa que no se recalculan rangos de versiones ni se actualizan paquetes, lo que reduce drásticamente la posibilidad de divergencias entre la máquina de desarrollo y la de producción. Por su parte, \texttt{npm install} sigue siendo útil para la instalación inicial o cuando se quiere regenerar el lockfile, pues actualiza dependencias dentro de los rangos permitidos y refleja esos cambios en el archivo de bloqueo.

El comando \texttt{npm rebuild} atiende un problema particular: la incompatibilidad de módulos nativos. Muchas bibliotecas, como aquellas que usan \texttt{node-gyp}, generan binarios dependientes de la versión de Node y del sistema operativo. Al recompilarlos, se asegura que los ejecutables generados sean compatibles con la infraestructura actual. Complementariamente, la gestión de cachés con \texttt{npm cache verify} y \texttt{npm cache clean --force} resulta indispensable cuando se sospecha corrupción en los artefactos almacenados. Estas instrucciones evitan que se reutilicen archivos dañados en instalaciones futuras, garantizando integridad y confiabilidad.

La filosofía de \texttt{pnpm install --frozen-lockfile} es semejante a la de \texttt{npm ci}, pero con la ventaja de que pnpm gestiona un almacén global compartido de dependencias. Esto no solo incrementa la eficiencia en tiempo y espacio, sino que también exige que el lockfile se respete estrictamente, lo que refuerza la reproducibilidad en entornos de CI/CD. El comando \texttt{pnpm rebuild} resuelve inconsistencias de binarios, mientras que \texttt{pnpm store prune} mantiene el almacén limpio, eliminando versiones que ya no son referenciadas. Esto último evita el crecimiento innecesario del almacenamiento y optimiza el rendimiento del sistema.

En Yarn, los comandos \texttt{yarn install --frozen-lockfile}, \texttt{yarn rebuild} y \texttt{yarn cache clean} desempeñan roles análogos. Yarn destaca por su fuerte énfasis en entornos de trabajo colaborativo y monorepos, por lo que la instalación reproducible es esencial. El comando de reconstrucción es clave al migrar proyectos o actualizar Node.js, mientras que la limpieza de la caché previene que paquetes corruptos comprometan la instalación. Esta combinación asegura que los equipos trabajen sobre una base estable, independientemente de los entornos locales.

Finalmente, Bun aporta comandos equivalentes, como \texttt{bun install --frozen-lockfile} y \texttt{bun rebuild}, que refuerzan la reproducibilidad y compatibilidad en proyectos que apuestan por este nuevo runtime. Aunque más reciente, su filosofía es consistente con la de otros gestores: bloquear versiones para evitar inconsistencias y recompilar binarios nativos cuando cambian las condiciones del sistema. Esto lo convierte en una alternativa prometedora para quienes priorizan velocidad de instalación y ejecución, sin sacrificar la estabilidad del proyecto.

En conjunto, cada uno de estos comandos forma parte de un ecosistema de prácticas diseñadas para garantizar que los proyectos Node.js se mantengan coherentes, reproducibles y estables a lo largo del tiempo. Adoptarlos en el flujo de trabajo asegura que los equipos reduzcan errores derivados de diferencias de entorno, favoreciendo un desarrollo más profesional y confiable.

\subsection{Arquitectura y Modelo de Programación}
React adopta una arquitectura basada en componentes funcionales, composición y un enrutador externo (React Router); favorece patrones declarativos y reactividad mediante \emph{hooks}. Sus elementos nucleares incluyen componentes (vista y lógica), \emph{hooks} (estado y efectos), contextos para compartir estado, y herramientas de \emph{data fetching} (fetch/axios, React Query). El proceso de \emph{build} con Vite transpila/optimiza el código para producción.

\subsubsection{Gráfico de Arquitectura}
La Figura \ref{fig:arquitectura-react-spring} ilustra un flujo típico: componentes $\rightarrow$ capa de datos (fetch/axios o React Query) $\rightarrow$ interceptores/opciones $\rightarrow$ API REST de Spring Boot $\rightarrow$ capa de persistencia.

\begin{figure}[!hbt]
	\centering
	\begin{tikzpicture}[
		node distance=8mm,
		box/.style={draw,rounded corners,fill=gray!5,inner sep=3mm,align=center,blur shadow},
		arr/.style={-{Latex[length=2mm]},thick}
		]
		\node[box] (browser) {Navegador\\(React App)};
		\node[box,below=of browser] (cmp) {Componentes\\(UI, TSX/JSX)};
		\node[box,below=of cmp] (svc) {Capa de datos\\(fetch/axios, React Query)};
		\node[box,below=of svc] (intc) {Interceptors/Config\\(auth, logging, retry, baseUrl)};
		\node[box,below=of intc] (transport) {XHR/Fetch};
		
		\node[box,right=20mm of svc] (router) {React Router\\(rutas, loaders, actions)};
		
		\node[box,below=15mm of transport] (api) {API REST\\Spring Boot};
		\node[box,below=of api] (svcjava) {Capa Servicio\\(Spring)};
		\node[box,below=of svcjava] (repo) {Repositorio/JPA};
		\node[box,below=of repo] (db) {Base de Datos};
		
		\draw[arr] (browser) -- (cmp);
		\draw[arr] (cmp) -- (svc);
		\draw[arr] (svc) -- (intc);
		\draw[arr] (intc) -- (transport);
		\draw[arr] (transport) -- node[right]{HTTP JSON} (api);
		\draw[arr] (api) -- (svcjava);
		\draw[arr] (svcjava) -- (repo);
		\draw[arr] (repo) -- (db);
		\draw[arr] (cmp) -- (router);
	\end{tikzpicture}
	\textcolor{Orange}{\textbf{\caption{Arquitectura de consumo de API REST con React (front-end) y Spring Boot (back-end).\label{fig:arquitectura-react-spring}}}}
\end{figure}

\begin{itemize}
	\item \textbf{Proyecto React (estructura inicial de la aplicación).}
	\begin{itemize}
		\item \emph{Definición:} Conjunto de carpetas y archivos base creados por Vite que incluye la aplicación, configuración de construcción, pruebas (si se añaden), \texttt{tsconfig}, \texttt{package.json}, y recursos. Esta estructura estandarizada permite a cualquier equipo iniciar un proyecto con convenciones claras y repetibles.
		\item \emph{Características:} Soporte para enrutamiento opcional; estilos preconfigurables; estructura basada en componentes; scripts de \emph{build}/\emph{test}.
		\item \emph{Funcionalidades:} Punto de entrada \texttt{main.tsx}, \texttt{App} inicial, soporte para variables de entorno y arquitectura para separar UI, estado y acceso a datos.
		\item \emph{Ejemplo de uso:} Iniciar el desarrollo a partir de \texttt{App}, añadir React Router y un cliente HTTP e implementar la primera vista de inicio (ver Figura \ref{fig:estructura-react}).
		
		\begin{figure}[!hbt]
			\centering
			\begin{verbatim}
				tienda-react/
				├── src/
				│   ├── App.tsx
				│   ├── main.tsx
				│   ├── api/
				│   │   └── productos.ts
				│   ├── components/
				│   │   └── ListaProductos.tsx
				│   ├── assets/
				│   └── styles/
				├── index.html
				├── package.json
				├── tsconfig.json
				└── vite.config.ts \end{verbatim}
			\textcolor{Orange}{\textbf{\caption{Estructura típica de un proyecto React generado con Vite. \label{fig:estructura-react}}}}
		\end{figure}
		
		Aunque React no impone estructura, también se puede recomendar agrupar por \emph{features} o por niveles atómicos (atom/molecule/organism) para escalar mantenibilidad, como se muestra en la Figura \ref{fig:estructura-amo-react}
		\begin{figure}[!hbt]
			\centering
			\begin{verbatim}
				src/
				├── app/            # shell, providers globales
				├── features/
				│   └── productos/
				│       ├── api/
				│       ├── components/
				│       ├── hooks/
				│       └── pages/
				├── shared/         # ui, hooks, utils, tipos
				└── styles/\end{verbatim}
			\textcolor{Orange}{\textbf{\caption{Estructura típica de un proyecto React generado con Vite. \label{fig:estructura-amo-react}}}}
		\end{figure}
		
		Este enfoque reduce acoplamiento y facilita el \emph{code splitting} \cite{ReactStructure}.
		
	\end{itemize}
	
	\item \textbf{Servidor de desarrollo (\emph{dev server}) con recarga en caliente.}
	\begin{itemize}
		\item \emph{Definición:} Servidor local que sirve la aplicación en memoria y recompila al detectar cambios, con recarga instantánea de módulos (\emph{HMR}).
		\item \emph{Características:} El \emph{Hot Module Replacement} (HMR), “reemplazo en caliente de módulos”, evita recargar toda la app, conservando el estado mientras se actualizan partes modificadas. Se complementa con \emph{source maps} para depurar el código TypeScript/JSX con precisión.
		\item \emph{Funcionalidades:} Navegación inmediata para validar UI y flujos; integración de proxy en Vite para evitar CORS durante el desarrollo.
		\item \emph{Ejemplo de uso:} Probar vistas y componentes mientras se edita el código; configurar el \texttt{server.proxy} de \texttt{vite.config.ts} para redirigir \texttt{/api} al back-end.
	\end{itemize}
	
	\item \textbf{Construcción de producción (\emph{build} optimizado).}
	\begin{itemize}
		\item \emph{Definición:} Generación de artefactos estáticos minificados en \texttt{dist/}, listos para despliegue.
		\item \emph{Características:} Minificación, eliminación de código muerto (\emph{tree-shaking}), división de código por rutas/componentes, comprobación de tamaños.
		\item \emph{Funcionalidades:} Produce HTML, JS y CSS optimizados; integra variables de entorno para producción.
		\item \emph{Ejemplo de uso:} Publicar \texttt{dist/} en un servidor estático, CDN o plataforma de hosting (p.\,ej., Nginx, Firebase Hosting).
	\end{itemize}
	
	\item \textbf{Componente \texttt{productos/lista}.}
	\begin{itemize}
		\item \emph{Definición:} Unidad de UI que encapsula JSX/TSX y estilos para listar productos.
		\item \emph{Características:} Enfoque declarativo; enlace de datos mediante \emph{state}/\emph{effects}; renderizado eficiente; memorización selectiva.
		\item \emph{Funcionalidades:} Renderiza una colección proveniente de un cliente HTTP; emite eventos (p.\,ej., seleccionar/editar) via \emph{callbacks}.
		\item \emph{Ejemplo de uso:} Consumir un \texttt{Promise<Producto[]>} con \texttt{useEffect}/\texttt{useState} o integrar React Query para manejar caché y revalidación.
	\end{itemize}
	
	\item \textbf{Servicio \texttt{core/productos}.}
	\begin{itemize}
		\item \emph{Definición:} Capa de acceso a datos y lógica compartida para productos (consumo de API).
		\item \emph{Características:} Funciones tipadas (\texttt{GET/POST/PUT/DELETE}); uso de \texttt{fetch}/\texttt{axios}. En este contexto, un \emph{hook} personalizado o React Query puede representar “la fuente” de datos que emite valores y actualiza componentes automáticamente.
		\item \emph{Funcionalidades:} Encapsula URLs, parámetros y mapeo de respuestas; centraliza reintentos, caché y manejo de errores.
		\item \emph{Ejemplo de uso:} \texttt{listar()}, \texttt{obtener(id)}, \texttt{crear(dto)}, \texttt{actualizar(id,dto)}, \texttt{eliminar(id)} consumidos por componentes y rutas.
	\end{itemize}
	\emph{Nota de caché/invalidación:} librerías como React Query y SWR proporcionan estrategias declarativas (p.\,ej., \texttt{staleTime}, \texttt{cacheTime}, invalidación por \texttt{queryKey}) para coherencia de datos, revalidación en segundo plano y control fino de estados de carga/errores, recomendables frente a \texttt{useEffect} manual cuando el proyecto escala \cite{TanStackQuery,SWR}.
	
	\item \textbf{Guardia de rutas (protección con React Router).}
	\begin{itemize}
		\item \emph{Definición:} Mecanismo que decide si una ruta puede activarse, implementado como \emph{wrapper} o \emph{loader}/\emph{action} que verifica sesión/roles.
		\item \emph{Características:} Integración con el enrutador; puede consultar estado de sesión/roles; redirecciones.
		\item \emph{Funcionalidades:} Protege áreas privadas; exige autenticación/autorización antes de renderizar componentes o rutas anidadas.
		\item \emph{Ejemplo de uso:} Validar \texttt{isLoggedIn()} o un \texttt{roleRequired}; en caso negativo, navegar a \texttt{/login}.
	\end{itemize}
	
	\item \textbf{Interceptor HTTP (axios).}
	\begin{itemize}
		\item \emph{Definición:} Filtro que intercepta solicitudes/respuestas HTTP para añadir cabeceras o tratar errores.
		\item \emph{Características:} Se registra en una instancia compartida; compatible con \texttt{axios}; cadena de interceptores.
		\item \emph{Funcionalidades:} Inserta \texttt{Authorization: Bearer <token>}; reintenta; centraliza manejo de 401/403/500.
		\item \emph{Ejemplo de uso:} Leer \texttt{localStorage} y clonar/ajustar la petición con \texttt{headers}; redirigir a \texttt{/login} en 401.
	\end{itemize}
	
	\item \textbf{Pruebas unitarias (\emph{unit tests}).}
	\begin{itemize}
		\item \emph{Definición:} Conjunto de \texttt{*.test.tsx} que validan componentes, utilidades y \emph{hooks}.
		\item \emph{Características:} React Testing Library para montar componentes; \emph{mocks}/\emph{spies}; ejecución en Jest o Vitest.
		\item \emph{Funcionalidades:} Detectar regresiones; medir cobertura; integrar en CI.
		\item \emph{Ejemplo de uso:} Probar que \texttt{listarProductos()} entrega datos y que la plantilla muestra el conteo esperado.
	\end{itemize}
	
	\item \textbf{Pruebas \emph{end-to-end} (E2E).}
	\begin{itemize}
		\item \emph{Definición:} Escenarios funcionales que automatizan la UI completa (navegación, formularios, respuestas del servidor).
		\item \emph{Características:} Ejecución en navegador real; \emph{selectors} robustos; \emph{stubs} de red (\emph{fixtures}).
		\item \emph{Funcionalidades:} Validar \emph{happy paths} y casos de error; garantizar integridad del flujo crítico antes de desplegar.
		\item \emph{Ejemplo de uso:} Caso “crear producto”: abrir formulario, completar campos, enviar, verificar notificación y presencia en la lista.
	\end{itemize}
	
	\item \textbf{Linter (análisis estático, ESLint).}
	\begin{itemize}
		\item \emph{Definición:} Reglas automáticas para estilo y calidad de código TypeScript/JSX.
		\item \emph{Características:} Reglas recomendadas para React; autofix; integración con editores y CI.
		\item \emph{Funcionalidades:} Estándares consistentes; detección temprana de \emph{anti-patterns}.
		\item \emph{Ejemplo de uso:} Bloquear un \emph{pull request} si la base no cumple reglas; ejecutar \emph{autofix} localmente.
	\end{itemize}
	
	\item \textbf{Paquete de componentes de interfaz (MUI/Chakra/Ant Design).}
	\begin{itemize}
		\item \emph{Definición:} Bibliotecas de UI basadas en sistemas de diseño (botones, \emph{dialogs}, \emph{tables}, formularios).
		\item \emph{Características:} Temas (claro/oscuro), tipografía, accesibilidad (ARIA).
		\item \emph{Funcionalidades:} Acelera la construcción de interfaces consistentes; integra tablas, formularios y diálogos.
		\item \emph{Ejemplo de uso:} Implementar una tabla de productos con paginación/filtro y un diálogo para crear/editar.
	\end{itemize}
	
	\item \textbf{Actualización de versión y migraciones.}
	\begin{itemize}
		\item \emph{Definición:} Proceso de actualización de React y librerías del ecosistema.
		\item \emph{Características:} Guiarse por \emph{release notes}; herramientas de \emph{codemods} cuando corresponda.
		\item \emph{Funcionalidades:} Mantener la base al día con mejoras de rendimiento, seguridad y nuevas APIs.
		\item \emph{Ejemplo de uso:} Migrar entre versiones mayores, ajustar configuración de Vite, React Router y TypeScript automáticamente con \emph{codemods} y guías.
	\end{itemize}
	
	\item \textbf{Despliegue (\emph{deploy}) de artefactos de \texttt{dist/}.}
	\begin{itemize}
		\item \emph{Definición:} Publicación de la aplicación ya construida en un entorno de producción o \emph{staging}.
		\item \emph{Características:} Integración con \emph{adapters} o acciones de despliegue (Firebase, GitHub Pages, servicios de hosting); soporte de rutas base.
		\item \emph{Funcionalidades:} Automatizar envío de \texttt{dist/} a un servidor; configurar cabeceras de caché y compresión en el destino.
		\item \emph{Ejemplo de uso:} Desplegar la SPA en un bucket estático con CDN y \emph{fallback} a \texttt{index.html} para el enrutador del cliente.
	\end{itemize}
\end{itemize}

\subsection{Ecosistema y Herramientas}
El flujo moderno con React automatiza \emph{scaffolding}, pruebas, linting y compilación mediante Vite (desarrollo rápido con HMR y \emph{build} optimizado), ESLint/Prettier (calidad y estilo), y bibliotecas como React Router, React Query, Jest/RTL, Cypress/Playwright y MUI. La documentación oficial y las guías de las librerías cubren arquitectura, \emph{i18n}, accesibilidad y pruebas.

\subsubsection{Comandos Frecuentes (front-end).}
\begin{lstlisting}[mathescape=false]
	# crear/servir/construir con Vite
	npm create vite@latest <app> -- --template react-ts
	cd <app>
	npm install
	npm run dev
	npm run build
	
	# generar artefactos (manual/esqueleto)
	# crear componentes/servicios con el editor o generadores de tu plantilla
	
	# utilidades
	npm test
	npm run lint
	# agregar UI (ejemplo MUI)
	npm install @mui/material @emotion/react @emotion/styled
	# actualizar dependencias (ejemplo)
	npm outdated && npm update
	# despliegue (ejemplo con gh-pages u otro host) \end{lstlisting}

\subsubsection{Comandos Frecuentes (back-end con Spring Boot).}
\begin{lstlisting}[mathescape=false]
	# Maven
	mvn spring-boot:run
	mvn clean package
	mvn test
	mvn clean package -DskipTests
	
	# Gradle
	./gradlew bootRun
	./gradlew build
	
	# Inicialización del proyecto (web)
	# https://start.spring.io (Spring Initializr) \end{lstlisting}

\subsection{Rendimiento y Escalabilidad}

\subsubsection{Estrategias Clave (Teoría $\rightarrow$ Práctica).}
\begin{enumerate}
	\item \textbf{División de código por rutas (lazy loading)} para reducir el TTI inicial.\vspace{0.3cm}
	\textit{Ejemplo} (carga diferida de \texttt{ProductosPage}):
	\begin{lstlisting}[mathescape=false]
		const ProductosPage = React.lazy(() => import('./pages/ProductosPage'));
		function App() {
			return (
			<React.Suspense fallback={<p>Cargando...</p>}>
			<ProductosPage />
			</React.Suspense>
			);
	} \end{lstlisting}
	Para una experiencia robusta, envuelva secciones \texttt{Suspense} con \emph{Error Boundaries} que capturen fallos de carga dinámica y permitan \emph{fallbacks} específicos o reintentos controlados \cite{ErrorBoundaries,ReactLazy}.
	
	\item \textbf{Renderizado eficiente}. Use \texttt{React.memo}, \texttt{useMemo} y \texttt{useCallback} para evitar trabajo innecesario; en listas, establezca \texttt{key} estables para minimizar \emph{diff} del DOM.
	\textit{Ejemplo}:
	\begin{lstlisting}[mathescape=false]
		{lista.map(p => (
			<Item key={p.id} producto={p} />
			))
	} \end{lstlisting}
	\item \textbf{Transiciones y diferimiento.} Use \texttt{startTransition} para marcar actualizaciones no urgentes (p.\,ej., filtrados costosos) y \texttt{useDeferredValue} para desacoplar la entrada del usuario de renders pesados y mantener la UI fluida \cite{ReactStartTransition,ReactDeferredValue}.
	
	\item \textbf{Uso correcto del cliente HTTP y caché}.\vspace{0.3cm}
	\textit{Ejemplo}: cachear lecturas con React Query y cancelar peticiones con \texttt{AbortController}.
	\begin{lstlisting}[mathescape=false]
		import { useQuery } from '@tanstack/react-query';
		function useProductos() {
			return useQuery({
				queryKey: ['productos'],
				queryFn: async () => (await fetch('/api/productos')).json(),
				staleTime: 60_000
			});
	} \end{lstlisting}
	
	\item \textbf{Inmutabilidad y funciones puras} para minimizar renders; evitar mutaciones directas del estado y preferir actualizaciones inmutables.
	
	\item \textbf{Optimizaciones de build}: \texttt{npm run build} con Vite activa minificación y \emph{tree-shaking}. Configure \emph{code splitting} usando importaciones dinámicas.
	
	\item \textbf{SSR e hidratación} cuando SEO/TTFB son críticos (p.\,ej., con Next.js).  La hidratación y el \emph{streaming} de HTML reducen la percepción de latencia.
\end{enumerate}

\subsection{Seguridad, Pruebas e Integración Continua}

\subsubsection{Técnicas y Tecnologías Recomendadas}
\begin{enumerate}
	\item \textbf{Mitigaciones integradas de React}:
	\begin{itemize}
		\item \textit{Escapado en JSX} por defecto; evitar \texttt{dangerouslySetInnerHTML} salvo casos justificados.
		\item \textit{CSRF/XSRF cookie-to-header}: alinear nombre de cookie/cabecera con el servidor (p.\,ej., \texttt{XSRF-TOKEN}/\texttt{X-XSRF-TOKEN}) si se usa protección CSRF.
	\end{itemize}
	\emph{HTML no confiable:} si debe renderizar HTML dinámico con \texttt{dangerouslySetInnerHTML}, aplique sanitización del lado cliente (p.\,ej., DOMPurify) y políticas de \emph{Content Security Policy} con \emph{nonce}/hashes; compleméntelo con \emph{Trusted Types} cuando sea factible \cite{DOMPurify,CSPTrustedTypes}.
	
	\item \textbf{CORS bien definido en el back-end} (Spring Boot):
	\begin{lstlisting}[mathescape=false]
		// Java / Spring Security 6+
		@Bean
		SecurityFilterChain security(HttpSecurity http) throws Exception {
			http.csrf(csrf -> csrf.disable())
			.cors(Customizer.withDefaults())
			.authorizeHttpRequests(auth -> auth.anyRequest().permitAll());
			return http.build();
		}
		
		@Bean
		CorsConfigurationSource corsConfigurationSource() {
			var config = new CorsConfiguration();
			config.setAllowedOrigins(List.of("http://localhost:5173"));
			config.setAllowedMethods(List.of("GET","POST","PUT","DELETE"));
			config.setAllowedHeaders(List.of("Content-Type","Authorization","X-XSRF-TOKEN"));
			var source = new UrlBasedCorsConfigurationSource();
			source.registerCorsConfiguration("/**", config);
			return source;
	} \end{lstlisting}
	
	\item \textbf{Autenticación/JWT mediante \textit{interceptor}} con axios.
	\begin{lstlisting}[mathescape=false]
		// src/lib/http.ts
		import axios from 'axios';
		export const http = axios.create({ baseURL: '/api' });
		http.interceptors.request.use(config => {
			const token = localStorage.getItem('token');
			if (token) config.headers.Authorization = `Bearer ${token}`;
			return config;
		}); \end{lstlisting}
	
	\item \textbf{CSP y Trusted Types} (cabeceras en servidor) para endurecer el DOM frente a XSS; combinar con reglas estricas en el \emph{build}.
	
	\item \textbf{Pruebas y CI/CD}: unitarias (Jest/RTL), \emph{e2e} (Cypress/Playwright), \emph{lint} (ESLint). Ejemplo mínimo de \textit{pipeline} GitHub Actions:
	\begin{lstlisting}[mathescape=false]
		# .github/workflows/ci.yml
		name: CI fullstack
		on: [push, pull_request]
		jobs:
		frontend:
		runs-on: ubuntu-latest
		steps:
		- uses: actions/checkout@v4
		- uses: actions/setup-node@v4
		with: { node-version: '22' }
		- run: npm ci
		- run: npm run lint && npm test -- --watch=false
		- run: npm run build
		backend:
		runs-on: ubuntu-latest
		steps:
		- uses: actions/checkout@v4
		- uses: actions/setup-java@v4
		with: { distribution: 'temurin', java-version: '21' }
		- run: mvn -B -DskipTests clean package
		- run: mvn test \end{lstlisting}
\end{enumerate}

\subsection{Fortalezas de React}
\begin{itemize}
	\item \textbf{Consistencia del modelo declarativo y composición}: componentes funcionales y \emph{hooks}; React Router y clientes HTTP encajan de forma natural en la arquitectura.
	\item \textbf{\emph{Tooling} moderno y rendimiento de \emph{build}}: Vite con HMR, \emph{code splitting} e integración con TypeScript.
	\item \textbf{Seguridad por diseño en \emph{bindings}}: JSX escapa contenido por defecto; buenas prácticas con CSP/Trusted Types en el servidor.
	\item \textbf{Ecosistema y documentación extensa}: guías completas para enrutamiento, HTTP, estado, pruebas y despliegue en el ecosistema de React.
\end{itemize}

% ----------------------------------------------------------------
% Ejemplo completo (de cero a proyecto funcional con LTS y tooling React)
% ----------------------------------------------------------------

\subsection{Proyecto Funcional con Node LTS y React (Vite)}
El siguiente procedimiento crea un entorno reproducible con \textbf{Node.js LTS} y \textbf{React} (con Vite), genera una aplicación inicial, la ejecuta en desarrollo y produce artefactos listos para despliegue. Se incluyen rutas para \emph{Windows} (con \texttt{nvm-windows}) y para \emph{Linux/macOS} (con \texttt{nvm}).

\subsubsection{Preparación del Entorno (Selección de Node LTS)}
La preparación del entorno es el primer paso crítico en cualquier proyecto de desarrollo. Seleccionar la versión adecuada de Node.js garantiza que las librerías utilizadas por React funcionen de manera estable, ya que las versiones LTS son mantenidas con actualizaciones de seguridad y correcciones de errores durante un largo período. De este modo se evitan problemas de incompatibilidad al instalar dependencias y se asegura que el entorno de ejecución sea predecible y uniforme en diferentes equipos.

\paragraph{Windows (PowerShell) con \texttt{nvm-windows}.}
En el caso de Windows, la herramienta recomendada es \texttt{nvm-windows}, un gestor que permite instalar y cambiar entre distintas versiones de Node.js sin conflictos. Esto es especialmente útil para quienes trabajan en múltiples proyectos con requerimientos diferentes. El uso de comandos sencillos como \texttt{nvm install lts} y \texttt{nvm use lts} permite mantener el control sobre la versión en uso, evitando dependencias rotas o errores durante la compilación.

\begin{lstlisting}[mathescape=false]
	nvm install lts        # instala la última versión LTS disponible
	nvm use lts            # activa la versión LTS instalada
	node -v                # verifica versión activa de Node
	npm -v                 # verifica versión activa de npm \end{lstlisting}

\paragraph{Linux/macOS con \texttt{nvm}.}
En sistemas Linux y macOS, el gestor equivalente es \texttt{nvm} (Node Version Manager). Su instalación habilita una administración flexible de las versiones de Node.js en entornos basados en Unix. De esta forma, el desarrollador puede probar aplicaciones en diferentes versiones sin necesidad de reinstalar manualmente el software. Esto es esencial para equipos distribuidos que buscan asegurar la reproducibilidad del entorno de desarrollo en distintos sistemas operativos.

\begin{lstlisting}[language=bash]
	# instalar NVM (si no lo tienes) y cargarlo en tu shell
	# consulta la doc oficial de nvm para el comando de instalación más reciente
	# luego:
	nvm install --lts
	nvm use --lts
	node -v
	npm -v \end{lstlisting}

\subsubsection{Instalar React (Tooling Global) y Elegir Gestor de Paquetes}
Una vez que Node.js está instalado, el siguiente paso es contar con el \emph{tooling} principal: Vite para crear y servir proyectos y, opcionalmente, utilidades como \texttt{create-react-app} (legado), ESLint y Prettier. Instalar y usar estas herramientas simplifica el flujo de trabajo, ya que el desarrollador puede generar componentes, ejecutar pruebas y construir la aplicación de forma automática.

\paragraph{Instalación con \texttt{npm} (Opción Sencilla para Comenzar).}
La verificación posterior a la creación es una práctica recomendable que asegura que el proyecto se ha configurado correctamente. Los comandos \texttt{npm run dev} y \texttt{npm run build} ofrecen un resumen práctico de que el \emph{dev server} y la compilación funcionan adecuadamente en el entorno de trabajo.

\begin{lstlisting}[mathescape=false]
	npm create vite@latest tienda-react -- --template react-ts
	cd tienda-react
	npm install
	npm run dev             # verifica servidor y HMR \end{lstlisting}

\paragraph{(Opcional) Establecer Gestor de Paquetes Preferido.}
Además de npm, React funciona con \texttt{pnpm} y \texttt{yarn}, que ofrecen mejoras en velocidad y eficiencia de almacenamiento. Con Corepack (incluido en Node 16.13+), es posible habilitar y cambiar entre estos gestores sin instalaciones externas adicionales, lo que otorga flexibilidad y facilita la integración con distintos flujos de trabajo.

\begin{lstlisting}[mathescape=false]
	# si prefieres pnpm o yarn, actívalo con Corepack (Node 16.13+)
	corepack enable
	corepack prepare pnpm@latest --activate
	# o: corepack prepare yarn@stable --activate \end{lstlisting}

\subsubsection{Crear el proyecto React}
La creación del proyecto con Vite ofrece una base sólida y organizada desde el inicio. Esta estructura incluye carpetas para los componentes, configuraciones para entornos, y archivos de compilación, lo que evita que el desarrollador tenga que construir manualmente la arquitectura inicial. Gracias a esto, se promueve la uniformidad en los proyectos y se reduce la probabilidad de errores de configuración.

\paragraph{Estructura Inicial con Enrutamiento y \texttt{SCSS}.}
El uso del \emph{template} \texttt{react-ts} y la adición de React Router o estilos SCSS permite que la aplicación esté lista para soportar navegación entre páginas y trabajar con hojas de estilo avanzadas. Estas opciones ahorran tiempo y simplifican tareas comunes en proyectos modernos, incluso para principiantes.

\begin{lstlisting}[mathescape=false]
	npm create vite@latest tienda-react -- --template react-ts
	# si deseas fijar un gestor específico al crear:
	# pnpm create vite tienda-react --template react-ts
	cd tienda-react \end{lstlisting}

\paragraph{Comprobación del Arranque en Desarrollo.}
Una vez creado el proyecto, es fundamental confirmar que el servidor de desarrollo se ejecute correctamente. El comando \texttt{npm run dev} levanta la aplicación con HMR. Esto crea un ciclo de desarrollo rápido e interactivo, permitiendo validar cada ajuste de manera inmediata.

\begin{lstlisting}[mathescape=false]
	npm run dev            # abre la app en http://localhost:5173 \end{lstlisting}

\subsubsection{Consumir una API (\texttt{mock} o Back-End Real) Durante el Desarrollo}
Para simular un back-end en las primeras etapas de desarrollo, se puede utilizar una herramienta ligera como \texttt{json-server}. Este paquete permite crear un servidor REST a partir de un archivo JSON, evitando la necesidad de implementar un servidor real. De esta forma, se facilita la validación de vistas y la integración de componentes de front-end sin depender de un sistema complejo.

\paragraph{Opción A: Servidor simulado con \texttt{json-server}.}
El archivo de datos definido para \texttt{json-server} actúa como base de la API simulada. Su estructura imita la respuesta que un servidor real entregaría en formato JSON, lo que resulta ideal para que los principiantes comprendan cómo funcionan las peticiones HTTP. Esta aproximación acelera el desarrollo inicial, al mismo tiempo que prepara el terreno para integrar posteriormente un back-end completo.

\begin{lstlisting}[mathescape=false]
	npm i -D json-server
	# archivo de datos, p. ej. dev-data.json
	# {
		#   "productos": [
		#     { "id": 1, "nombre": "Teclado", "precio": 25.9 },
		#     { "id": 2, "nombre": "Ratón",   "precio": 15.5 }
		#   ]
		# }
	npx json-server --watch dev-data.json --port 3001 \end{lstlisting}

\paragraph{Proxy de Desarrollo para Evitar \texttt{CORS}.}
El desarrollo moderno de aplicaciones web se encuentra con restricciones de seguridad como CORS, que limitan las peticiones entre dominios distintos. Para facilitar la comunicación entre el front-end y un servidor simulado o real, Vite permite configurar un \emph{proxy} que actúa como intermediario. Esta práctica evita problemas de acceso durante el desarrollo local.

El \texttt{vite.config.ts} define cómo se deben redirigir las peticiones a rutas específicas, como \texttt{/api}, hacia el servidor adecuado. Este mecanismo elimina errores comunes relacionados con CORS y simplifica la comunicación entre la aplicación React y la API.

Crea/ajusta \texttt{vite.config.ts} en la raíz del proyecto:
\begin{lstlisting}[mathescape=false]
	import { defineConfig } from 'vite';
	import react from '@vitejs/plugin-react';
	
	export default defineConfig({
		plugins: [react()],
		server: {
			proxy: {
				'/api': {
					target: 'http://localhost:3001',
					changeOrigin: true,
					rewrite: path => path.replace(/^\/api/, '')
				}
			}
		}
	}); \end{lstlisting}
Al ejecutar el servidor de desarrollo, Vite aplica la configuración de redirección. Así se trabaja con rutas relativas como \texttt{/api/productos} sin preocuparse por las direcciones reales del back-end, lo que simplifica colaboración y despliegue posterior.

Sirve la aplicación usando el \emph{proxy}:
\begin{lstlisting}[mathescape=false]
	npm run dev \end{lstlisting}

\paragraph{Servicio React Mínimo para Consumir el \texttt{mock}.}
La estructuración en una carpeta \texttt{api/} con funciones \emph{fetcher} acelera el desarrollo y mantiene la consistencia del proyecto. Se separa la lógica de acceso a datos de la interfaz, permitiendo un código más limpio y fácil de mantener. Los componentes consumen estas funciones o \emph{hooks} personalizados.

Crea un módulo de datos y un componente de lista:

\begin{lstlisting}[mathescape=false]
	# (no hay generadores obligatorios; cree los archivos con el editor)
	# src/api/productos.ts
	# src/components/ListaProductos.tsx \end{lstlisting}

Ejemplo de \texttt{src/api/productos.ts}:

\begin{lstlisting}[language=bash]
	export type Producto = { id: number; nombre: string; precio: number };
	
	export async function listarProductos(): Promise<Producto[]> {
		const res = await fetch('/api/productos');
		if (!res.ok) throw new Error('Error de red');
		return res.json();
} \end{lstlisting}
El componente de lista actúa como puente entre la interfaz y la capa de datos. Su responsabilidad principal es invocar las funciones \emph{fetcher} y renderizar la información en la vista.

Ejemplo de \texttt{src/components/ListaProductos.tsx} y uso:

\begin{lstlisting}[mathescape=false]
	import * as React from 'react';
	import { listarProductos, type Producto } from '../api/productos';
	
	export function ListaProductos() {
		const [datos, setDatos] = React.useState<Producto[]>([]);
		const [cargando, setCargando] = React.useState(true);
		const [error, setError] = React.useState<string | null>(null);
		
		React.useEffect(() => {
			listarProductos()
			.then(setDatos)
			.catch(e => setError(e.message))
			.finally(() => setCargando(false));
		}, []);
		
		if (cargando) return <p>Cargando...</p>;
		if (error)    return <p>Error: {error}</p>;
		
		return (
		<section>
		<h2>Productos</h2>
		{datos.map(p => (
			<div key={p.id} className="card">
			<strong>{p.nombre}</strong> — ${'{'}p.precio{'}'}
			</div>
			))}
		</section>
		);
} \end{lstlisting}

Cuando se cuenta con un back-end real, como uno construido en Spring Boot, el desarrollo se orienta hacia la integración directa con servicios ya existentes. En este escenario, React consume datos provenientes de un servidor que gestiona usuarios, productos u otros recursos. Esto brinda una experiencia de desarrollo cercana a la realidad del despliegue final.

\paragraph{Opción B: Back-end Real (p. ej., Spring Boot).}
La configuración adecuada de cabeceras y políticas de CORS en el back-end es esencial para permitir que la aplicación React acceda a los recursos sin restricciones. Además, el alineamiento de medidas de seguridad como tokens CSRF/XSRF refuerza la protección contra ataques comunes, asegurando que las peticiones desde el cliente sean legítimas.

\begin{itemize}
	\item Apunta el \emph{baseURL} del cliente HTTP a \texttt{http://localhost:8080/api} o configura un \emph{proxy} análogo al anterior.
	\item Habilita CORS en el servidor y alinea cabeceras de seguridad (XSRF si aplica).
\end{itemize}

El archivo \texttt{src/lib/http.ts} puede centralizar la instancia de \texttt{axios} y sus interceptores, garantizando que todos los módulos y componentes se beneficien de manera uniforme y evitando configuraciones dispersas.

\subsubsection{Configurar Cliente HTTP y Seguridad Básica}
El uso de configuraciones de seguridad como XSRF cookie-to-header permite que las peticiones HTTP incluyan automáticamente tokens que protegen contra ataques de falsificación de solicitudes. Al establecer estas medidas desde el inicio, incluso un desarrollador con poca experiencia puede contar con prácticas seguras sin necesidad de implementar soluciones manuales.

En un módulo compartido, registre un cliente con interceptor:
\begin{lstlisting}[mathescape=false]
	// Ejemplo de XSRF cookie-to-header si el servidor emite "XSRF-TOKEN" (cookie)
	import Cookies from 'js-cookie';
	http.interceptors.request.use(config => {
		const xsrf = Cookies.get('XSRF-TOKEN');
		if (xsrf) config.headers['X-XSRF-TOKEN'] = xsrf;
		return config;
	});\end{lstlisting}
\noindent Ajuste nombres de cookie/cabecera para alinearlos con el servidor (p.\,ej., Spring Security) \cite{SpringSecurityCSRF}.

La construcción para producción implica optimizar la aplicación de forma que el código resultante sea lo más eficiente posible. Esto incluye reducir el tamaño de los archivos, eliminar fragmentos de código innecesario y mejorar el rendimiento en la carga inicial. Con este paso, la aplicación deja de estar en modo de desarrollo y se transforma en un conjunto de archivos listos para desplegar.

\subsubsection{Construcción Optimizada para Producción}
El proceso de compilación también prepara el proyecto para escalar. Al dividir el código en fragmentos cargados bajo demanda, la aplicación mejora la experiencia del usuario final, ya que solo se descarga lo necesario en cada interacción. Este enfoque reduce tiempos de carga y optimiza el consumo de recursos en dispositivos con capacidades limitadas.

\paragraph{Compilación y Salida en \texttt{dist/}.}
El comando de construcción con Vite genera un conjunto de artefactos optimizados dentro de la carpeta \texttt{dist/}. Este proceso transforma el código fuente en archivos estáticos listos para ser servidos por cualquier servidor web. Para los desarrolladores principiantes, este paso es esencial porque marca la transición entre la fase de desarrollo y la fase de despliegue, garantizando que la aplicación esté compacta, eficiente y adecuada para entornos de producción.

\begin{lstlisting}[mathescape=false]
	npm run build
	# Artefactos listos para desplegar (HTML, JS, CSS minificado y dividido por rutas). \end{lstlisting}

La salida de la carpeta \texttt{dist/} contiene HTML, JavaScript y CSS ya procesados, lo que simplifica su publicación en servicios como Nginx, Firebase Hosting o GitHub Pages. Gracias a las técnicas de minificación y división por rutas, la aplicación carga más rápido y consume menos recursos en el navegador del usuario.

\subsubsection{(Opcional) Reinstalar Dependencias ante Cambios de Versión de Node}
En ocasiones, al cambiar de versión de Node.js o actualizar dependencias, se pueden producir inconsistencias en módulos que requieren compilación nativa. Para evitar problemas, se recomienda reinstalar las dependencias desde cero, garantizando que se construyan en coherencia con la versión activa de Node. Esto asegura que la aplicación continúe funcionando correctamente tras los cambios en el entorno.

Si cambias la versión de Node o notas inconsistencias con módulos nativos:

\begin{lstlisting}[mathescape=false]
	# El uso de nvm/nvm-windows permite establecer rápidamente la versión adecuada de Node
	# y volver a un estado estable tras actualizar librerías con binarios específicos.
	
	# PowerShell (Windows) o bash (Linux/macOS) según tu sistema
	# 1) Asegura la versión LTS activa
	nvm use lts            # Windows (nvm-windows)
	# o: nvm use --lts      # Linux/macOS
	
	# La eliminación manual de node_modules y la reinstalación con "npm ci" aseguran
	# versiones exactas según el lockfile. "npm rebuild" recompila módulos nativos.
	
	# 2) Reinstalación limpia (respetando lockfile) con npm:
	Remove-Item -Recurse -Force node_modules	# PowerShell
	# o: rm -rf node_modules                    # Linux/macOS
	npm ci
	npm rebuild                                 # recompila bindings nativos si aplica \end{lstlisting}

Una verificación rápida de calidad antes del despliegue permite asegurar que los principales aspectos de la aplicación funcionen como se espera. Ejecutar pruebas unitarias, análisis estáticos y pruebas end-to-end ayuda a identificar errores comunes y posibles regresiones.

\subsubsection{(Opcional) Verificación Rápida de Calidad}
Las pruebas y el análisis estático ofrecen beneficios complementarios. Mientras que las pruebas unitarias validan la lógica en aislamiento, las pruebas end-to-end simulan escenarios reales de interacción, asegurando la integridad de los flujos críticos. Por su parte, el \texttt{lint} refuerza la consistencia del código y ayuda a detectar malas prácticas. Estos pasos, aunque opcionales en la etapa temprana, son altamente recomendados para proyectos en crecimiento.

\begin{lstlisting}[mathescape=false]
	npm test         # pruebas unitarias (si están configuradas)
	npm run lint     # análisis estático (ESLint)
	# npx cypress run / npx playwright test     # E2E (si están configuradas) \end{lstlisting}

El despliegue es el paso final en el ciclo de desarrollo. Una vez construida la aplicación, los archivos optimizados deben publicarse en un servidor o servicio de hosting. Esta etapa implica también configurar políticas de caché, seguridad y rutas adecuadas para que la aplicación funcione correctamente en un entorno de producción. Con un despliegue exitoso, la aplicación se convierte en una herramienta disponible para los usuarios finales.

\subsubsection{Despliegue}
Existen múltiples alternativas para desplegar una aplicación React. Servicios de hosting gratuitos como GitHub Pages permiten mostrar proyectos de prueba de manera sencilla, mientras que soluciones más robustas como Firebase Hosting, Azure Static Web Apps o servidores propios con Nginx ofrecen mayor control y flexibilidad. La elección del destino depende de las necesidades del proyecto, pero en todos los casos el objetivo es garantizar disponibilidad, rendimiento y seguridad a los usuarios que accedan a la aplicación.

Para SEO/TTFB críticos o personalización en el servidor, utilice SSR/SSG con Next.js, que soporta \emph{React Server Components}, \emph{streaming} e hidratación encajada (\emph{partial}) por defecto. Como alternativa flexible, Vite ofrece SSR con configuración manual de \emph{render} del lado servidor e hidratación en cliente, útil cuando se desea mantener el \emph{stack} ligero \cite{NextSSR,ReactServerComponents,ViteSSR}.

\begin{lstlisting}[mathescape=false]
	# Subir la carpeta dist/tienda-react/ a tu hosting/CDN/servidor estático.
	# Ejemplos: Nginx, Firebase Hosting, GitHub Pages, Azure Static Web Apps, etc. \end{lstlisting}
