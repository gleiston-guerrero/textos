\documentclass[12pt,twoside]{book}

%---------------------------------------------------------
% Idioma español, con soporte de caracteres modernos
%---------------------------------------------------------
\usepackage[spanish, es-noquoting, es-noshorthands]{babel}

% Codificación recomendada
%\usepackage[utf8]{inputenc}
\usepackage{eurosym}
\usepackage{listings}

%\setmainfont{Latin Modern Roman}
\usepackage{longtable}
% Mejoras tipográficas
%\usepackage{lmodern}        % Fuente moderna compatible
\usepackage{microtype}      % Mejora espaciado y legibilidad
\microtypesetup{protrusion=true, expansion=true}
\usepackage{multirow}
%---------------------------------------------------------
% Matemáticas y símbolos
%---------------------------------------------------------
\usepackage{amsmath, amssymb, amsfonts}
\usepackage{csquotes}
%---------------------------------------------------------
% Paquetes gráficos y figuras
%---------------------------------------------------------
\usepackage{graphicx}
\usepackage{float}
\usepackage{caption}
\usepackage{subcaption}
\captionsetup{
	font=small,
	labelfont=bf,
	textfont=small
}
% TikZ y librerías necesarias para tus figuras
\usepackage{tikz}
\usetikzlibrary{positioning, arrows.meta, calc, shapes, backgrounds}

%---------------------------------------------------------
% Encabezados y pies de página
%---------------------------------------------------------
\usepackage{fancyhdr}

\pagestyle{fancy}
\fancyhead{}
\fancyhead[LE,RO]{\thepage}
\fancyhead[RE]{\leftmark}
\fancyhead[LO]{\rightmark}

% Ajuste recomendado por fancyhdr
\setlength{\headheight}{15pt}
\addtolength{\topmargin}{-2.5pt}

\renewcommand{\chaptermark}[1]{\markboth{#1}{}}
\renewcommand{\sectionmark}[1]{\markright{#1}}

%---------------------------------------------------------
% Hipervínculos y navegación en PDF
%---------------------------------------------------------
\usepackage[hidelinks]{hyperref}

%---------------------------------------------------------
% Listas mejoradas
%---------------------------------------------------------
\usepackage{enumitem}

%---------------------------------------------------------
% Bibliografía BibLaTeX con estilo IEEE
%---------------------------------------------------------
\usepackage[
backend=biber,
style=ieee,
sorting=none,
doi=true,
url=true
]{biblatex}
\DefineBibliographyStrings{spanish}{
	artno = {n.\adddot\space art\adddot}
}


\addbibresource{refs.bib}

%---------------------------------------------------------
% Espaciado y formato del documento
%---------------------------------------------------------
\usepackage{setspace}
\onehalfspacing

%---------------------------------------------------------
% Ajuste de tablas (tamaño y espaciado académico)
%---------------------------------------------------------
\usepackage{etoolbox}

% Tablas en tamaño menor y espaciado simple
\AtBeginEnvironment{tabular}{\small\singlespacing}
\AtBeginEnvironment{table}{\small\singlespacing}

\usepackage{geometry}
\geometry{
	letterpaper,
	left=3cm,
	right=2.5cm,
	top=3cm,
	bottom=3cm
}

\usepackage{tabularx}
\usepackage{array}

%\usepackage{textcomp}
%\usepackage{fontenc}

%========================================================
% Listados UPSAM 2.0 con colores (lstlisting)
%========================================================
% Requiere en el preámbulo:
\usepackage{xcolor}
% \usepackage{listings}
%
% (Opcional pero recomendable para acentos en comentarios/strings)
% \usepackage[T1]{fontenc}
% \usepackage[utf8]{inputenc} % si NO compila con LuaLaTeX/XeLaTeX
%========================================================

%-----------------------------
% Paleta de colores (ajustable)
%-----------------------------
\definecolor{upsamKeyword}{RGB}{0,76,153}     % palabras reservadas
\definecolor{upsamType}{RGB}{128,0,128}       % tipos (entero, real, cadena, lógico)
\definecolor{upsamId}{RGB}{0,102,0}           % identificadores
\definecolor{upsamInt}{RGB}{153,76,0}         % constantes enteras
\definecolor{upsamReal}{RGB}{153,0,76}        % constantes reales
\definecolor{upsamString}{RGB}{163,21,21}     % cadenas
\definecolor{upsamComment}{RGB}{120,120,120}  % comentarios { ... }
\definecolor{upsamOp}{RGB}{0,0,0}             % operadores
\definecolor{upsamBg}{RGB}{250,250,250}       % fondo suave
\definecolor{upsamFrame}{RGB}{220,220,220}    % marco

%--------------------------------------------------------
% Definición del lenguaje UPSAM (lstdefinelanguage)
%--------------------------------------------------------
\lstdefinelanguage{UPSAM}{
	sensitive=true,
	morecomment=[s]{\{}{\}},
	commentstyle=\color{upsamComment}\itshape,
	morestring=[b]",
	stringstyle=\color{upsamString},
	morekeywords=[1]{
		Algoritmo,Programa,Var,Inicio,Fin,
		Si,Entonces,Sino,FinSi,Fin\_Si,
		Mientras,Haga,FinMientras,Fin\_Mientras,
		Para,Hasta,Con,Paso,FinPara,Fin\_Para,
		Repetir,HastaQue,Hasta\_Que,
		Funcion,Function,Retornar,Devolver,FinFuncion,Fin\_Funcion, FinFunction, Fin\_Function
	},
	keywordstyle=[1]\color{upsamKeyword}\bfseries,
	morekeywords=[2]{ENTERO,REAL,CADENA,LOGICO,LÓGICO,VERDADERO,FALSO},
	keywordstyle=[2]\color{upsamType}\bfseries,
	morekeywords=[3]{MOD,DIV,AND,OR,NOT},
	keywordstyle=[3]\color{upsamOp}\bfseries,
	alsoletter={.},
	literate={0.0}{{\textcolor{upsamReal}{0.0}}}3
	{0.1}{{\textcolor{upsamReal}{0.1}}}3
	{0.2}{{\textcolor{upsamReal}{0.2}}}3
	{0.3}{{\textcolor{upsamReal}{0.3}}}3
	{0.4}{{\textcolor{upsamReal}{0.4}}}3
	{0.5}{{\textcolor{upsamReal}{0.5}}}3
	{0.6}{{\textcolor{upsamReal}{0.6}}}3
	{0.7}{{\textcolor{upsamReal}{0.7}}}3
	{0.8}{{\textcolor{upsamReal}{0.8}}}3
	{0.9}{{\textcolor{upsamReal}{0.9}}}3
	{<-}{{\textcolor{upsamOp}{<-}}}2
	{||}{{\textcolor{upsamOp}{||}}}2
	{|}{{\textcolor{upsamOp}{|}}}1
	{&}{{\textcolor{upsamOp}{\&}}}1
	{^}{{\textcolor{upsamOp}{\^{}}}}1
	{<<}{{\textcolor{upsamOp}{<<}}}2
	{>>}{{\textcolor{upsamOp}{>>}}}2
}

%--------------------------------------------------------
% Estilo global para listados UPSAM
% - Identificadores (variables, nombres) en otro color
%--------------------------------------------------------
\lstdefinestyle{upsamStyle}{
	language=UPSAM,
	basicstyle=\ttfamily\small,
	backgroundcolor=\color{upsamBg},
	frame=single,
	rulecolor=\color{upsamFrame},
	frameround=ffff,
	framesep=6pt,
	identifierstyle=\color{upsamId},
	literate=%
	*{0}{{\textcolor{upsamInt}{0}}}1
	{1}{{\textcolor{upsamInt}{1}}}1
	{2}{{\textcolor{upsamInt}{2}}}1
	{3}{{\textcolor{upsamInt}{3}}}1
	{4}{{\textcolor{upsamInt}{4}}}1
	{5}{{\textcolor{upsamInt}{5}}}1
	{6}{{\textcolor{upsamInt}{6}}}1
	{7}{{\textcolor{upsamInt}{7}}}1
	{8}{{\textcolor{upsamInt}{8}}}1
	{9}{{\textcolor{upsamInt}{9}}}1
	{0.0}{{\textcolor{upsamReal}{0.0}}}3
	{0.1}{{\textcolor{upsamReal}{0.1}}}3
	{0.2}{{\textcolor{upsamReal}{0.2}}}3
	{0.3}{{\textcolor{upsamReal}{0.3}}}3
	{0.4}{{\textcolor{upsamReal}{0.4}}}3
	{0.5}{{\textcolor{upsamReal}{0.5}}}3
	{0.6}{{\textcolor{upsamReal}{0.6}}}3
	{0.7}{{\textcolor{upsamReal}{0.7}}}3
	{0.8}{{\textcolor{upsamReal}{0.8}}}3
	{0.9}{{\textcolor{upsamReal}{0.9}}}3
	{<-}{{\textcolor{upsamOp}{<-}}}2
	{||}{{\textcolor{upsamOp}{||}}}2
	{|}{{\textcolor{upsamOp}{|}}}1
	{&}{{\textcolor{upsamOp}{\&}}}1
	{^}{{\textcolor{upsamOp}{\^{}}}}1
	{<<}{{\textcolor{upsamOp}{<<}}}2
	{>>}{{\textcolor{upsamOp}{>>}}}2,
	showstringspaces=false,
	tabsize=3,
	keepspaces=true,
	columns=fullflexible,
	numbers=left,
	numberstyle=\scriptsize\color{upsamComment},
	numbersep=10pt,
	breaklines=true,
	breakatwhitespace=true,
	captionpos=b
}


\lstset{
	basicstyle=\ttfamily\small,
	numbers=left,
	numberstyle=\tiny,
	stepnumber=1,
	numbersep=5pt,
	frame=single,
	columns=fullflexible,
	keepspaces=true,         % <<< Mantiene los espacios tal como están
	showspaces=false,         % <<< Opcional: muestra los espacios visualmente
	showtabs=false,           % <<< Muestra las tabulaciones
	tabsize=2,               % <<< Define cuántos espacios equivale una tabulación
	breaklines=true,
	inputencoding=utf8,
	extendedchars=true,
	literate=
	{á}{{\'a}}1 {é}{{\'e}}1 {í}{{\'i}}1 {ó}{{\'o}}1 {ú}{{\'u}}1
	{Á}{{\'A}}1 {É}{{\'E}}1 {Í}{{\'I}}1 {Ó}{{\'O}}1 {Ú}{{\'U}}1
	{ñ}{{\~n}}1 {Ñ}{{\~N}}1
	{¿}{{\textquestiondown}}1
	{¡}{{\textexclamdown}}1
}

\renewcommand{\arraystretch}{1.15}

%---------------------------------------------------------
% Inicio del documento
%---------------------------------------------------------

\usepackage[most]{tcolorbox}

\newtcolorbox{importantbox}{
	colback=gray!5,
	colframe=gray!70,
	boxrule=0.8pt,
	arc=4pt,
	left=8pt,
	right=8pt,
	top=6pt,
	bottom=6pt,
	enhanced,
	breakable
}

\usepackage{fontspec}

\setmainfont{Latin Modern Roman}

% Fuente para emoji (ajusta según tu sistema)
\newfontfamily\emojiFont{Segoe UI Emoji}

% Requiere:
% \usepackage{tikz}
% \usetikzlibrary{calc}

\newcommand{\AcadBubble}[2]{%
	\begin{center}
		\begin{tikzpicture}
			
			% Caja principal (texto)
			\node[
			draw=gray!65,
			fill=gray!5,
			rounded corners=3pt,
			line width=0.8pt,
			inner xsep=10pt,
			inner ysep=10pt,
			text width=0.92\linewidth,
			align=justify
			] (B) {\ignorespaces #2\unskip};
			
			% Pestaña de título (FUERA de la caja, arriba)
			\node[
			draw=gray!65,
			fill=gray!15,
			rounded corners=3pt,
			line width=0.8pt,
			inner xsep=12pt,
			inner ysep=6pt,
			anchor=south west
			] (T) at ([xshift=10pt,yshift=2pt]B.north west)
			{\textbf{\color{gray!85!black}#1}};
			
			% Ícono (círculo) a la izquierda de la pestaña, sin tapar texto
			\node[
			circle,
			draw=gray!65,
			fill=gray!25,
			line width=0.8pt,
			minimum size=7mm
			] at ([xshift=-6mm]T.west)
			{\scriptsize\bfseries\color{gray!85!black}i};
			
		\end{tikzpicture}
	\end{center}%
}

\addbibresource{refs.bib}

%---------------------------------------------------------
% Inicio del documento
%---------------------------------------------------------
\begin{document}
	
	\frontmatter
	
	\title{Programación Básica para Ingeniería en Sistemas de Información:\\
		De los Sistemas de Información al Código}
	\author{Gleiston Guerrero Ulloa}
	\date{}
	\maketitle
	
	\tableofcontents
	
	\chapter*{Prefacio}
	% Propósito del libro, público objetivo,
	% relación con la carrera de Ingeniería en Sistemas de Información,
	% resultado de aprendizaje de la asignatura,
	% recomendaciones de uso para estudiantes y docentes.
	
	\mainmatter
	
	%=========================================================
	% UNIDAD I
	%=========================================================
	%=========================================================
	\part{Fundamentos Computacionales para Sistemas de Información}
	%=========================================================	
		%---------------------------------------------------------
		\chapter{Sistemas de Información, Tecnología y Programación Aplicada}
		%---------------------------------------------------------
			\noindent
			La formación en Ingeniería en Sistemas de Información exige una comprensión articulada entre estructuras organizacionales y mecanismos computacionales. La programación constituye el medio formal mediante el cual las necesidades operativas se traducen en soluciones ejecutables, integrando procesos, datos y reglas de negocio dentro de arquitecturas tecnológicas coherentes. La literatura especializada sostiene que el desarrollo de aplicaciones fortalece la capacidad de análisis estructurado y modelización de problemas empresariales~\cite{Kendall2014Systems,Laudon2020Management}. El dominio de fundamentos computacionales permite diseñar sistemas alineados con dinámicas administrativas reales y con entornos tecnológicos sujetos a evolución constante.
			
			La disciplina integra personas, procesos y tecnología bajo un marco que combina análisis organizacional con implementación técnica. El software opera como mecanismo de materialización de políticas institucionales y controles operativos~\cite{Gonzalez-Longatt2007Introduccion}. Desde la ingeniería de software se establecen criterios de trazabilidad, consistencia y verificabilidad que inciden directamente en la calidad del sistema construido~\cite{Ghezzi2003Fundamentals}. El dominio de la programación habilita la construcción de aplicaciones capaces de gestionar inventarios, nóminas, transacciones financieras o registros académicos, ampliando el horizonte profesional del ingeniero y fortaleciendo su capacidad de intervención técnica en organizaciones de diversa escala.
			
			La actividad del desarrollador trasciende la mera codificación; involucra modelado estructural, definición de reglas formales y validación sistemática de resultados. La automatización administrativa demanda control preciso de estructuras condicionales, ciclos y manejo de datos~\cite{Hanly2015Problem}. Los estándares técnicos sobre prácticas seguras de programación proporcionan lineamientos que reducen defectos y aumentan la confiabilidad del software~\cite{ISO247722024Programming}. La práctica sostenida consolida disciplina analítica, rigor metodológico y responsabilidad profesional.
			
			Los sistemas de información transforman datos en insumos útiles para la gestión. La captura, almacenamiento y procesamiento algorítmico de registros digitales constituye la base operativa de dichos sistemas~\cite{Gaddis2022Starting}. La experiencia directa con estructuras de control y funciones permite observar cómo los datos adquieren significado operativo cuando son sometidos a transformaciones formales. Estudios sobre ecosistemas informacionales muestran que la organización estructurada de datos incrementa la capacidad analítica institucional~\cite{Calzati2025Ecosystemic}. La programación habilita participación activa en la construcción de estos mecanismos informacionales.
			
			La infraestructura computacional sostiene la ejecución de aplicaciones mediante la interacción coordinada entre procesadores, memoria y sistemas operativos~\cite{Stallings2021Computer}. La gestión de procesos y recursos, descrita en la teoría de sistemas operativos, determina el comportamiento observable del software en ejecución~\cite{Silberschatz2018Operating}. Conocer estos fundamentos permite escribir código que utilice racionalmente los recursos disponibles y que opere de manera estable en plataformas heterogéneas. La formación técnica proporciona criterio para evaluar rendimiento, eficiencia y adecuación arquitectónica.
			
			La representación digital introduce al estudiante en la estructura formal de los datos en memoria. El estándar IEEE 754 define la organización de números en punto flotante mediante campos de signo, exponente y fracción~\cite{IEEE2019Standard754}. El análisis clásico de errores de redondeo evidencia cómo pequeñas variaciones en la representación binaria influyen en cálculos posteriores~\cite{Goldberg1991What}. Este conocimiento favorece decisiones técnicas informadas al diseñar modelos financieros, estadísticos o administrativos que dependen de precisión numérica.
			
			La formulación rigurosa del problema computacional constituye la base del diseño de soluciones informacionales. La identificación sistemática de entradas, salidas y restricciones permite estructurar modelos verificables~\cite{Wirth1976Algorithms}. El diseño algorítmico proporciona criterios formales de finitud, precisión y corrección, garantizando coherencia interna en la solución implementada. La práctica continua en este ámbito fortalece el razonamiento estructurado y la capacidad de afrontar desafíos organizacionales mediante procedimientos definidos.
			
			El modelo curricular IS2020 plantea que el profesional en Sistemas de Información debe integrar análisis organizacional con implementación técnica en plataformas reales~\cite{Leidig2020Updating,Leidig2021Competency}. La programación actúa como puente entre teoría administrativa y ejecución tecnológica, permitiendo materializar procesos empresariales en sistemas operativos concretos. El dominio de estas competencias amplía oportunidades laborales y consolida una formación integral orientada a la transformación digital organizacional.
				
			\section{Ingeniería en Sistemas de Información y programación aplicada}
				\noindent
				La Ingeniería en Sistemas de Información (IS) se orienta a comprender, diseñar e implementar soluciones socio-técnicas en las que personas, procesos, datos y reglas organizacionales se integran mediante sistemas de software. En este ámbito, el software no se concibe como un producto aislado, sino como un mecanismo de coordinación y control que operacionaliza políticas, procedimientos y restricciones bajo condiciones reales de uso (tiempos, recursos, variabilidad y excepciones). Por ello, la programación adquiere relevancia formativa y profesional: permite convertir descripciones organizacionales en comportamientos ejecutables, verificables y mantenibles sobre plataformas tecnológicas concretas~\cite{Kendall2014Systems,Laudon2020Management,Tegarden2025Systems}.
				
				En un curso de programación básica para IS, el objetivo no consiste únicamente en “aprender un lenguaje”, sino en adquirir una capacidad transferible: representar problemas con precisión, diseñar soluciones paso a paso y expresar dichas soluciones como algoritmos que un computador pueda ejecutar sin ambigüedades. Esta capacidad se relaciona con el pensamiento computacional, que enfatiza abstracción, descomposición y formulación sistemática de procedimientos, habilidades útiles para contextos organizacionales donde los problemas suelen estar incompletos o descritos informalmente~\cite{Wing2006Computational,Perkovic2010Framework,Futschek2006Algorithmic}.
				
				Desde una perspectiva curricular basada en competencias, la programación se valida por su utilidad para intervenir en tareas reales de análisis, construcción e implementación de soluciones que atienden necesidades de actores y unidades organizacionales. En consecuencia, aprender a programar en IS implica articular conceptos (algoritmos, datos, control) con prácticas elementales de ingeniería (especificar, probar, documentar y mejorar), de modo que el estudiante avance desde ejercicios controlados hacia la resolución de problemas con significado organizacional~\cite{Leidig2021Competency,Leidig2020Updating,Laudon2020Management}.
				
				En este capítulo, la programación se presenta como una herramienta que permite: (i) formalizar procesos organizacionales mediante reglas explícitas; (ii) automatizar operaciones repetitivas con criterios de calidad; y (iii) producir resultados consistentes que sostienen decisiones. El desarrollo se mantiene deliberadamente en un nivel conceptual y de aprendizaje, reservando para secciones posteriores el tratamiento detallado de transformación digital, responsabilidades profesionales y ciclo de vida del dato, con el fin de evitar redundancias y preservar la progresión pedagógica~\cite{Kendall2014Systems,Tegarden2025Systems,Laudon2020Management}.
				
				\subsection{La programación como competencia profesional en Sistemas de Información}
					\noindent
					En IS, la programación se reconoce como una competencia transversal porque conecta el análisis del entorno organizacional con la implementación concreta de mecanismos de información, control y coordinación. Esta conexión no es abstracta: en la práctica profesional, decisiones operativas y administrativas quedan codificadas en reglas de validación, cálculos, flujos de trabajo y restricciones que el software ejecuta de manera consistente para múltiples usuarios y situaciones~\cite{Laudon2020Management,Kendall2014Systems,Tegarden2025Systems}.
					
					Para el estudiante que aprende a programar, esta transversalidad se traduce en una idea guía: un programa es una especificación ejecutable de un procedimiento. En términos formativos, ello exige dominar nociones fundamentales (variables, tipos, expresiones, estructuras de control, modularidad) y, al mismo tiempo, aprender a justificar la elección de una estrategia algorítmica frente a un requerimiento. Dicho aprendizaje se apoya en la disciplina algorítmica: claridad, finitud, corrección y trazabilidad entre el problema y la solución~\cite{Wirth1976Algorithms,Hanly2015Problem,Gaddis2022Starting}.
					
					Además, la programación fortalece habilidades de abstracción y descomposición aplicables a dominios no exclusivamente informáticos. La capacidad de separar un problema en subproblemas, definir entradas y salidas, y construir soluciones incrementales constituye un fundamento metodológico para diseñar soluciones organizacionales robustas, incluso cuando los requisitos iniciales son ambiguos o cambian con el contexto~\cite{Wing2006Computational,Perkovic2010Framework,Futschek2006Algorithmic}.
					
					Desde la perspectiva de IS2020, el dominio técnico adquiere valor cuando se integra con comprensión organizacional, comunicación y pensamiento crítico para producir soluciones utilizables. En consecuencia, aprender a programar debe orientarse a producir artefactos comprensibles, verificables y evolucionables, no únicamente a “hacer que el código funcione”~\cite{Leidig2021Competency,Leidig2020Updating,Tegarden2025Systems}.
					
					\subsubsection{Programación como medio de formalización de procesos organizacionales}
						\noindent
						Los procesos organizacionales suelen describirse mediante lenguaje natural, documentos operativos o acuerdos tácitos. Sin embargo, para ser automatizables y auditables requieren una traducción a reglas explícitas, condiciones y secuencias de acciones que un sistema pueda ejecutar de forma consistente. La programación cumple aquí una función de formalización: convierte decisiones, excepciones, validaciones y dependencias en estructuras algorítmicas precisas que reducen ambigüedades~\cite{Wirth1976Algorithms,Hanly2015Problem,Gaddis2022Starting}.
						
						En clave pedagógica, formalizar significa aprender a “cerrar” lo que el lenguaje natural deja abierto. Por ejemplo, una frase organizacional como “registrar la solicitud si está completa” obliga a precisar qué se entiende por completitud (campos obligatorios, formatos válidos, rangos aceptables) y qué ocurre si la condición falla (rechazo, corrección, notificación). Estos aspectos se expresan mediante condicionales, validaciones de entrada y manejo de casos límite, elementos básicos que estructuran el razonamiento del programador principiante~\cite{Hanly2015Problem,Gaddis2022Starting,ISO247722024Programming}.
						
						La formalización también exige representar con precisión los estados del proceso y sus transiciones. Aunque el modelamiento de procesos se tratará de manera más extensa en otras secciones, aquí basta destacar que la programación permite materializar estados como valores y condiciones (por ejemplo, “pendiente”, “aprobado”, “rechazado”), y transiciones como reglas que dependen de eventos y verificaciones. Esta correspondencia entre proceso y control de flujo introduce al estudiante en el diseño de soluciones que no son lineales, sino gobernadas por decisiones y excepciones~\cite{Kendall2014Systems,Tegarden2025Systems,Wirth1976Algorithms}.
						
						Finalmente, la formalización mediante programación aporta un lenguaje común entre lo organizacional y lo técnico. Modelos de análisis y diseño (por ejemplo, orientados a objetos o basados en UML) describen estructuras y comportamientos; la programación convierte dichas descripciones en componentes ejecutables en los que cada operación implementada representa una regla o decisión del proceso. La trazabilidad conceptual entre modelo e implementación se vuelve, así, una disciplina temprana que el estudiante debe aprender a cultivar desde ejercicios básicos~\cite{Booch2007Object,Ghezzi2003Fundamentals,Tegarden2025Systems}.
						
					\subsubsection{Programación como instrumento de automatización operativa}
						\noindent
						La automatización operativa delega en procedimientos computacionales aquellas actividades repetitivas, intensivas en registro o propensas a error humano, con el fin de lograr ejecución uniforme y medible. En IS, esta automatización se expresa mediante programas que capturan datos, validan transacciones, aplican reglas y producen salidas operativas (cálculos, estados, comprobaciones, reportes), integrándose con los sistemas de información que sostienen la operación organizacional~\cite{Laudon2020Management,Kendall2014Systems,Gonzalez-Longatt2007Introduccion}.
						
						Desde el aprendizaje de programación, automatizar no equivale a “mecanizar” un procedimiento sin comprenderlo. Automatizar exige identificar entradas, decidir el orden de los pasos, definir condiciones de aceptación y establecer salidas verificables. En términos de construcción algorítmica, ello se traduce en seleccionar estructuras de control adecuadas (secuencia, selección, iteración), diseñar funciones para dividir responsabilidades y aplicar pruebas simples para confirmar que el programa reproduce el procedimiento esperado~\cite{Hanly2015Problem,Gaddis2022Starting,Wirth1976Algorithms}.
						
						La automatización también introduce un criterio didáctico esencial: la corrección debe sostenerse en la diversidad de casos, no solo en el “caso típico”. Por ello, el estudiante debe aprender a anticipar excepciones (datos incompletos, formatos inválidos, valores fuera de rango) y a diseñar validaciones y mensajes de error que hagan explícito el contrato del programa. Estos aspectos se relacionan con prácticas de programación responsable y con lineamientos que buscan reducir fallas recurrentes asociadas a suposiciones inseguras o entradas no controladas~\cite{ISO247722024Programming,Gaddis2022Starting,Ghezzi2003Fundamentals}.
						
						Finalmente, automatizar con impacto organizacional requiere considerar calidad y mantenibilidad. La ingeniería de software destaca propiedades como corrección, claridad, modularidad y adecuación al propósito, que se vuelven críticas cuando un proceso depende del software para operar. En consecuencia, aprender a programar debe incluir hábitos tempranos de estructura y legibilidad (nombres, modularización, comentarios mínimos justificados), ya que estos hábitos condicionan la sostenibilidad del sistema más allá del primer funcionamiento~\cite{Ghezzi2003Fundamentals,Fitzpatrick2004Software,Kendall2014Systems}.
						
					\subsubsection{Programación como soporte informacional para la toma de decisiones}
						\noindent
						La toma de decisiones organizacionales depende de transformar datos en información contextualizada y, posteriormente, en conocimiento accionable. Los sistemas de información sostienen esa transformación mediante mecanismos de captura, almacenamiento, procesamiento y presentación, donde los programas implementan operaciones que filtran, validan, agregan y derivan resultados que funcionan como evidencia para decidir~\cite{Laudon2020Management,Bernstein2009Data,Calzati2025Ecosystemic}.
						
						En términos formativos, este rol informacional permite introducir al estudiante en tareas de programación con sentido: calcular totales, promedios, frecuencias, máximos y mínimos; clasificar registros; detectar inconsistencias; o generar resúmenes que hagan visible el estado de una operación. Estas tareas, aunque básicas, enseñan a pensar en términos de datos, reglas y resultados verificables, y facilitan comprender por qué la precisión en tipos, operaciones y validaciones afecta directamente la confiabilidad de la información producida~\cite{Gaddis2022Starting,Bernstein2009Data,Hanly2015Problem}.
						
						El soporte informacional exige consistencia: decisiones distintas no deben originarse en cálculos inconsistentes o reglas implícitas. Por ello, la programación debe explicitar supuestos (por ejemplo, unidades, rangos, criterios de inclusión), y establecer controles que permitan reproducibilidad del procesamiento. Esta exigencia se conecta con la disciplina algorítmica (precisión y finitud) y con criterios de calidad del software (comportamiento estable y verificable), aspectos que deben introducirse desde el nivel básico para evitar que el estudiante normalice resultados “aproximados” sin justificación~\cite{Wirth1976Algorithms,Ghezzi2003Fundamentals,Fitzpatrick2004Software}.
						
						Además, la confiabilidad informacional se asocia a la correcta representación de valores numéricos, especialmente cuando se realizan cálculos acumulativos o comparaciones. En programación, comprender límites de representación y el manejo apropiado de tipos numéricos fortalece la integridad de los resultados y reduce errores sutiles que afectan reportes e indicadores. Aunque los detalles de representación digital se abordarán posteriormente, aquí se subraya su impacto directo en la calidad del soporte informacional~\cite{IEEE2019Standard754,Goldberg1991What,Gaddis2022Starting}.
					
				\subsection{Relación entre procesos organizacionales y software}
					\noindent
					Un sistema de información puede entenderse como la materialización computacional de un conjunto de procesos organizacionales que gestionan recursos, eventos, registros y comunicaciones. En consecuencia, la calidad del software depende del entendimiento del proceso que modela y de la coherencia entre el procedimiento operativo y la lógica implementada, ya que el programa se convierte en un “ejecutor” de reglas organizacionales en escenarios reales~\cite{Kendall2014Systems,Laudon2020Management,Tegarden2025Systems}.
					
					Esta relación es bidireccional. Por un lado, los procesos condicionan requisitos y reglas del software; por otro, el software introduce capacidades de trazabilidad, validación sistemática y generación de evidencia que reconfiguran la forma en que el proceso se ejecuta y se controla. Para quien aprende a programar, esta bidireccionalidad se traduce en comprender que cada decisión de diseño (estructuras de datos, validaciones, orden de pasos) produce consecuencias operativas: habilita o restringe acciones, reduce o incrementa errores, y determina la calidad de la información disponible~\cite{Laudon2020Management,Ghezzi2003Fundamentals,Gonzalez-Longatt2007Introduccion}.
					
					En el plano pedagógico, esta subsección cumple un propósito específico: ayudar a que el estudiante no programe “en el vacío”. Incluso en ejercicios introductorios, se busca que identifique qué parte del proceso representa el programa (qué se recibe, qué se decide, qué se produce) y que evalúe la solución por criterios de corrección y claridad, no solo por ejecución. Con ello, la programación se integra como una práctica de análisis aplicado, coherente con marcos de análisis y diseño de sistemas~\cite{Kendall2014Systems,Tegarden2025Systems,Hanly2015Problem}.
					
					\subsubsection{Proceso, procedimiento y sistema en entornos organizacionales}
						\noindent
						En IS resulta útil distinguir: (i) \emph{proceso} como conjunto de actividades coordinadas orientadas a un resultado organizacional; (ii) \emph{procedimiento} como la forma prescrita o normativa de ejecutar parte del proceso; y (iii) \emph{sistema} como el conjunto socio-técnico que integra personas, reglas y tecnología para ejecutar y controlar dichos procesos. Estas distinciones son relevantes porque el software no implementa “la organización” en abstracto, sino comportamientos concretos asociados a procedimientos y reglas dentro de un proceso delimitado~\cite{Laudon2020Management,Kendall2014Systems,Gonzalez-Longatt2007Introduccion}.
						
						Para aprender a programar, estas distinciones ofrecen una guía práctica: un programa suele representar un procedimiento (una forma específica de hacer) dentro de un proceso mayor. Por ello, antes de escribir código, el estudiante debe aprender a identificar el alcance: qué parte del proceso será automatizada, qué decisiones quedan dentro del programa y cuáles permanecen bajo control humano. Esta delimitación reduce errores de diseño típicos en principiantes, como querer resolver “todo el proceso” con una sola rutina o ignorar casos excepcionales relevantes~\cite{Hanly2015Problem,Gaddis2022Starting,Kendall2014Systems}.
						
						La precisión conceptual evita errores de alcance en proyectos de software. Cuando no se distingue proceso de procedimiento, se tiende a sobredimensionar funciones del sistema o a automatizar actividades que requieren juicio humano o validación externa. Por ello, marcos de análisis y diseño recomiendan delimitar responsabilidades, entradas y salidas por función, y especificar la interacción de usuarios y componentes con el proceso organizacional~\cite{Tegarden2025Systems,Kendall2014Systems,Booch2007Object}.
						
						En consecuencia, una práctica formativa adecuada consiste en traducir un procedimiento a una especificación mínima: entradas, reglas y salidas. Esta especificación se convierte en una estructura de programa con control de flujo explícito y validaciones claras, lo que refuerza la disciplina algorítmica y disminuye suposiciones implícitas sobre la dinámica organizacional~\cite{Wirth1976Algorithms,Ghezzi2003Fundamentals,ISO247722024Programming}.
						
					\subsubsection{Modelamiento de procesos y necesidades informacionales}
						\noindent
						El modelamiento constituye el puente entre la descripción de un proceso y su instrumentación computacional. En IS, modelar significa representar actividades, decisiones, actores, datos y reglas, con el fin de identificar qué información debe capturarse, en qué momento, bajo qué validaciones y con qué propósito operativo o gerencial. Esta representación no es un formalismo ornamental: orienta el diseño del programa, reduce ambigüedades y establece criterios para evaluar la solución~\cite{Kendall2014Systems,Tegarden2025Systems,Laudon2020Management}.
						
						En este sentido, la necesidad informacional no se reduce a “guardar datos”, sino a definir semántica y utilidad: qué atributos representan un evento, qué consistencia deben mantener, y cómo habilitan operaciones de control o seguimiento. Para el aprendizaje de programación, ello implica entrenar al estudiante en la elección de estructuras de datos coherentes con el significado de la información y en la implementación de validaciones que preserven la integridad del registro~\cite{Laudon2020Management,Bernstein2009Data,Calzati2025Ecosystemic}.
						
						El modelamiento también orienta decisiones de diseño: modularidad, responsabilidades y operaciones. En enfoques orientados a objetos, por ejemplo, el modelo facilita la identificación de entidades, relaciones y comportamientos que luego se traducen a clases y métodos; incluso cuando se programa de manera introductoria, esta perspectiva ayuda a organizar el código en partes comprensibles y reutilizables, evitando soluciones monolíticas difíciles de mantener~\cite{Booch2007Object,Tegarden2025Systems,Ghezzi2003Fundamentals}.
						
						Como consecuencia, el estudiante aprende que “programar” incluye un trabajo previo de clarificación: construir una representación mínima del proceso y de sus datos, a partir de la cual se derivan reglas y casos de prueba elementales. Esta práctica refuerza el vínculo entre lo que el proceso requiere y lo que el programa ejecuta, con criterios verificables de corrección~\cite{Hanly2015Problem,Gaddis2022Starting,Kendall2014Systems}.
						
					\subsubsection{De la necesidad organizacional a la solución computacional}
						\noindent
						La transición desde una necesidad organizacional hacia una solución computacional exige transformar objetivos (reducir errores, mejorar control, acelerar registro, producir reportes) en especificaciones operables: funciones, reglas y restricciones que puedan implementarse y verificarse. En análisis y diseño de sistemas, esta transición se estructura mediante identificación de requerimientos, definición de alcance y elaboración de modelos que conectan actores, procesos y datos con funcionalidades del software~\cite{Kendall2014Systems,Tegarden2025Systems,Laudon2020Management}.
						
						Desde la perspectiva del aprendizaje, esta transición se traduce en una secuencia disciplinada: (i) comprender el enunciado y sus restricciones; (ii) definir entradas y salidas con precisión; (iii) descomponer en subproblemas; (iv) diseñar un algoritmo; y (v) implementar de forma incremental con verificación continua. Este enfoque evita que el estudiante confunda la escritura de código con la solución del problema, y promueve que la implementación sea una consecuencia de un diseño algorítmico explícito~\cite{Hanly2015Problem,Wirth1976Algorithms,Gaddis2022Starting}.
						
						La programación cierra el ciclo al convertir dichas especificaciones en algoritmos y estructuras de datos ejecutables, asegurando que el comportamiento real del sistema corresponda al comportamiento requerido. En términos formativos, esto implica habituarse a la verificación: comprobar resultados, probar escenarios alternativos y revisar supuestos. De este modo, el estudiante desarrolla un criterio profesional temprano: el programa es correcto cuando satisface el problema bajo condiciones relevantes, no cuando solo produce una salida “razonable”~\cite{Ghezzi2003Fundamentals,Fitzpatrick2004Software,Wirth1976Algorithms}.
						
						Conviene enfatizar que, en esta sección, la relación se plantea a nivel conceptual y de trazabilidad: necesidad $\rightarrow$ modelo $\rightarrow$ implementación. Los métodos detallados para formular entradas, salidas, restricciones y criterios de aceptación, así como su articulación con otras dimensiones organizacionales, se desarrollan en secciones posteriores del capítulo. Esta decisión editorial evita redundancias y sostiene una progresión pedagógica que acompaña el aprendizaje de programación desde fundamentos hacia aplicaciones más integrales~\cite{Kendall2014Systems,Tegarden2025Systems,Leidig2021Competency}.
				
			\section{Rol profesional del desarrollador en Sistemas de Información}
				\noindent
				El rol profesional del desarrollador en Sistemas de Información (IS) se define por la capacidad de traducir necesidades organizacionales en soluciones de software que operan bajo restricciones reales: tiempo, presupuesto, normativas, interacción humana y evolución de procesos. Esta labor exige convertir descripciones funcionales en comportamientos ejecutables, con reglas explícitas, datos bien definidos y resultados verificables, de modo que el sistema sostenga operaciones y decisiones sin degradar la coherencia del proceso organizacional~\cite{Kendall2014Systems,Laudon2020Management,Tegarden2025Systems}.
				
				Dentro de este panorama, aprender a programar constituye una decisión formativa orientada a la empleabilidad y al desempeño profesional. La programación habilita al estudiante a pasar de la intención a la implementación: formular un algoritmo, elegir estructuras de datos, controlar la ejecución y validar resultados mediante pruebas. Esta progresión convierte el aprendizaje en una práctica acumulativa, donde cada concepto (secuencia, selección, iteración, modularidad) aporta un recurso concreto para construir soluciones aplicables en distintos contextos organizacionales~\cite{Hanly2015Problem,Gaddis2022Starting,Wirth1976Algorithms}.
				
				La práctica profesional no se limita a producir código funcional; incluye asegurar calidad, mantenibilidad y seguridad desde etapas tempranas. Por esa razón, el desarrollo de competencias técnicas incorpora hábitos de diseño, lectura de requisitos, documentación mínima útil y revisión sistemática de defectos frecuentes. Este marco garantista se vincula con la ingeniería de software, donde la corrección técnica se evalúa junto con claridad, evolución y adecuación al propósito~\cite{Ghezzi2003Fundamentals,Pressman2019Software,Sommerville2015Software}.
				
				\subsection{Automatización, digitalización y transformación organizacional}
					\noindent
					La automatización y la digitalización representan dos líneas de intervención que suelen confluir en iniciativas de transformación digital. En IS, el desarrollador participa en estas iniciativas implementando mecanismos que capturan información, normalizan registros, ejecutan reglas y coordinan actividades, buscando que el sistema reduzca fricción operativa y produzca evidencia útil para control y mejora~\cite{Laudon2020Management,Tegarden2025Systems,Cato2020Transforming}.
					
					El aprendizaje de programación contribuye directamente a este tipo de intervención. Un estudiante que domina estructuras de control y modelado básico de datos puede implementar validaciones, automatizar cálculos, generar reportes y construir prototipos que hagan visibles fallas del proceso o inconsistencias del registro. Esa experiencia temprana favorece un enfoque riguroso: cada decisión de diseño se expresa como una regla ejecutable y cada regla se verifica con casos de prueba y entradas variadas~\cite{Hanly2015Problem,Gaddis2022Starting,ISO247722024Programming}.
					
					Paralelamente, la transformación organizacional demanda sensibilidad socio-técnica. El software modifica rutinas, tiempos y responsabilidades; por ello, el desarrollador debe anticipar efectos sobre usuarios y sobre la interacción con el sistema. Aun en programación básica, resulta pertinente introducir ejercicios que consideren uso real: mensajes de error informativos, flujos de entrada consistentes y salidas interpretables por usuarios no técnicos~\cite{Dix2004HCI,Kendall2014Systems,Laudon2020Management}.
					
					\subsubsection{Digitalización de información y procesos}
						\noindent
						La digitalización consiste en representar información y actividades de manera que puedan almacenarse, consultarse y procesarse mediante sistemas computacionales. En organizaciones, este paso implica identificar qué datos describen un evento, qué atributos garantizan trazabilidad y qué reglas preservan integridad, evitando registros incompletos o ambiguos que comprometan la operación~\cite{Laudon2020Management,Bernstein2009Data,Date2019Database}.
						
						Para quien aprende a programar, la digitalización se materializa en decisiones concretas: definir tipos de datos, estructurar registros, validar entradas y diseñar formatos de salida. Un formulario, un archivo de datos o una estructura en memoria no son detalles secundarios; constituyen la base del comportamiento posterior del sistema. Por ello, el entrenamiento debe incluir prácticas de validación (rangos, formatos, obligatoriedad) y de coherencia semántica (nombres consistentes, unidades, estados), destacando que una buena representación reduce errores aguas abajo~\cite{Gaddis2022Starting,Hanly2015Problem,ISO247722024Programming}.
						
						De manera complementaria, la digitalización se conecta con principios de gestión de datos en sistemas de información. Modelos de datos y conceptos de bases de datos ayudan a evitar duplicidad, inconsistencias y pérdidas de significado al pasar de registros aislados a estructuras persistentes. Sin profundizar en administración de bases (tema desarrollado en otras unidades), conviene que el estudiante perciba la relación entre “cómo se programa” y “qué calidad tienen los datos”~\cite{Elmasri2016Database,Silberschatz2020Database,Date2019Database}.
						
					\subsubsection{Automatización de operaciones y flujos de trabajo}
						\noindent
						La automatización se orienta a ejecutar tareas repetitivas con uniformidad, control y medición, integrando reglas operativas en procedimientos computacionales. En IS, esta automatización se implementa mediante programas que registran transacciones, calculan resultados, aplican restricciones y coordinan secuencias de trabajo. En organizaciones con alta carga operativa, pequeños incrementos de consistencia y velocidad producen mejoras acumulativas en calidad del servicio y trazabilidad~\cite{Laudon2020Management,Kendall2014Systems,Gonzalez-Longatt2007Introduccion}.
						
						El aprendizaje de programación ofrece un camino pedagógico natural para esta automatización. Primero se ejercita la especificación de pasos; luego se introduce la selección condicional para manejar decisiones; posteriormente se incorporan bucles para procesar conjuntos de registros; después se emplea modularidad para separar responsabilidades y facilitar pruebas. Esta ruta promueve un estilo de pensamiento donde el estudiante aprende a transformar un procedimiento narrado en un algoritmo que el computador ejecuta sin interpretaciones implícitas~\cite{Wirth1976Algorithms,Hanly2015Problem,Gaddis2022Starting}.
						
						No obstante, la automatización requiere atención a fallos frecuentes: entradas inválidas, supuestos no verificados y manejo insuficiente de excepciones. La calidad operativa depende de validar datos, registrar errores de forma útil y conservar invariantes del proceso. Catálogos y lineamientos de codificación ayudan a identificar riesgos habituales y favorecen prácticas tempranas de programación responsable, incluso en ejercicios introductorios~\cite{ISO247722024Programming,Ghezzi2003Fundamentals,Sommerville2015Software}.
						
						En distintos contextos organizacionales, la automatización también se implementa como orquestación de tareas y flujos. Sistemas de gestión de procesos (BPMS) y enfoques afines muestran que las reglas de negocio y los pasos de un flujo pueden representarse, monitorearse y refinarse. Para el estudiante, estas ideas se traducen en diseñar programas que hagan explícitas transiciones, estados y condiciones, preparando el terreno para trabajos más avanzados sin anticipar contenidos de unidades posteriores~\cite{MartinNavarro2023BPMS,Kendall2014Systems,Tegarden2025Systems}.
						
					\subsubsection{Transformación digital orientada al valor organizacional}
						\noindent
						La transformación digital orientada al valor se vincula con cambios en la forma de operar y decidir, apoyados por software, datos y rediseño de procesos. Su propósito no se reduce a informatizar tareas existentes; introduce nuevas capacidades de coordinación, medición y mejora continua, alineadas con objetivos de desempeño, servicio y sostenibilidad organizacional~\cite{Cato2020Transforming,Jeanneret2024Digital,Varzaru2024Digital}.
						
						Desde la formación en programación, la conexión con el valor se enseña mediante problemas bien planteados: definir qué variable representa un indicador, qué regla determina una condición de alerta, qué estructura permite consolidar registros, y cómo se verifica que el resultado refleje la intención del proceso. La finalidad de ilustrar esta relación consiste en que el lector perciba que cada estructura de control y cada diseño de datos tienen impacto directo sobre la utilidad del sistema~\cite{Laudon2020Management,Hanly2015Problem,Gaddis2022Starting}.
						
						En contraste con una visión centrada en herramientas, el aprendizaje orientado al valor prioriza principios: consistencia, verificabilidad, trazabilidad y mantenibilidad. Un programa con resultados correctos pero difícil de leer o modificar impone costos de cambio; un programa legible y modular facilita adaptación ante cambios de política o de proceso. Esta relación entre diseño y evolución se encuentra documentada en fundamentos de ingeniería de software, con énfasis en calidad y ciclo de vida~\cite{Pressman2019Software,Sommerville2015Software,Ghezzi2003Fundamentals}.
						
				\subsection{Responsabilidades y competencias técnicas en IS}
					\noindent
					El desarrollador en IS asume responsabilidades técnicas que exceden la escritura de código: interpretar requisitos, estructurar soluciones, verificar corrección y comunicar decisiones de diseño. Estas responsabilidades se ejercen con mayor solidez cuando el aprendizaje de programación se acompaña de hábitos de razonamiento: formular supuestos, delimitar alcance, definir contratos de entrada/salida y construir pruebas que respalden el resultado~\cite{Kendall2014Systems,Tegarden2025Systems,Ghezzi2003Fundamentals}.
						
					El modelo de competencias IS2020 destaca la integración entre capacidades técnicas, pensamiento analítico y comunicación profesional. Por ello, el aprendizaje de programación debe presentarse como una competencia de articulación: convierte una necesidad en un algoritmo, un algoritmo en una implementación, y una implementación en un componente operable dentro de un sistema socio-técnico~\cite{Leidig2021Competency,Leidig2020Updating,Laudon2020Management}.
					
					Asimismo, la responsabilidad profesional incorpora prácticas de calidad que deben iniciarse desde programación básica. La estructura del código, la claridad de nombres, el uso de funciones y la revisión de errores comunes son prácticas que evitan deuda técnica temprana y preparan al estudiante para proyectos colaborativos. La ingeniería de software provee criterios y técnicas para sostener estas prácticas en el tiempo~\cite{Sommerville2015Software,Pressman2019Software,Martin2008Clean}.
					
					\subsubsection{Pensamiento lógico y abstracción aplicada}
						\noindent
						El pensamiento lógico aplicado se expresa en la habilidad de construir una solución paso a paso y justificar cada transición del algoritmo. En programación básica, esta habilidad se cultiva al formular procedimientos precisos, identificar condiciones y diseñar estructuras de control que representen decisiones del problema. La disciplina algorítmica proporciona un marco para evaluar si un procedimiento es correcto, finito y ejecutable~\cite{Wirth1976Algorithms,Hanly2015Problem,Gaddis2022Starting}.
						
						La abstracción aplicada consiste en seleccionar lo relevante del problema y representarlo con estructuras mínimas: variables, colecciones, funciones y tipos. En IS, esta selección tiene una dimensión pragmática: se abstrae con el objetivo de operar sobre datos y reglas organizacionales sin perder significado. La formación debe favorecer ejercicios que obliguen a decidir qué información se guarda, qué se calcula, qué se valida y qué se omite por carecer de utilidad operacional~\cite{Laudon2020Management,Bernstein2009Data,Perkovic2010Framework}.
						
						El aprendizaje mejora cuando se incorpora una práctica incremental: comenzar con una versión simple que funcione, ampliar para cubrir casos adicionales y refactorizar para conservar claridad. Este patrón enseña al lector a programar con control del crecimiento del código, evitando soluciones extensas y frágiles. En ingeniería de software, esta idea se relaciona con modularidad y evolución de sistemas, aportando criterios para decidir cuándo dividir, renombrar o reorganizar~\cite{Martin2008Clean,Ghezzi2003Fundamentals,Sommerville2015Software}.
						
					\subsubsection{Calidad, mantenibilidad y responsabilidad profesional}
						\noindent
						La calidad del software se manifiesta en corrección, legibilidad, seguridad y adaptabilidad. En IS, estas propiedades impactan operaciones y decisiones, ya que el sistema ejecuta reglas de negocio, valida transacciones y produce información para seguimiento. La responsabilidad profesional del desarrollador incluye prevenir defectos previsibles, documentar supuestos y asegurar que el sistema responda de manera consistente ante entradas diversas~\cite{Ghezzi2003Fundamentals,Pressman2019Software,ISO247722024Programming}.
						
						La mantenibilidad depende de estructuras comprensibles por terceros y por el propio autor en el tiempo. Para el lector que aprende a programar, esta idea se traduce en hábitos observables: nombres informativos, funciones con una responsabilidad definida, manejo explícito de errores y reducción de duplicación. Buenas prácticas de diseño y limpieza de código favorecen el aprendizaje porque convierten el programa en un objeto legible que puede discutirse, corregirse y mejorar con criterios explícitos~\cite{Martin2008Clean,Sommerville2015Software,Gaddis2022Starting}.
						
						La responsabilidad también incluye atención a fallas vinculadas a seguridad y robustez, incluso en programas pequeños. Validar entradas, controlar rangos y manejar condiciones inesperadas previene comportamientos indeseados y errores silenciosos que contaminan datos o producen resultados equivocados. Lineamientos de codificación y estándares de ingeniería proporcionan referencias para evitar patrones inseguros y para estructurar verificaciones de forma sistemática~\cite{ISO247722024Programming,Ghezzi2003Fundamentals,Pressman2019Software}.
						
						En síntesis, aprender a programar con orientación a IS implica adoptar una ética técnica: producir código que funcione, que pueda evolucionar y que proteja el significado de los datos y reglas que implementa. Esta ética se consolida cuando el estudiante aprende a justificar decisiones de diseño y a evaluar consecuencias, articulando práctica algorítmica con calidad de ingeniería~\cite{Sommerville2015Software,Ghezzi2003Fundamentals,Wirth1976Algorithms}.
						
					\subsubsection{Colaboración interdisciplinaria y documentación técnica}
						\noindent
						Los proyectos de IS requieren colaboración con actores de negocio, usuarios finales, analistas, administradores de datos y responsables de infraestructura. El desarrollador debe comunicar decisiones, restricciones y supuestos en un lenguaje accesible para perfiles no técnicos, manteniendo precisión suficiente para evitar interpretaciones erróneas. Por ello, la documentación técnica se consolida como un componente profesional del desarrollo, asociado a trazabilidad y a coordinación del trabajo~\cite{Kendall2014Systems,Tegarden2025Systems,Laudon2020Management}.
						
						Para quien aprende a programar, la colaboración se entrena mediante prácticas concretas: describir el algoritmo antes del código, comentar decisiones no obvias, registrar precondiciones y postcondiciones de funciones, y producir ejemplos de entrada/salida que sirvan como contrato. Estas prácticas fortalecen la capacidad de revisión y facilitan que otras personas validen el programa, reproduzcan resultados y detecten defectos de forma temprana~\cite{Hanly2015Problem,Gaddis2022Starting,Pressman2019Software}.
						
						Destacando la dimensión socio-técnica, la interacción con usuarios exige considerar usabilidad básica: mensajes, consistencia de opciones, prevención de errores y retroalimentación en tiempo de ejecución. En ejercicios introductorios, esta orientación puede incorporarse mediante requisitos simples de interacción y validación, promoviendo que el estudiante produzca programas que apoyen al usuario y reduzcan fricción operativa~\cite{Dix2004HCI,Laudon2020Management,Kendall2014Systems}.
						
						De manera complementaria, la documentación se apoya en representaciones estructuradas que conectan análisis y construcción. Modelos orientados a objetos y notaciones de diseño ofrecen un vocabulario compartido para describir entidades, responsabilidades y relaciones, ayudando a que el código conserve coherencia con el diseño. Esta práctica prepara al estudiante para proyectos de mayor envergadura, donde la coordinación depende de artefactos que complementan el código~\cite{Booch2007Object,Tegarden2025Systems,Ghezzi2003Fundamentals}.
						
			\section{Datos, información y conocimiento en Sistemas de Información}
				\noindent
				En Sistemas de Información (IS), la distinción entre datos, información y conocimiento estructura la forma en que las organizaciones operan, controlan procesos y orientan decisiones. Los sistemas computacionales gestionan registros, ejecutan transformaciones y producen resultados interpretables; sin embargo, esta secuencia solo adquiere sentido cuando el desarrollador comprende qué representa cada nivel y cómo se articulan entre sí~\cite{Laudon2020Management,Bernstein2009Data,Tegarden2025Systems}. Para quien aprende a programar, esta tríada constituye una guía conceptual que conecta estructuras de datos, algoritmos y salidas con impactos organizacionales concretos.
				
				Dentro de este panorama, programar implica asumir responsabilidad sobre la calidad de los datos que ingresan, la coherencia de los procesos que los transforman y la utilidad de los resultados que se generan. Cada variable declarada, cada validación implementada y cada cálculo realizado influyen en la transición de dato a información y de información a conocimiento operativo. Esta relación se ha consolidado como fundamento en IS, donde la arquitectura de sistemas y el modelado de procesos se articulan con gestión de datos y análisis organizacional~\cite{Kendall2014Systems,Laudon2020Management,Date2019Database}.
				
				Aprender programación desde esta perspectiva transforma ejercicios técnicos en prácticas con sentido. El estudiante deja de manipular números o cadenas aisladas y comienza a interpretar registros, estados y eventos que describen actividades organizacionales. Esta orientación promueve un enfoque riguroso: cada decisión de diseño debe justificarse por su aporte a la coherencia informacional y a la trazabilidad del proceso~\cite{Hanly2015Problem,Gaddis2022Starting,Wirth1976Algorithms}.
				
				\subsection{Fundamentos conceptuales}
					\noindent
					La diferenciación conceptual entre dato, información y conocimiento organiza la reflexión sobre cómo operan los sistemas de información en distintos contextos organizacionales. Un sistema no agrega valor por almacenar registros de manera masiva; lo hace cuando transforma registros en resultados utilizables y alineados con decisiones y acciones. Esta transición ha sido abordada por la literatura de IS y de gestión de datos como una secuencia que exige precisión técnica y claridad semántica~\cite{Laudon2020Management,Bernstein2009Data,Calzati2025Ecosystemic}.
					
					Para entender esta secuencia en clave formativa, el estudiante debe identificar qué representa cada nivel en términos programáticos. El dato se vincula con estructuras elementales; la información surge del procesamiento controlado; el conocimiento emerge cuando los resultados se interpretan bajo reglas organizacionales. Programar, por tanto, no consiste en producir salidas arbitrarias, sino en diseñar transformaciones que respeten significado y contexto~\cite{Kendall2014Systems,Date2019Database,Hanly2015Problem}.
					
					Asimismo, estos fundamentos orientan el aprendizaje hacia la precisión. Cuando un algoritmo procesa registros sin validación o sin definición clara de atributos, se degrada la calidad informacional. Este marco garantista exige que el estudiante adopte prácticas de validación y modelado coherentes con principios de ingeniería de software y administración de datos~\cite{Ghezzi2003Fundamentals,Sommerville2015Software,Elmasri2016Database}.
						
					\subsubsection{Dato como registro estructurado}
						\noindent
						El dato puede definirse como un registro estructurado que representa un hecho, evento o atributo dentro de un dominio organizacional. En IS, los datos adquieren significado cuando se asocian a entidades, relaciones y restricciones, lo cual exige definir tipos, formatos y dominios válidos para cada atributo~\cite{Laudon2020Management,Date2019Database,Elmasri2016Database}. Esta caracterización evita ambigüedades y facilita que el sistema procese registros de forma consistente.
						
						Desde la perspectiva del aprendizaje de programación, el dato se materializa en variables, arreglos, registros o clases. Declarar correctamente un tipo, seleccionar una estructura adecuada y validar valores de entrada son decisiones que determinan la integridad del sistema. Por esa razón, los ejercicios iniciales deben insistir en rangos válidos, coherencia de formatos y prevención de valores fuera de dominio~\cite{Gaddis2022Starting,Hanly2015Problem,ISO247722024Programming}.
						
						Paralelamente, la representación estructurada se relaciona con principios de normalización y modelado conceptual. Aunque la teoría detallada de bases de datos se abordará en otras unidades, resulta indispensable introducir la noción de que cada atributo responde a una definición precisa y a restricciones explícitas. Esta práctica favorece una visión holística donde el programador entiende que los datos constituyen la materia prima del sistema~\cite{Elmasri2016Database,Silberschatz2020Database,Date2019Database}.
						
						En síntesis, aprender a programar implica asumir que cada dato posee significado organizacional. No se trata de valores abstractos, sino de representaciones de hechos que deben mantenerse coherentes, completos y verificables a lo largo del ciclo de vida del sistema~\cite{Laudon2020Management,Ghezzi2003Fundamentals,Bernstein2009Data}.
						
					\subsubsection{Información como procesamiento contextualizado}
						\noindent
						La información surge cuando los datos son procesados bajo reglas que incorporan contexto, relaciones y criterios de interpretación. En IS, esta transformación requiere operaciones de cálculo, agregación, filtrado y clasificación que dotan a los registros de significado operativo~\cite{Laudon2020Management,Bernstein2009Data,Calzati2025Ecosystemic}. La diferencia entre un dato aislado y una información útil radica en el marco que orienta su procesamiento.
						
						Para quien aprende a programar, esta transición se traduce en diseñar algoritmos que transformen entradas en resultados verificables. Calcular totales, identificar tendencias simples o validar condiciones son ejemplos de procesamiento contextualizado que enseñan a relacionar datos con reglas explícitas. Esta práctica promueve disciplina algorítmica y precisión en la definición de operaciones~\cite{Wirth1976Algorithms,Hanly2015Problem,Gaddis2022Starting}.
						
						En contraste con el manejo superficial de registros, el procesamiento contextualizado exige que el estudiante justifique cada operación. ¿Por qué se filtra un conjunto? ¿Qué criterio define una categoría? Estas preguntas fortalecen el razonamiento estructurado y conectan programación con análisis organizacional~\cite{Kendall2014Systems,Tegarden2025Systems,Laudon2020Management}.
						
						De manera complementaria, la calidad de la información depende de la correcta implementación de validaciones y de la coherencia en los cálculos. Errores en tipos numéricos o en comparaciones pueden alterar indicadores y decisiones posteriores. Por ello, la enseñanza de programación debe integrar pruebas sistemáticas y revisión de resultados para garantizar consistencia~\cite{IEEE2019Standard754,Goldberg1991What,Ghezzi2003Fundamentals}.
						
						Asimismo, la producción de información útil requiere claridad en la presentación. El formato de salida, la organización de resultados y la legibilidad influyen en la interpretación por parte de usuarios. Introducir estos criterios en ejercicios básicos fomenta sensibilidad hacia el impacto organizacional del código~\cite{Dix2004HCI,Laudon2020Management,Kendall2014Systems}.
						
					\subsubsection{Conocimiento como soporte para decisiones organizacionales}
						\noindent
						El conocimiento organizacional emerge cuando la información se interpreta bajo objetivos estratégicos y reglas de negocio. En IS, los sistemas apoyan esta etapa proporcionando reportes, indicadores y alertas que orientan acciones y ajustes de procesos~\cite{Laudon2020Management,Calzati2025Ecosystemic,Bernstein2009Data}. La generación de conocimiento exige coherencia entre cálculo, contexto y finalidad organizacional.
						
						Desde el aprendizaje de programación, el paso hacia conocimiento se refleja en la capacidad de diseñar funciones que traduzcan información en criterios de decisión. Por ejemplo, un programa puede evaluar umbrales, clasificar estados o sugerir acciones en función de reglas predefinidas. Esta práctica fortalece la habilidad de vincular estructuras lógicas con consecuencias operativas~\cite{Hanly2015Problem,Wirth1976Algorithms,Gaddis2022Starting}.
						
						Destacando la dimensión estratégica, el conocimiento computacional requiere trazabilidad. Cada resultado debe poder vincularse con datos y reglas que lo originaron, evitando decisiones basadas en cálculos opacos. La ingeniería de software respalda esta necesidad mediante principios de diseño claro y documentación coherente~\cite{Ghezzi2003Fundamentals,Sommerville2015Software,Kendall2014Systems}.
						
						Dentro de este panorama, aprender a programar con orientación a IS significa asumir que cada algoritmo puede influir en decisiones organizacionales. Esta responsabilidad impulsa al estudiante a diseñar soluciones robustas, verificables y alineadas con criterios explícitos~\cite{Leidig2021Competency,Leidig2020Updating,Laudon2020Management}.
						
				\subsection{Ciclo de vida del dato en entornos organizacionales}
					\noindent
					El ciclo de vida del dato describe la secuencia de etapas que atraviesa un registro desde su captura hasta su utilización estratégica. En IS, esta secuencia integra procesos técnicos y organizacionales que determinan calidad, accesibilidad y utilidad del dato a lo largo del tiempo~\cite{Laudon2020Management,Elmasri2016Database,Silberschatz2020Database}.
					
					Para el estudiante de programación, visualizar este ciclo permite ubicar su intervención en cada fase. Programar no se limita a procesar información existente; también implica diseñar mecanismos de captura, validación, almacenamiento y presentación coherentes con reglas y objetivos. Esta visión dinámica conecta fundamentos técnicos con impacto organizacional~\cite{Kendall2014Systems,Gaddis2022Starting,Tegarden2025Systems}.
					
					En este marco, adoptar prácticas responsables desde programación básica favorece sistemas más robustos en etapas posteriores. Validar entradas, estructurar datos con claridad y producir salidas interpretables constituyen hábitos que acompañan al desarrollador en proyectos de mayor envergadura~\cite{Ghezzi2003Fundamentals,Sommerville2015Software,ISO247722024Programming}.
					
					\subsubsection{Captura y validación de datos}
						\noindent
						La captura de datos inicia el ciclo informacional. En organizaciones, esta etapa puede involucrar formularios digitales, sensores o registros manuales digitalizados. La calidad del sistema depende de que los datos ingresen con coherencia y consistencia desde el primer momento~\cite{Laudon2020Management,Date2019Database,Elmasri2016Database}.
						
						Para aprender programación, la captura se traduce en leer entradas, verificar formatos y establecer condiciones mínimas de aceptación. Implementar validaciones evita que el sistema procese información defectuosa y enseña disciplina en el diseño de algoritmos~\cite{Gaddis2022Starting,Hanly2015Problem,ISO247722024Programming}.
						
						Paralelamente, la validación debe contemplar rangos, tipos y relaciones entre atributos. Un registro puede ser válido en forma individual, aunque inconsistente respecto a otros valores. Introducir estas verificaciones en ejercicios básicos fortalece el razonamiento lógico y la atención a detalles estructurales~\cite{Wirth1976Algorithms,Ghezzi2003Fundamentals,Sommerville2015Software}.
						
						Asimismo, la captura responsable promueve trazabilidad. Registrar fecha, origen o responsable de un dato facilita auditoría y control posterior, aspectos relevantes en distintos contextos organizacionales~\cite{Laudon2020Management,Kendall2014Systems,Elmasri2016Database}.
						
					\subsubsection{Almacenamiento y procesamiento informacional}
						\noindent
						El almacenamiento organiza datos para su recuperación y análisis posterior. Sistemas de bases de datos proporcionan mecanismos de persistencia, integridad y consulta que permiten mantener coherencia a lo largo del tiempo~\cite{Elmasri2016Database,Silberschatz2020Database,Date2019Database}. La programación interactúa con estas estructuras mediante consultas, inserciones y actualizaciones controladas.
						
						Para el estudiante, esta etapa se vincula con estructuras de datos persistentes y con operaciones que transforman conjuntos de registros. Diseñar algoritmos que recorran colecciones, filtren elementos y produzcan resultados agregados constituye un paso formativo hacia sistemas informacionales más complejos~\cite{Hanly2015Problem,Gaddis2022Starting,Wirth1976Algorithms}.
						
						Destacando la importancia de integridad, el almacenamiento debe preservar restricciones definidas en el modelo conceptual. Claves, relaciones y dominios protegen coherencia del sistema y evitan inconsistencias acumulativas~\cite{Elmasri2016Database,Date2019Database,Ghezzi2003Fundamentals}.
						
						En síntesis, aprender a programar implica reconocer que el procesamiento no ocurre en el vacío: se apoya en estructuras persistentes que deben diseñarse con rigor y mantenerse coherentes a lo largo del ciclo de vida~\cite{Laudon2020Management,Sommerville2015Software,Tegarden2025Systems}.
						
					\subsubsection{Presentación, análisis y uso estratégico}
						\noindent
						La etapa final del ciclo informacional consiste en presentar resultados de forma que apoyen análisis y acción. Reportes, visualizaciones y alertas traducen cálculos en representaciones interpretables por actores organizacionales~\cite{Laudon2020Management,Calzati2025Ecosystemic,Bernstein2009Data}. La forma de presentación influye en la interpretación y en la calidad de decisiones derivadas.
						
						Para quien aprende programación, esta fase introduce diseño de salidas legibles y estructuradas. Organizar información, etiquetar resultados y seleccionar formatos adecuados forman parte del proceso algorítmico. Esta práctica fortalece sensibilidad hacia usuarios y hacia el impacto organizacional del código~\cite{Dix2004HCI,Kendall2014Systems,Gaddis2022Starting}.
						
						Asimismo, el análisis estratégico puede incorporar reglas adicionales que identifiquen patrones o condiciones de alerta. Implementar comparaciones, umbrales y clasificaciones enseña a vincular información con criterios decisionales~\cite{Wirth1976Algorithms,Hanly2015Problem,Laudon2020Management}.
						
						Dentro de este panorama, aprender a programar desde la perspectiva de IS significa participar en todo el ciclo de vida del dato. Cada línea de código contribuye a capturar, transformar y presentar información que orienta acciones organizacionales. Esta visión integradora motiva al lector a desarrollar competencias técnicas con conciencia del impacto y con compromiso hacia la calidad del sistema~\cite{Leidig2021Competency,Leidig2020Updating,Ghezzi2003Fundamentals}.
							
			\section{Tecnología computacional como soporte del Sistema de Información}
				\noindent
				La tecnología computacional constituye el entramado material y lógico que posibilita la operación de un Sistema de Información (SI). En organizaciones contemporáneas, hardware, software y componentes de control interactúan para capturar eventos, ejecutar reglas y producir resultados coherentes con objetivos operativos y estratégicos~\cite{Laudon2020Management,Kendall2014Systems,Tegarden2025Systems}. Desde la perspectiva formativa, este entramado adquiere sentido cuando el estudiante reconoce que cada programa escrito se ejecuta sobre una arquitectura concreta y que sus decisiones de diseño dialogan con restricciones técnicas reales.
				
				Aprender a programar implica asumir que el código no existe en abstracto: se ejecuta en procesadores con capacidades definidas, interactúa con sistemas operativos que gestionan recursos y puede integrarse con dispositivos físicos que generan datos. Esta conciencia tecnológica orienta al lector hacia una práctica responsable, donde el rendimiento, la consistencia y la interacción con el entorno se consideran desde etapas iniciales del aprendizaje~\cite{Silberschatz2018Operating,Gaddis2022Starting,Hanly2015Problem}.
				
				Dentro de este panorama, la comprensión del soporte tecnológico fortalece la calidad del desarrollo. Cuando el estudiante identifica cómo fluyen los datos desde un dispositivo hasta una aplicación y cómo se gestionan memoria y almacenamiento, adquiere una visión holística del sistema. Esta visión favorece decisiones algorítmicas coherentes con la infraestructura y evita supuestos infundados sobre disponibilidad de recursos~\cite{Tanenbaum2021Structured,Laudon2020Management,Ghezzi2003Fundamentals}.
				
				Desde un enfoque riguroso, la tecnología computacional se convierte en aliada del aprendizaje. El conocimiento de sus componentes no persigue erudición técnica aislada; proporciona criterios para diseñar programas robustos, prever limitaciones y articular soluciones alineadas con la realidad organizacional~\cite{Kendall2014Systems,Tegarden2025Systems,Pressman2019Software}.
				
				\subsection{Componentes tecnológicos}
					\noindent
					Los componentes tecnológicos de un SI pueden agruparse en infraestructura de hardware, software de aplicación y sistemas operativos, así como firmware encargado del control directo de dispositivos. Cada componente cumple funciones específicas que, integradas, permiten capturar, procesar y distribuir información de manera coherente~\cite{Laudon2020Management,Tanenbaum2021Structured,Silberschatz2018Operating}.
					
					Para entender la relevancia de estos elementos en el aprendizaje de programación, es preciso reconocer que cada línea de código interactúa con ellos. Un programa gestiona memoria proporcionada por el sistema operativo, utiliza capacidades de procesamiento del hardware y puede depender de controladores que median la comunicación con dispositivos externos. Esta interdependencia sugiere que la formación del desarrollador en IS debe incorporar nociones básicas sobre arquitectura y gestión de recursos~\cite{Gaddis2022Starting,Silberschatz2018Operating,Ghezzi2003Fundamentals}.
					
					Asimismo, la articulación entre componentes tecnológicos respalda la confiabilidad del sistema. Un algoritmo correcto puede degradar su desempeño cuando ignora limitaciones de hardware o comportamientos del sistema operativo. Por ello, la programación con orientación a IS exige considerar latencia, almacenamiento y concurrencia como variables que influyen en la ejecución~\cite{Tanenbaum2021Structured,Sommerville2015Software,Pressman2019Software}.
					
					\subsubsection{Infraestructura de hardware}
						\noindent
						La infraestructura de hardware comprende procesadores, memoria principal, almacenamiento secundario y dispositivos periféricos que permiten entrada y salida de información. Estos elementos determinan capacidad de cómputo, velocidad de respuesta y volumen de datos que el sistema puede manejar~\cite{Tanenbaum2021Structured,Laudon2020Management}. En organizaciones con operaciones intensivas, la selección y configuración del hardware impactan directamente en la eficiencia del SI.
						
						Desde la perspectiva del aprendizaje, comprender nociones básicas de arquitectura favorece decisiones algorítmicas coherentes. La elección de estructuras de datos, el uso de ciclos anidados o la gestión de colecciones influyen en consumo de memoria y tiempo de ejecución. Esta relación introduce al estudiante en el análisis de eficiencia y en la importancia de evaluar costos computacionales~\cite{Wirth1976Algorithms,Hanly2015Problem,Gaddis2022Starting}.
						
						De manera complementaria, el hardware interactúa con dispositivos que generan datos organizacionales: lectores, sensores o terminales de usuario. Programar implica considerar formatos de entrada y latencias asociadas a estos dispositivos, preparando al lector para entornos donde la tecnología trasciende la pantalla y se integra con procesos físicos~\cite{Laudon2020Management,Tanenbaum2021Structured,Kendall2014Systems}.
						
					\subsubsection{Software de aplicación y sistemas operativos}
						\noindent
						El software de aplicación implementa reglas de negocio y funcionalidades específicas del SI, mientras que el sistema operativo administra recursos, procesos y comunicación entre componentes. Esta distinción organiza la arquitectura lógica del entorno donde se ejecuta el código~\cite{Silberschatz2018Operating,Sommerville2015Software,Laudon2020Management}.
						
						Para quien aprende a programar, entender esta separación favorece claridad conceptual. El código desarrollado en un lenguaje de alto nivel depende de servicios del sistema operativo para acceder a archivos, gestionar memoria o interactuar con red. Esta dependencia exige respetar convenciones, manejar excepciones y estructurar programas conforme a estándares del entorno~\cite{Gaddis2022Starting,Hanly2015Problem,Silberschatz2018Operating}.
						
						Paralelamente, el software de aplicación refleja decisiones organizacionales. Cada módulo implementa funciones alineadas con procesos y requisitos definidos. Diseñar programas coherentes con estos requisitos fortalece la competencia del desarrollador y lo prepara para integrar su trabajo en sistemas de mayor envergadura~\cite{Kendall2014Systems,Tegarden2025Systems,Pressman2019Software}.
						
						Asimismo, la interacción entre aplicaciones y sistema operativo introduce al estudiante en conceptos como concurrencia y gestión de recursos compartidos. Aunque su estudio detallado corresponde a etapas posteriores, una noción inicial sobre cómo el entorno gestiona procesos enriquece la práctica de programación básica~\cite{Silberschatz2018Operating,Sommerville2015Software,Tanenbaum2021Structured}.
						
					\subsubsection{Firmware y control de dispositivos}
						\noindent
						El firmware constituye el nivel intermedio entre hardware y software de aplicación. Se trata de programas almacenados en dispositivos que controlan operaciones básicas y permiten comunicación con sistemas superiores~\cite{Tanenbaum2021Structured,Laudon2020Management}. En entornos organizacionales con dispositivos inteligentes, el firmware coordina captura y transmisión de datos hacia aplicaciones centrales.
						
						Aprender programación con conciencia de este nivel amplía la visión del estudiante. La interacción con dispositivos exige considerar protocolos, formatos y validaciones adicionales. Aunque el desarrollo de firmware puede exceder la programación inicial, reconocer su existencia fortalece la comprensión de la cadena completa de procesamiento~\cite{Ghezzi2003Fundamentals,Sommerville2015Software,Tegarden2025Systems}.
						
						En síntesis, el firmware ilustra que la programación no se limita a aplicaciones visibles; integra capas que permiten funcionamiento coordinado del sistema. Esta comprensión prepara al lector para escenarios donde software y hardware interactúan de manera dinámica y organizada~\cite{Laudon2020Management,Tanenbaum2021Structured,Kendall2014Systems}.
						
				\subsection{Modelo funcional de entrada–proceso–salida en SI}
					\noindent
					El modelo funcional de entrada–proceso–salida (E–P–S) describe la estructura básica de operación de un SI. Datos ingresan al sistema, son transformados mediante reglas y algoritmos, y producen resultados destinados a usuarios o a otros sistemas~\cite{Laudon2020Management,Kendall2014Systems}. Este esquema sintetiza la lógica fundamental que el estudiante reproduce en cada ejercicio de programación.
					
					Desde una perspectiva pedagógica, el modelo E–P–S actúa como guía para estructurar programas. Identificar claramente entradas, diseñar procesamiento coherente y definir salidas verificables ordena el razonamiento y facilita pruebas sistemáticas. Esta estructura fomenta disciplina y claridad en el diseño algorítmico~\cite{Hanly2015Problem,Wirth1976Algorithms,Gaddis2022Starting}.
					
					Asimismo, el modelo evidencia que cada componente tecnológico participa en la secuencia. El hardware recibe datos, el software procesa información y los dispositivos presentan resultados. Esta integración subraya la relevancia de comprender cómo interactúan los niveles tecnológicos descritos anteriormente~\cite{Tanenbaum2021Structured,Silberschatz2018Operating,Laudon2020Management}.
					
					\subsubsection{Entrada de datos organizacionales}
						\noindent
						La entrada de datos constituye el punto inicial del modelo E–P–S. Formularios, interfaces digitales y dispositivos de captura registran eventos y atributos relevantes para la operación organizacional~\cite{Laudon2020Management,Kendall2014Systems}. La calidad de esta etapa condiciona el procesamiento posterior.
						
						Para quien aprende a programar, diseñar entradas implica validar tipos, rangos y formatos antes de ejecutar cálculos. Implementar estas verificaciones refuerza disciplina y reduce propagación de errores~\cite{Gaddis2022Starting,Hanly2015Problem,ISO247722024Programming}.
						
						Asimismo, la entrada puede provenir de sistemas externos o de dispositivos automáticos. Integrar estas fuentes exige comprender protocolos básicos y estructuras de datos compatibles~\cite{Silberschatz2018Operating,Tanenbaum2021Structured,Laudon2020Management}.
						
						Destacando la dimensión organizacional, cada dato capturado representa un evento con significado. Reconocer esta conexión motiva al estudiante a programar con responsabilidad y coherencia~\cite{Kendall2014Systems,Ghezzi2003Fundamentals,Leidig2021Competency}.
						
					\subsubsection{Procesamiento de información}
						\noindent
						El procesamiento transforma entradas en resultados mediante algoritmos estructurados. Operaciones aritméticas, comparaciones, iteraciones y funciones constituyen la base de esta transformación~\cite{Wirth1976Algorithms,Hanly2015Problem,Gaddis2022Starting}. En IS, este procesamiento implementa reglas de negocio y políticas operativas.
						
						Aprender a diseñar algoritmos eficientes implica analizar pasos, evaluar complejidad y verificar consistencia de resultados. Esta práctica fortalece pensamiento lógico y prepara al lector para problemas de mayor escala~\cite{Sommerville2015Software,Ghezzi2003Fundamentals,Pressman2019Software}.
						
						De manera complementaria, el procesamiento puede involucrar interacción con almacenamiento persistente o con sistemas externos. Introducir estas consideraciones en ejercicios graduales permite visualizar la amplitud del entorno tecnológico~\cite{Elmasri2016Database,Silberschatz2020Database,Tegarden2025Systems}.
						
					\subsubsection{Salida para usuarios y sistemas}
						\noindent
						La salida representa el resultado visible del modelo E–P–S. Puede consistir en mensajes en pantalla, reportes estructurados o datos transmitidos a otros sistemas~\cite{Laudon2020Management,Kendall2014Systems}. Su claridad y coherencia determinan utilidad organizacional.
						
						Para el estudiante, diseñar salidas legibles y consistentes forma parte integral del algoritmo. Organizar resultados y explicar estados refuerza la conexión entre código y usuario~\cite{Dix2004HCI,Gaddis2022Starting,Hanly2015Problem}.
						
						Asimismo, la salida puede alimentar procesos posteriores. Programar con esta visión holística fomenta responsabilidad técnica y coherencia sistémica~\cite{Tegarden2025Systems,Sommerville2015Software,Ghezzi2003Fundamentals}.
							
			\section{Representación digital de la información}
				\noindent
				La representación digital define la forma en que un Sistema de Información (SI) convierte hechos organizacionales en símbolos manipulables por software. Esta conversión condiciona almacenamiento, transmisión y procesamiento, dado que toda operación computacional se ejecuta sobre codificaciones concretas que deben preservar significado y consistencia~\cite{Laudon2020Management,Kendall2014Systems,Tanenbaum2021Structured}.
				
				Aprender a programar con orientación a IS se fortalece cuando el lector domina las decisiones elementales de representación. Un error de codificación de texto, un desbordamiento en enteros o una interpretación incorrecta de números reales puede degradar reportes, alterar reglas de negocio y producir decisiones apoyadas en resultados inválidos~\cite{Gaddis2022Starting,Goldberg1991What,IEEE2019Standard754}.
				
				Dentro de este panorama, la representación digital aporta un marco formativo que conecta teoría y práctica. Comprender bases numéricas, codificaciones y formatos conduce a programas más robustos, con validaciones mejor justificadas y salidas que preservan semántica organizacional~\cite{Hanly2015Problem,Wirth1976Algorithms,Ghezzi2003Fundamentals}.
				
				Esta sección organiza la representación digital en tres perspectivas complementarias: fundamentos binarios, codificación de tipos de contenido y riesgos habituales de representación. La finalidad de ilustrar esta organización consiste en que el lector encuentre motivos técnicos y profesionales para programar con rigor, desde ejercicios básicos hasta escenarios organizacionales de mayor envergadura~\cite{Tegarden2025Systems,Laudon2020Management,Sommerville2015Software}.
				
				\subsection{Fundamentos de representación binaria}
						
					La representación binaria constituye el lenguaje operativo del hardware. El procesador y la memoria trabajan con estados discretos, y el software se apoya en esos estados para representar números, texto y estructuras de datos que describen eventos organizacionales~\cite{Tanenbaum2021Structured,Silberschatz2018Operating,Laudon2020Management}.
					
					Aprender estos fundamentos permite que la programación deje de ser una actividad “mágica” y se convierta en una práctica justificable. Cuando el lector relaciona variables y estructuras con bytes reales en memoria, adquiere criterio para elegir tipos, anticipar límites y explicar fallas asociadas a rangos y conversiones~\cite{Gaddis2022Starting,Hanly2015Problem,Sebesta2018Concepts}.
					
					La perspectiva binaria también facilita evaluar eficiencia. Representar información con estructuras apropiadas reduce consumo de memoria y costo de procesamiento, lo cual se refleja en tiempos de respuesta y escalabilidad del SI, especialmente cuando se procesan grandes volúmenes de registros~\cite{Wirth1976Algorithms,Sedgewick2011Algorithms,Tanenbaum2021Structured}.
					
					No obstante, la utilidad formativa más directa se manifiesta en la depuración. Reconocer cómo se codifica un dato habilita rastrear errores de interpretación, fallos de lectura/escritura y resultados inesperados en operaciones aritméticas o lógicas, fortaleciendo hábitos de verificación~\cite{Ghezzi2003Fundamentals,Pressman2019Software,Gaddis2022Starting}.
					
					Paralelamente, el manejo de bits introduce destrezas prácticas frecuentes en IS: validación mediante máscaras, compresión simple, control de permisos y codificación de estados. Estas destrezas ofrecen ejercicios motivadores para aprender a programar con problemas cercanos a escenarios reales~\cite{Wirth1976Algorithms,Manzano2017Programacion,Hanly2015Problem}.
					
					\subsubsection{Bits, bytes y almacenamiento}
						\noindent
						Un bit representa la unidad mínima de información en sistemas digitales, y un byte agrupa bits para formar una unidad práctica de almacenamiento. Esta organización responde a cómo hardware y sistema operativo direccionan memoria y gestionan transferencia de datos, lo cual incide en tamaño de variables, estructuras y archivos~\cite{Tanenbaum2021Structured,Silberschatz2018Operating,Laudon2020Management}.
						
						En programación, la noción de byte se conecta con el tipo de dato elegido. Un entero, un carácter o un valor booleano ocupan un número determinado de bytes; esa ocupación define rangos posibles y condiciona operaciones de lectura, escritura y serialización. Esta relación orienta al estudiante a seleccionar tipos con criterio y a justificar la representación en función del dominio organizacional~\cite{Gaddis2022Starting,Hanly2015Problem,Sebesta2018Concepts}.
						
						El almacenamiento también se expresa en estructuras: arreglos, cadenas y registros ocupan memoria de manera distinta. Reconocer esta diferencia favorece decisiones sobre cómo modelar colecciones de datos organizacionales, evitando estructuras infladas o diseños que dificulten procesamiento por recorridos repetidos~\cite{Wirth1976Algorithms,Sedgewick2011Algorithms,Manzano2017Programacion}.
						
						En escenarios de IS, el almacenamiento se extiende a archivos y bases de datos. Aunque el estudio detallado de persistencia se desarrolla en otras unidades, resulta pertinente observar que un archivo codifica bytes y que una mala interpretación de esa codificación produce datos corruptos o inconsistentes~\cite{Date2019Database,Elmasri2016Database,Silberschatz2020Database}.
						
						De manera complementaria, el almacenamiento se relaciona con integridad y seguridad. Tamaños mal controlados, conversiones inseguras o supuestos erróneos sobre longitudes introducen fallas previsibles, por lo que se recomienda entrenar desde temprano validaciones y manejo seguro de entradas~\cite{ISO247722024Programming,Ghezzi2003Fundamentals,Pressman2019Software}.
						
					\subsubsection{Sistemas de numeración}
						\noindent
						Los sistemas de numeración constituyen el fundamento matemático que permite representar cantidades mediante símbolos y reglas formales. En términos generales, un sistema de numeración define un conjunto de dígitos permitidos y un mecanismo para combinar dichos dígitos con el fin de expresar valores. Desde la perspectiva computacional, esta formalización es determinante porque toda información procesada por un Sistema de Información (SI) se expresa finalmente como secuencias numéricas codificadas en binario~\cite{Tanenbaum2021Structured,Manzano2017Programacion,Wirth1976Algorithms}.
						
						Existen sistemas posicionales y no posicionales. En los sistemas no posicionales, el valor de un símbolo no depende de su posición; ejemplos históricos como la numeración romana ilustran esta característica. En contraste, los sistemas posicionales asignan significado a cada posición en función de una potencia de la base. Esta distinción resulta indispensable para quien aprende a programar, ya que los sistemas digitales utilizan exclusivamente esquemas posicionales para almacenar y transformar datos~\cite{Tanenbaum2021Structured,Gaddis2022Starting,Hanly2015Problem}.
						
						En un sistema posicional de base $b$, los dígitos permitidos pertenecen al conjunto $\{0,1,\dots,b-1\}$. El valor mínimo representable con un solo dígito es $0$, y el valor máximo es $b-1$. Cuando se combinan $n$ dígitos, el valor total se obtiene mediante la suma ponderada de cada dígito multiplicado por la potencia correspondiente de la base:
						\[
						N = \sum_{i=0}^{n-1} d_i \cdot b^i,
						\]
						donde $d_i$ representa el dígito en la posición $i$. Esta formulación no constituye un formalismo abstracto; proporciona al estudiante un modelo exacto para diseñar algoritmos de conversión y para justificar resultados obtenidos por el programa~\cite{Wirth1976Algorithms,Hanly2015Problem,Manzano2017Programacion}.
						
						En computación, base 2 se emplea para operación interna, base 16 se utiliza para representación compacta y lectura técnica, y base 10 se mantiene como referencia organizacional para usuarios y reportes~\cite{Tanenbaum2021Structured,Laudon2020Management,Gaddis2022Starting}. Dominar la noción de base permite al lector interpretar resultados de depuración, comprender límites de tipos numéricos y diseñar validaciones coherentes con el dominio del problema.
						
						\paragraph{Representación en base decimal (10).} El sistema decimal utiliza base $10$, con dígitos entre $0$ y $9$. Su valor máximo por posición es $9$, y cada posición representa una potencia de $10$. Por ejemplo:
						\[
						372_{10} = 3\cdot10^2 + 7\cdot10^1 + 2\cdot10^0.
						\]
						En programación, esta representación coincide con la forma habitual en que los usuarios ingresan datos numéricos, lo cual exige validaciones de rango y control de formato~\cite{Gaddis2022Starting,Hanly2015Problem}.
						
						\textbf{Ejercicios propuestos:}
						\begin{enumerate}
							\item Representar el número $5042_{10}$ como suma de potencias de 10.
							\item Determinar el valor máximo representable con tres dígitos decimales.
							\item Codificar en decimal el número ASCII del carácter `A` (65) y verificar su interpretación como carácter.
						\end{enumerate}
						
						\paragraph{Representación en base binaria (2).} La base $2$ emplea dígitos $\{0,1\}$. El valor máximo por posición es $1$. Cada posición representa una potencia de $2$. Por ejemplo:
						\[
						1011_2 = 1\cdot2^3 + 0\cdot2^2 + 1\cdot2^1 + 1\cdot2^0 = 11_{10}.
						\]
						Este sistema se ha consolidado como fundamento del hardware digital~\cite{Tanenbaum2021Structured,Wirth1976Algorithms,Gaddis2022Starting}.
						
						\textbf{Ejercicios propuestos:}
						\begin{enumerate}
							\item Convertir $110101_2$ a decimal.
							\item Determinar el valor máximo representable con 8 bits sin signo.
							\item Representar en binario el código ASCII de la letra `B` (66).
						\end{enumerate}
						
						\paragraph{Representación en base octal (8).} El sistema octal utiliza base $8$, con dígitos entre $0$ y $7$. El valor máximo por posición es $7$. Su uso en informática histórica y en permisos de sistemas operativos lo convierte en un recurso práctico para quien aprende a programar~\cite{Tanenbaum2021Structured,Silberschatz2018Operating,Manzano2017Programacion}. Un número octal como:
						\[
						157_8 = 1\cdot8^2 + 5\cdot8^1 + 7\cdot8^0
						\]
						puede convertirse a decimal mediante el algoritmo posicional descrito anteriormente.
						
						\textbf{Ejercicios propuestos:}
						\begin{enumerate}
							\item Convertir $345_8$ a base decimal.
							\item Determinar el mayor número representable con cuatro dígitos octales.
							\item Representar en octal el código decimal 65 y relacionarlo con su carácter ASCII correspondiente.
						\end{enumerate}
						
						\paragraph{Representación en base hexadecimal (16).} La base $16$ utiliza dígitos $\{0,\dots,9,A,\dots,F\}$, donde $A=10$ hasta $F=15$. El valor máximo por posición es $15$. Esta base facilita lectura compacta de direcciones de memoria y datos binarios~\cite{Tanenbaum2021Structured,Sebesta2018Concepts,Gaddis2022Starting}. Por ejemplo:
						\[
						2F_{16} = 2\cdot16^1 + 15\cdot16^0 = 47_{10}.
						\]
						
						\textbf{Ejercicios propuestos:}
						\begin{enumerate}
							\item Convertir $3A7_{16}$ a decimal.
							\item Determinar el máximo valor representable con dos dígitos hexadecimales.
							\item Representar en hexadecimal el código ASCII de la palabra “SI” (S: 83, I: 73).
						\end{enumerate}
						
						\paragraph{Aplicación formativa.} El estudio de los sistemas de numeración fortalece pensamiento algorítmico, ya que cada conversión puede implementarse mediante procedimientos iterativos y verificables~\cite{Wirth1976Algorithms,Hanly2015Problem,Gaddis2022Starting}. La conexión con datos alfanuméricos se evidencia en la codificación ASCII o Unicode, donde cada carácter se representa como número entero que puede expresarse en distintas bases.
						
						Desde la perspectiva de IS, dominar estas representaciones habilita interpretar identificadores, permisos, códigos de estado y estructuras de almacenamiento. Programar con criterio numérico reduce errores de conversión, facilita depuración y aporta fundamento técnico a decisiones de diseño que impactan directamente en la calidad del Sistema de Información~\cite{Laudon2020Management,Tanenbaum2021Structured,Sommerville2015Software}.
						
					\subsubsection{Conversión de valores enteros entre distintos sistemas de numeración}
						\noindent
						La conversión entre bases se apoya en descomposición posicional. Este procedimiento constituye un ejemplo didáctico de algoritmo finito, con pasos verificables y resultados contrastables, por lo que se ha posicionado como práctica formativa adecuada para principiantes~\cite{Wirth1976Algorithms,Hanly2015Problem,Gaddis2022Starting}.
						
						En programación, implementar conversiones refuerza dominio de divisiones enteras, residuos, recorridos y construcción incremental de resultados. Estos conceptos reaparecen en problemas típicos de IS, tales como generación de códigos, validación de identificadores y tratamiento de formatos de entrada variados~\cite{Manzano2017Programacion,Gaddis2022Starting,Hanly2015Problem}.
						
						Las conversiones entre bases se organizan en familias de procedimientos según su lógica de cálculo. En términos formativos, esta agrupación ayuda a programar las transformaciones con algoritmos simples, verificables y reutilizables, evitando memorizar reglas aisladas \cite{Wirth1976Algorithms,Hanly2015Problem,Gaddis2022Starting}.
						
						\paragraph{Familia A: conversión \emph{desde decimal} mediante divisiones sucesivas}
						Este procedimiento se aplica cuando el número de entrada está en base $10$ y se desea expresarlo en base $b$ (por ejemplo, decimal$\rightarrow$binario, decimal$\rightarrow$octal, decimal$\rightarrow$hexadecimal). Su lógica se apoya en cocientes y residuos, lo cual facilita una implementación directa con bucles \cite{Hanly2015Problem,Gaddis2022Starting,Wirth1976Algorithms}.
						
						\begin{enumerate}
							\item Tomar el número decimal $N$ como valor inicial.
							\item Dividir $N$ entre la base destino $b$.
							\item Registrar el residuo $r = N \bmod b$ como dígito siguiente.
							\item Actualizar $N \leftarrow \lfloor N/b \rfloor$.
							\item Repetir pasos 2--4 hasta que $N=0$.
							\item Leer los residuos en orden inverso (del último al primero) para obtener el número en base $b$.
							\item En base 16, reemplazar residuos 10--15 por $A$--$F$.
						\end{enumerate}
						
						\noindent
						\textbf{Casos cubiertos por esta familia:}
						\begin{itemize}
							\item \textbf{Decimal $\rightarrow$ Binario} (base $b=2$)
							\item \textbf{Decimal $\rightarrow$ Octal} (base $b=8$)
							\item \textbf{Decimal $\rightarrow$ Hexadecimal} (base $b=16$)
						\end{itemize}
						
						\subsubsection*{Ejercicios resueltos: Conversión desde decimal mediante divisiones sucesivas}
						
						\noindent	
						A continuación se presentan dos ejercicios completos para cada caso cubierto por la familia de conversión desde base decimal hacia otra base utilizando divisiones sucesivas. En cada uno se siguen estrictamente los pasos establecidos.
						
						%------------------------------------------------
						\subsubsection*{1. Decimal $\rightarrow$ Binario (base $b=2$)}
						
						\noindent
						\textbf{Ejercicio 1: Convertir $45_{10}$ a binario}
						
						\noindent
						\textbf{Paso 1:} $N = 45$
						
						\begin{center}
							\begin{tabular}{c|c|c}
								$N$ & $N \div 2$ & Residuo \\
								\hline
								45 & 22 & 1 \\
								22 & 11 & 0 \\
								11 & 5  & 1 \\
								5  & 2  & 1 \\
								2  & 1  & 0 \\
								1  & 0  & 1 \\
							\end{tabular}
						\end{center}
						
						\noindent
						\textbf{Paso final:} Leer residuos en orden inverso:
						
						\[
						45_{10} = 101101_2
						\]
						
						\noindent
						\textbf{Ejercicio 2: Convertir $156_{10}$ a binario}
						
						\begin{center}
							\begin{tabular}{c|c|c}
								$N$ & $N \div 2$ & Residuo \\
								\hline
								156 & 78 & 0 \\
								78  & 39 & 0 \\
								39  & 19 & 1 \\
								19  & 9  & 1 \\
								9   & 4  & 1 \\
								4   & 2  & 0 \\
								2   & 1  & 0 \\
								1   & 0  & 1 \\
							\end{tabular}
						\end{center}
						
						\[
						156_{10} = 10011100_2
						\]
						
						%------------------------------------------------
						\subsubsection*{2. Decimal $\rightarrow$ Octal (base $b=8$)}
						
						\noindent
						\textbf{Ejercicio 1: Convertir $83_{10}$ a octal}
						
						\begin{center}
							\begin{tabular}{c|c|c}
								$N$ & $N \div 8$ & Residuo \\
								\hline
								83 & 10 & 3 \\
								10 & 1  & 2 \\
								1  & 0  & 1 \\
							\end{tabular}
						\end{center}
						
						\[
						83_{10} = 123_8
						\]
						
						\noindent
						\textbf{Ejercicio 2: Convertir $250_{10}$ a octal}
						
						\begin{center}
							\begin{tabular}{c|c|c}
								$N$ & $N \div 8$ & Residuo \\
								\hline
								250 & 31 & 2 \\
								31  & 3  & 7 \\
								3   & 0  & 3 \\
							\end{tabular}
						\end{center}
						
						\[
						250_{10} = 372_8
						\]
						
						%------------------------------------------------
						\subsubsection*{3. Decimal $\rightarrow$ Hexadecimal (base $b=16$)}
						
						\noindent
						\textbf{Ejercicio 1: Convertir $254_{10}$ a hexadecimal}
						
						\begin{center}
							\begin{tabular}{c|c|c}
								$N$ & $N \div 16$ & Residuo \\
								\hline
								254 & 15 & 14 \\
								15  & 0  & 15 \\
							\end{tabular}
						\end{center}
						
						Reemplazando residuos:
						\[
						14 = E, \quad 15 = F
						\]
						
						\[
						254_{10} = FE_{16}
						\]
						
						\noindent
						\textbf{Ejercicio 2: Convertir $1023_{10}$ a hexadecimal}
						
						\begin{center}
							\begin{tabular}{c|c|c}
								$N$ & $N \div 16$ & Residuo \\
								\hline
								1023 & 63 & 15 \\
								63   & 3  & 15 \\
								3    & 0  & 3 \\
							\end{tabular}
						\end{center}
						
						Reemplazando residuos:
						\[
						15 = F
						\]
						
						\[
						1023_{10} = 3FF_{16}
						\]
						
						\paragraph{Familia B: conversión \emph{hacia decimal} mediante expansión posicional}
						Este procedimiento se aplica cuando el número de entrada está en base $b$ y se desea su equivalente en base $10$ (por ejemplo, binario$\rightarrow$decimal, octal$\rightarrow$decimal, hexadecimal$\rightarrow$decimal). Se fundamenta en el sistema posicional, donde cada dígito pondera una potencia de la base \cite{Wirth1976Algorithms,Tanenbaum2021Structured,Manzano2017Programacion}.
						
						La conversión también funciona como ejercicio de pruebas. El estudiante puede verificar propiedades de reversibilidad (convertir y retornar), detectar discrepancias por redondeo y documentar supuestos sobre rangos. Esta práctica fortalece hábitos de verificación y depuración~\cite{Ghezzi2003Fundamentals,Pressman2019Software,Hanly2015Problem}.
						
						\begin{enumerate}
							\item Identificar la base $b$ del número de entrada (2, 8 o 16).
							\item Enumerar los dígitos de derecha a izquierda, asignando exponente $0$ al dígito menos significativo.
							\item Para cada dígito $d_i$, calcular $d_i \cdot b^i$.
							\item Sumar todos los productos obtenidos.
							\item El resultado total corresponde al valor en base decimal.
						\end{enumerate}
						
						\textbf{Casos cubiertos por esta familia:}
						\begin{itemize}
							\item \textbf{Binario $\rightarrow$ Decimal} (base $b=2$)
							\item \textbf{Octal $\rightarrow$ Decimal} (base $b=8$)
							\item \textbf{Hexadecimal $\rightarrow$ Decimal} (base $b=16$, con $A=10,\dots,F=15$)
						\end{itemize}
						
						\subsubsection*{Ejercicios resueltos: Conversión hacia decimal mediante expansión posicional}
						
						\noindent
						A continuación se presentan dos ejercicios completos para cada caso cubierto por la familia de conversión hacia base decimal utilizando expansión posicional. En cada ejercicio se siguen estrictamente los pasos establecidos: identificar la base, enumerar dígitos de derecha a izquierda, multiplicar por potencias de la base y sumar los productos.
						
						%------------------------------------------------
						\subsubsection*{1. Binario $\rightarrow$ Decimal (base $b=2$)}
						
						\noindent
						\textbf{Ejercicio 1: Convertir $101101_2$ a decimal}
						
						\noindent
						\textbf{Paso 1:} Base identificada: $b=2$
						
						\noindent
						\textbf{Paso 2:} Enumerar dígitos de derecha a izquierda (exponente 0 al menos significativo)
						
						\begin{center}
							\begin{tabular}{c|c|c|c}
								Dígito ($d_i$) & Posición $i$ & Potencia $2^i$ & Producto $d_i\cdot 2^i$ \\
								\hline
								1 & 0 & $2^0=1$  & $1\cdot 1 = 1$ \\
								0 & 1 & $2^1=2$  & $0\cdot 2 = 0$ \\
								1 & 2 & $2^2=4$  & $1\cdot 4 = 4$ \\
								1 & 3 & $2^3=8$  & $1\cdot 8 = 8$ \\
								0 & 4 & $2^4=16$ & $0\cdot 16 = 0$ \\
								1 & 5 & $2^5=32$ & $1\cdot 32 = 32$ \\
							\end{tabular}
						\end{center}
						
						\noindent
						\textbf{Paso final:} Sumar productos:
						
						\[
						1 + 0 + 4 + 8 + 0 + 32 = 45
						\]
						
						\[
						101101_2 = 45_{10}
						\]
						
						\noindent
						\textbf{Ejercicio 2: Convertir $10011100_2$ a decimal}
						
						\noindent
						\textbf{Paso 1:} Base identificada: $b=2$
						
						\begin{center}
							\begin{tabular}{c|c|c|c}
								Dígito ($d_i$) & Posición $i$ & Potencia $2^i$ & Producto $d_i\cdot 2^i$ \\
								\hline
								0 & 0 & $2^0=1$   & $0\cdot 1 = 0$ \\
								0 & 1 & $2^1=2$   & $0\cdot 2 = 0$ \\
								1 & 2 & $2^2=4$   & $1\cdot 4 = 4$ \\
								1 & 3 & $2^3=8$   & $1\cdot 8 = 8$ \\
								1 & 4 & $2^4=16$  & $1\cdot 16 = 16$ \\
								0 & 5 & $2^5=32$  & $0\cdot 32 = 0$ \\
								0 & 6 & $2^6=64$  & $0\cdot 64 = 0$ \\
								1 & 7 & $2^7=128$ & $1\cdot 128 = 128$ \\
							\end{tabular}
						\end{center}
						
						\noindent
						\textbf{Paso final:} Sumar productos:
						
						\[
						0 + 0 + 4 + 8 + 16 + 0 + 0 + 128 = 156
						\]
						
						\[
						10011100_2 = 156_{10}
						\]
						
						%------------------------------------------------
						\subsubsection*{2. Octal $\rightarrow$ Decimal (base $b=8$)}
						
						\noindent
						\textbf{Ejercicio 1: Convertir $372_8$ a decimal}
						
						\noindent
						\textbf{Paso 1:} Base identificada: $b=8$
						
						\begin{center}
							\begin{tabular}{c|c|c|c}
								Dígito ($d_i$) & Posición $i$ & Potencia $8^i$ & Producto $d_i\cdot 8^i$ \\
								\hline
								2 & 0 & $8^0=1$   & $2\cdot 1 = 2$ \\
								7 & 1 & $8^1=8$   & $7\cdot 8 = 56$ \\
								3 & 2 & $8^2=64$  & $3\cdot 64 = 192$ \\
							\end{tabular}
						\end{center}
						
						\noindent
						\textbf{Paso final:} Sumar productos:
						
						\[
						2 + 56 + 192 = 250
						\]
						
						\[
						372_8 = 250_{10}
						\]
						
						\noindent
						\textbf{Ejercicio 2: Convertir $123_8$ a decimal}
						
						\noindent
						\textbf{Paso 1:} Base identificada: $b=8$
						
						\begin{center}
							\begin{tabular}{c|c|c|c}
								Dígito ($d_i$) & Posición $i$ & Potencia $8^i$ & Producto $d_i\cdot 8^i$ \\
								\hline
								3 & 0 & $8^0=1$  & $3\cdot 1 = 3$ \\
								2 & 1 & $8^1=8$  & $2\cdot 8 = 16$ \\
								1 & 2 & $8^2=64$ & $1\cdot 64 = 64$ \\
							\end{tabular}
						\end{center}
						
						\noindent
						\textbf{Paso final:} Sumar productos:
						
						\[
						3 + 16 + 64 = 83
						\]
						
						\[
						123_8 = 83_{10}
						\]
						
						%------------------------------------------------
						\subsubsection*{3. Hexadecimal $\rightarrow$ Decimal (base $b=16$)}
						
						\noindent
						\textbf{Ejercicio 1: Convertir $FE_{16}$ a decimal}
						
						\noindent
						\textbf{Paso 1:} Base identificada: $b=16$, con $F=15$ y $E=14$
						
						\begin{center}
							\begin{tabular}{c|c|c|c}
								Dígito ($d_i$) & Posición $i$ & Potencia $16^i$ & Producto $d_i\cdot 16^i$ \\
								\hline
								$E=14$ & 0 & $16^0=1$  & $14\cdot 1 = 14$ \\
								$F=15$ & 1 & $16^1=16$ & $15\cdot 16 = 240$ \\
							\end{tabular}
						\end{center}
						
						\noindent
						\textbf{Paso final:} Sumar productos:
						
						\[
						14 + 240 = 254
						\]
						
						\[
						FE_{16} = 254_{10}
						\]
						
						\noindent
						\textbf{Ejercicio 2: Convertir $3FF_{16}$ a decimal}
						
						\noindent
						\textbf{Paso 1:} Base identificada: $b=16$, con $F=15$
						
						\begin{center}
							\begin{tabular}{c|c|c|c}
								Dígito ($d_i$) & Posición $i$ & Potencia $16^i$ & Producto $d_i\cdot 16^i$ \\
								\hline
								$F=15$ & 0 & $16^0=1$    & $15\cdot 1 = 15$ \\
								$F=15$ & 1 & $16^1=16$   & $15\cdot 16 = 240$ \\
								$3$    & 2 & $16^2=256$  & $3\cdot 256 = 768$ \\
							\end{tabular}
						\end{center}
						
						\noindent
						\textbf{Paso final:} Sumar productos:
						
						\[
						15 + 240 + 768 = 1023
						\]
						
						\[
						3FF_{16} = 1023_{10}
						\]
						
						\paragraph{Familia C: conversiones entre bases potencia de 2 mediante agrupación de bits}
						Cuando las bases son potencias de 2, las conversiones pueden realizarse por \emph{agrupación de bits} sin pasar por decimal, lo cual simplifica depuración y permite implementar conversores eficientes \cite{Tanenbaum2021Structured,Sebesta2018Concepts,Wirth1976Algorithms}. En particular, $8=2^3$ y $16=2^4$.
						
						\subparagraph{C1. Binario $\leftrightarrow$ Octal (grupos de 3 bits)}
						\textbf{Binario $\rightarrow$ Octal}
						\begin{enumerate}
							\item Separar el número binario en grupos de 3 bits desde la derecha.
							\item Si el grupo más a la izquierda queda incompleto, rellenar con ceros a la izquierda hasta completar 3 bits.
							\item Convertir cada grupo de 3 bits a su valor decimal (0 a 7).
							\item Escribir esos valores consecutivamente como dígitos octales.
						\end{enumerate}
						
						\textbf{Octal $\rightarrow$ Binario}
						\begin{enumerate}
							\item Tomar cada dígito octal por separado (0 a 7).
							\item Convertir cada dígito a su forma binaria de 3 bits (por ejemplo, $5_8 \rightarrow 101_2$).
							\item Concatenar los grupos de 3 bits en el mismo orden para formar el binario final.
							\item Si se desea una forma normalizada, eliminar ceros a la izquierda que no aporten valor.
						\end{enumerate}
						
						\subparagraph{C2. Binario $\leftrightarrow$ Hexadecimal (grupos de 4 bits)}
						\textbf{Binario $\rightarrow$ Hexadecimal}
						\begin{enumerate}
							\item Separar el número binario en grupos de 4 bits desde la derecha.
							\item Rellenar con ceros a la izquierda el grupo más significativo si fuera necesario.
							\item Convertir cada grupo de 4 bits a su valor (0 a 15).
							\item Reemplazar 10--15 por $A$--$F$.
							\item Concatenar los dígitos resultantes para obtener el número hexadecimal.
						\end{enumerate}
						
						\textbf{Hexadecimal $\rightarrow$ Binario}
						\begin{enumerate}
							\item Tomar cada dígito hexadecimal por separado (0--9, A--F).
							\item Convertirlo a su valor entero (A=10, ..., F=15).
							\item Representar ese valor como binario de 4 bits.
							\item Concatenar los grupos de 4 bits en el mismo orden.
							\item Normalizar quitando ceros a la izquierda si corresponde.
						\end{enumerate}
						
						\subsubsection*{Ejercicios resueltos: Conversión entre bases potencia de 2 con longitudes no divisibles}
						
						\noindent
						En los siguientes ejercicios se emplean cantidades de bits que no son múltiplos de 3 ni de 4 (por ejemplo, 8, 16 y 32 bits). Esto obliga a aplicar correctamente el paso de relleno con ceros a la izquierda antes de agrupar, lo cual es relevante cuando se trabaja con registros completos de memoria o tipos de datos estándar en programación (byte de 8 bits, palabra de 16 bits, entero de 32 bits).
						
						%------------------------------------------------
						\subsubsection*{1. Binario $\rightarrow$ Octal (8, 16 y 32 bits)}
						
						\noindent
						\textbf{Ejercicio 1: Convertir $10110110_2$ (8 bits) a octal}
						
						\noindent
						\textbf{Paso 1:} Agrupar desde la derecha en bloques de 3 bits:
						
						\[
						10\;110\;110
						\]
						
						\noindent
						\textbf{Paso 2:} Rellenar con ceros a la izquierda:
						
						\[
						010\;110\;110
						\]
						
						\noindent
						\textbf{Paso 3:} Convertir cada grupo:
						
						\[
						010_2=2,\quad 110_2=6,\quad 110_2=6
						\]
						
						\noindent
						\textbf{Paso 4:} Resultado:
						
						\[
						10110110_2 = 266_8
						\]
						
						\noindent
						\emph{Observación adicional:} En programación, un byte (8 bits) no coincide naturalmente con bloques de 3 bits; por ello, el relleno garantiza que la representación octal conserve el valor exacto del patrón binario.
						
						\bigskip
						
						\noindent
						\textbf{Ejercicio 2: Convertir $1100110010101101_2$ (16 bits) a octal}
						
						\noindent
						\textbf{Paso 1:}
						
						\[
						110\;011\;001\;010\;110\;1
						\]
						
						\noindent
						\textbf{Paso 2:} Rellenar:
						
						\[
						001\;100\;110\;010\;101\;101
						\]
						
						\noindent
						\textbf{Paso 3:}
						
						\[
						001=1,\;100=4,\;110=6,\;010=2,\;101=5,\;101=5
						\]
						
						\noindent
						\textbf{Paso 4:}
						
						\[
						1100110010101101_2 = 146255_8
						\]
						
						\noindent
						\emph{Observación adicional:} En registros de 16 bits, la agrupación produce más dígitos octales que bytes disponibles, lo que demuestra que el tamaño de palabra y la base elegida influyen en la forma externa del número.
						
						%------------------------------------------------
						\subsubsection*{2. Octal $\rightarrow$ Binario (resultados de 8, 16 y 32 bits)}
						
						\noindent
						\textbf{Ejercicio 1: Convertir $347_8$ a binario}
						
						\noindent
						\textbf{Paso 1:}
						
						\[
						3,\;4,\;7
						\]
						
						\noindent
						\textbf{Paso 2:}
						
						\[
						3=011,\;4=100,\;7=111
						\]
						
						\noindent
						\textbf{Paso 3:}
						
						\[
						011100111_2
						\]
						
						\noindent
						\textbf{Paso 4:} Normalizar:
						
						\[
						11100111_2
						\]
						
						\noindent
						\emph{Observación adicional:} El resultado tiene 8 bits tras eliminar el cero inicial, coincidiendo con un byte completo.
						
						\bigskip
						
						\noindent
						\textbf{Ejercicio 2: Convertir $15723_8$ a binario}
						
						\noindent
						\textbf{Paso 1:}
						
						\[
						1,\;5,\;7,\;2,\;3
						\]
						
						\noindent
						\textbf{Paso 2:}
						
						\[
						001,\;101,\;111,\;010,\;011
						\]
						
						\noindent
						\textbf{Paso 3:}
						
						\[
						001101111010011_2
						\]
						
						\noindent
						\textbf{Paso 4:} Normalizar:
						
						\[
						1101111010011_2
						\]
						
						\noindent
						\emph{Observación adicional:} Este resultado no es múltiplo de 8 bits; al almacenarlo en memoria real, el compilador ajustaría el tamaño al tipo de dato correspondiente.
						
						%------------------------------------------------
						\subsubsection*{3. Binario $\rightarrow$ Hexadecimal (8, 16 y 32 bits)}
						
						\noindent
						\textbf{Ejercicio 1: Convertir $10101101_2$ (8 bits) a hexadecimal}
						
						\noindent
						\textbf{Paso 1:} Agrupar en bloques de 4 bits:
						
						\[
						1010\;1101
						\]
						
						\noindent
						\textbf{Paso 2:} No requiere relleno.
						
						\noindent
						\textbf{Paso 3:}
						
						\[
						1010=10=A,\quad 1101=13=D
						\]
						
						\noindent
						\textbf{Paso 4:}
						
						\[
						10101101_2 = AD_{16}
						\]
						
						\noindent
						\emph{Observación adicional:} Un byte equivale exactamente a dos dígitos hexadecimales; por ello, hexadecimal resulta especialmente práctico para inspección de memoria.
						
						\bigskip
						
						\noindent
						\textbf{Ejercicio 2: Convertir $1100101011110001_2$ (16 bits) a hexadecimal}
						
						\noindent
						\textbf{Paso 1:}
						
						\[
						1100\;1010\;1111\;0001
						\]
						
						\noindent
						\textbf{Paso 2:}
						
						\[
						1100=12=C,\;1010=10=A,\;1111=15=F,\;0001=1
						\]
						
						\noindent
						\textbf{Paso 3:}
						
						\[
						1100101011110001_2 = CAF1_{16}
						\]
						
						\noindent
						\emph{Observación adicional:} En 16 bits se obtienen cuatro dígitos hexadecimales; esta relación directa simplifica la depuración en lenguajes de bajo nivel.
						
						%------------------------------------------------
						\subsubsection*{4. Hexadecimal $\rightarrow$ Binario (32 bits)}
						
						\noindent
						\textbf{Ejercicio 1: Convertir $1A3F_{16}$ a binario}
						
						\noindent
						\textbf{Paso 1:}
						
						\[
						1,\;A,\;3,\;F
						\]
						
						\noindent
						\textbf{Paso 2:}
						
						\[
						0001,\;1010,\;0011,\;1111
						\]
						
						\noindent
						\textbf{Paso 3:}
						
						\[
						0001101000111111_2
						\]
						
						\noindent
						\textbf{Paso 4:} Normalizar:
						
						\[
						1101000111111_2
						\]
						
						\noindent
						\emph{Observación adicional:} Aunque el número puede escribirse sin ceros iniciales, en memoria podría almacenarse en 16 o 32 bits según el tipo de dato.
						
						\bigskip
						
						\noindent
						\textbf{Ejercicio 2: Convertir $89ABCDEF_{16}$ a binario (32 bits)}
						
						\noindent
						\textbf{Paso 1:}
						
						\[
						8,\;9,\;A,\;B,\;C,\;D,\;E,\;F
						\]
						
						\noindent
						\textbf{Paso 2:}
						
						\[
						1000,\;1001,\;1010,\;1011,\;1100,\;1101,\;1110,\;1111
						\]
						
						\noindent
						\textbf{Paso 3:}
						
						\[
						10001001101010111100110111101111_2
						\]
						
						\noindent
						\paragraph{Observación adicional:} Cada dígito hexadecimal representa exactamente 4 bits; por ello, 8 dígitos hexadecimales equivalen a 32 bits completos, tamaño típico de un entero estándar en muchos lenguajes de programación.
						
						\paragraph{Familia D: conversiones Octal $\leftrightarrow$ Hexadecimal mediante puente binario}
						Octal y hexadecimal no son potencias directas entre sí, aunque ambas son potencias de 2. Un procedimiento estable consiste en convertir primero a binario y luego a la base destino, manteniendo pasos sistemáticos y fáciles de programar \cite{Tanenbaum2021Structured,Hanly2015Problem,Gaddis2022Starting}.
						
						\subparagraph{D1. Octal $\rightarrow$ Hexadecimal}
						\begin{enumerate}
							\item Convertir cada dígito octal a 3 bits y concatenar para obtener el binario (procedimiento C1).
							\item Agrupar el binario en bloques de 4 bits desde la derecha (procedimiento C2).
							\item Convertir cada bloque a hexadecimal y concatenar.
						\end{enumerate}
						
						\subparagraph{D2. Hexadecimal $\rightarrow$ Octal}
						\begin{enumerate}
							\item Convertir cada dígito hexadecimal a 4 bits y concatenar para obtener el binario (procedimiento C2).
							\item Agrupar el binario en bloques de 3 bits desde la derecha (procedimiento C1).
							\item Convertir cada bloque a octal y concatenar.
						\end{enumerate}
						
						\paragraph{Mapa completo de conversiones (con familia aplicable)}
						\begin{itemize}
							\item Decimal $\rightarrow$ Binario: Familia A
							\item Binario $\rightarrow$ Decimal: Familia B
							\item Decimal $\rightarrow$ Octal: Familia A
							\item Octal $\rightarrow$ Decimal: Familia B
							\item Decimal $\rightarrow$ Hexadecimal: Familia A
							\item Hexadecimal $\rightarrow$ Decimal: Familia B
							\item Binario $\rightarrow$ Octal: Familia C1
							\item Octal $\rightarrow$ Binario: Familia C1
							\item Binario $\rightarrow$ Hexadecimal: Familia C2
							\item Hexadecimal $\rightarrow$ Binario: Familia C2
							\item Octal $\rightarrow$ Hexadecimal: Familia D (puente binario)
							\item Hexadecimal $\rightarrow$ Octal: Familia D (puente binario)
						\end{itemize}
						
						\subsubsection*{Ejercicios resueltos: Conversión Octal $\leftrightarrow$ Hexadecimal mediante puente binario}
						
						\noindent
						A continuación se presentan dos ejercicios completos para cada caso de la Familia D. En cada uno se sigue estrictamente el procedimiento: conversión intermedia a binario, reagrupación y conversión final. Se emplean longitudes que no son múltiplos directos entre 3 y 4 para evidenciar la necesidad de relleno y normalización.
						
						%------------------------------------------------
						\subsubsection*{1. Octal $\rightarrow$ Hexadecimal (puente binario)}
						
						\noindent
						\textbf{Ejercicio 1: Convertir $735_8$ a hexadecimal}
						
						\noindent
						\textbf{Paso 1:} Convertir cada dígito octal a 3 bits
						
						\[
						7=111,\quad 3=011,\quad 5=101
						\]
						
						\[
						735_8 \rightarrow 111011101_2
						\]
						
						\noindent
						\textbf{Paso 2:} Agrupar en bloques de 4 bits desde la derecha
						
						\[
						1110\;1110\;1
						\]
						
						\noindent
						Rellenar a la izquierda:
						
						\[
						0001\;1101\;1101
						\]
						
						\noindent
						\textbf{Paso 3:} Convertir cada bloque a hexadecimal
						
						\[
						0001=1,\quad 1101=D,\quad 1101=D
						\]
						
						\[
						735_8 = 1DD_{16}
						\]
						
						\noindent
						\emph{Observación adicional:} Aunque el número original tenía 9 bits intermedios, el relleno garantiza alineación correcta en bloques de 4 bits, lo cual es indispensable al programar conversores automáticos.
						
						\bigskip
						
						\noindent
						\textbf{Ejercicio 2: Convertir $12647_8$ a hexadecimal}
						
						\noindent
						\textbf{Paso 1:}
						
						\[
						1=001,\quad 2=010,\quad 6=110,\quad 4=100,\quad 7=111
						\]
						
						\[
						12647_8 \rightarrow 001010110100111_2
						\]
						
						\noindent
						\textbf{Paso 2:} Agrupar en bloques de 4 bits
						
						\[
						0010\;1011\;0100\;111
						\]
						
						\noindent
						Rellenar:
						
						\[
						0001\;0101\;1010\;0111
						\]
						
						\noindent
						\textbf{Paso 3:}
						
						\[
						0001=1,\;0101=5,\;1010=A,\;0111=7
						\]
						
						\[
						12647_8 = 15A7_{16}
						\]
						
						\noindent
						\emph{Observación adicional:} Este procedimiento evidencia que la longitud binaria intermedia no coincide necesariamente con 8, 16 o 32 bits; la alineación depende del patrón generado por la base original.
						
						%------------------------------------------------
						\subsubsection*{2. Hexadecimal $\rightarrow$ Octal (puente binario)}
						
						\noindent
						\textbf{Ejercicio 1: Convertir $2AF_{16}$ a octal}
						
						\noindent
						\textbf{Paso 1:} Convertir cada dígito hexadecimal a 4 bits
						
						\[
						2=0010,\quad A=1010,\quad F=1111
						\]
						
						\[
						2AF_{16} \rightarrow 001010101111_2
						\]
						
						\noindent
						\textbf{Paso 2:} Agrupar en bloques de 3 bits desde la derecha
						
						\[
						001\;010\;101\;111
						\]
						
						\noindent
						\textbf{Paso 3:} Convertir cada bloque a octal
						
						\[
						001=1,\;010=2,\;101=5,\;111=7
						\]
						
						\[
						2AF_{16} = 1257_8
						\]
						
						\noindent
						\paragraph{Observación adicional:} Obsérvese que 3 dígitos hexadecimales (12 bits) producen exactamente 4 dígitos octales (también 12 bits), lo cual facilita validaciones cruzadas en programas.
						
						\bigskip
						
						\noindent
						\textbf{Ejercicio 2: Convertir $4C3D_{16}$ a octal}
						
						\noindent
						\textbf{Paso 1:}
						
						\[
						4=0100,\quad C=1100,\quad 3=0011,\quad D=1101
						\]
						
						\[
						4C3D_{16} \rightarrow 0100110000111101_2
						\]
						
						\noindent
						\textbf{Paso 2:} Agrupar en bloques de 3 bits
						
						\[
						010\;011\;000\;011\;110\;1
						\]
						
						\noindent
						Rellenar:
						
						\[
						001\;001\;100\;001\;111\;101
						\]
						
						\noindent
						\textbf{Paso 3:}
						
						\[
						001=1,\;001=1,\;100=4,\;001=1,\;111=7,\;101=5
						\]
						
						\[
						4C3D_{16} = 114175_8
						\]
						
						\noindent
						\paragraph{Observación adicional:} En este caso, 16 bits generan 6 dígitos octales tras el relleno; esta diferencia estructural es relevante cuando se diseñan funciones de conversión en lenguajes que manipulan enteros de tamaño fijo.
						No obstante, la conversión presenta límites cuando intervienen números reales. En esos casos, la representación depende de estándares de punto flotante, donde ciertos valores no pueden representarse exactamente. Reconocer esta limitación evita errores interpretativos en cálculos financieros o métricas operativas~\cite{Goldberg1991What,IEEE2019Standard754,Chapra2014Numerical}.
					
					\subsubsection{Conversión y representación de valores reales en distintos sistemas de numeración}
						\noindent	
						Hasta este punto, los procedimientos descritos se han aplicado principalmente a números enteros. No obstante, en SI gran parte de los datos procesados corresponden a cantidades reales: montos financieros, promedios, tasas, porcentajes y métricas continuas. La conversión y representación de estos valores requiere extender los pasos anteriores, incorporando el tratamiento de la parte fraccionaria y considerando las limitaciones inherentes a la representación en punto flotante \cite{Goldberg1991What,IEEE2019Standard754,Chapra2014Numerical}.
						
						\paragraph{1. Extensión del modelo posicional a números reales.} En un sistema posicional de base $b$, un número real puede expresarse como:
						
						\[
						N = \sum_{i=-m}^{n} d_i \cdot b^i
						\]
						
						\noindent
						donde los exponentes negativos representan posiciones fraccionarias. Por ejemplo, en base decimal:
						
						\[
						45.375_{10} = 4\cdot10^1 + 5\cdot10^0 + 3\cdot10^{-1} + 7\cdot10^{-2} + 5\cdot10^{-3}
						\]
						
						\noindent
						Esta formulación generaliza el esquema utilizado para enteros e introduce un aspecto formativo clave: la parte fraccionaria se construye mediante potencias negativas de la base \cite{Wirth1976Algorithms,Hanly2015Problem,Manzano2017Programacion}. Para quien aprende a programar, este modelo permite diseñar algoritmos sistemáticos de conversión que tratan por separado parte entera y parte decimal.
						
						\paragraph{2. Conversión de decimal real a otra base.} Cuando se convierte un número decimal real a base $b$ (por ejemplo, decimal $\rightarrow$ binario), el procedimiento se divide en dos fases:
						
						\noindent
						\textbf{Parte entera (igual que antes):}
						\begin{enumerate}
							\item Aplicar divisiones sucesivas entre la base $b$.
							\item Registrar residuos.
							\item Leer residuos en orden inverso.
						\end{enumerate}
						
						\noindent
						\textbf{Parte fraccionaria:}
						\begin{enumerate}
							\item Tomar la parte decimal $f$.
							\item Multiplicar $f$ por la base $b$.
							\item El entero resultante constituye el siguiente dígito fraccionario.
							\item Conservar la nueva parte fraccionaria.
							\item Repetir hasta que la fracción sea 0 o hasta alcanzar la precisión deseada.
						\end{enumerate}
						
						\noindent
						Ejemplo conceptual: convertir $0.625_{10}$ a binario.
						
						\[
						0.625 \times 2 = 1.25 \Rightarrow 1
						\]
						\[
						0.25 \times 2 = 0.5 \Rightarrow 0
						\]
						\[
						0.5 \times 2 = 1.0 \Rightarrow 1
						\]
						
						\noindent
						Resultado: $0.101_2$
						
						Este procedimiento enseña al estudiante a manejar bucles controlados por precisión, introduciendo nociones de tolerancia y límite de iteraciones \cite{Hanly2015Problem,Gaddis2022Starting,Chapra2014Numerical}.
						
						\subsubsection*{Ejemplos resueltos: Conversión de números reales (con parte fraccionaria)}
						
						\noindent
						A continuación se presentan dos ejemplos completos de conversión de números reales desde base decimal hacia otra base. En ambos casos se aplican las dos fases del procedimiento: conversión de la parte entera mediante divisiones sucesivas y conversión de la parte fraccionaria mediante multiplicaciones sucesivas. El primer ejemplo produce una expansión finita; el segundo genera una expansión infinita periódica. Para representar una serie infinita se puede usar la siguiente notación $0.\overline{133}_3$, \textbf{\textit{133} se repite infinitamente y su base es \textit{3}}.
						
						%------------------------------------------------
						\subsubsection*{Ejemplo 1: Conversión finita}
						\noindent
						\textbf{Convertir $13.625_{10}$ a binario}
						
						\subsubsection*{Parte entera}
						
						\noindent
						$N = 13$
						
						\begin{center}
							\begin{tabular}{c|c|c}
								$N$ & $N \div 2$ & Residuo \\
								\hline
								13 & 6 & 1 \\
								6  & 3 & 0 \\
								3  & 1 & 1 \\
								1  & 0 & 1 \\
							\end{tabular}
						\end{center}
						
						\noindent
						Leer residuos en orden inverso:
						
						\[
						13_{10} = 1101_2
						\]
						
						\subsubsection*{Parte fraccionaria}
						
						\noindent
						$f = 0.625$
						
						\[
						0.625 \times 2 = 1.25 \Rightarrow 1
						\]
						\[
						0.25 \times 2 = 0.5 \Rightarrow 0
						\]
						\[
						0.5 \times 2 = 1.0 \Rightarrow 1
						\]
						
						\noindent
						La fracción se hace 0, por lo tanto la conversión termina.
						
						\[
						0.625_{10} = 0.101_2
						\]
						
						\noindent
						\textbf{Resultado final}
						
						\[
						13.625_{10} = 1101.101_2
						\]
						
						\noindent
						\emph{Observación adicional:} La conversión es finita porque $0.625 = \frac{5}{8}$ y el denominador es potencia de 2. Cuando la fracción decimal puede expresarse como $k/2^n$, su representación binaria termina.
						
						%------------------------------------------------
						\subsubsection*{Ejemplo 2: Conversión infinita periódica}
						\noindent
						\textbf{Convertir $7.1_{10}$ a binario}
						
						\subsubsection*{Parte entera}
						
						\noindent
						$N = 7$
						
						\begin{center}
							\begin{tabular}{c|c|c}
								$N$ & $N \div 2$ & Residuo \\
								\hline
								7 & 3 & 1 \\
								3 & 1 & 1 \\
								1 & 0 & 1 \\
							\end{tabular}
						\end{center}
						
						\[
						7_{10} = 111_2
						\]
						
						\subsubsection*{Parte fraccionaria}
						
						\noindent
						$f = 0.1$
						
						\[
						0.1 \times 2 = 0.2 \Rightarrow 0
						\]
						\[
						0.2 \times 2 = 0.4 \Rightarrow 0
						\]
						\[
						0.4 \times 2 = 0.8 \Rightarrow 0
						\]
						\[
						0.8 \times 2 = 1.6 \Rightarrow 1
						\]
						\[
						0.6 \times 2 = 1.2 \Rightarrow 1
						\]
						\[
						0.2 \times 2 = 0.4 \Rightarrow 0
						\]
						
						\noindent
						Se observa que reaparece el valor 0.2, por lo que el patrón se repite.
						
						\[
						0.1_{10} = 0.0001100110011\ldots_2
						\]
						
						\noindent
						\textbf{Resultado final}
						
						\[
						7.1_{10} = 111.0001100110011\ldots_2
						\]
						
						\noindent
						\paragraph{Observación adicional:} La expansión no termina porque $0.1 = \frac{1}{10}$ y el denominador contiene factores primos distintos de 2. En sistemas digitales, esta representación infinita se aproxima con un número finito de bits, lo que explica errores de redondeo en cálculos con punto flotante.
						
						\paragraph{3. Conversión desde otra base hacia decimal (valores reales). } El proceso inverso aplica expansión posicional incluyendo potencias negativas:
						
						Ejemplo: convertir $101.101_2$ a decimal.
						
						\[
						1\cdot2^2 + 0\cdot2^1 + 1\cdot2^0 + 1\cdot2^{-1} + 0\cdot2^{-2} + 1\cdot2^{-3}
						\]
						
						\[
						= 4 + 0 + 1 + 0.5 + 0 + 0.125 = 5.625_{10}
						\]
						
						\noindent
						El algoritmo consiste en:
						\begin{enumerate}
							\item Separar parte entera y fraccionaria.
							\item Aplicar expansión posicional con exponentes positivos y negativos.
							\item Sumar todos los términos.
						\end{enumerate}
						
						\noindent
						Este procedimiento refuerza el entendimiento del sistema posicional extendido y promueve implementación modular en código \cite{Wirth1976Algorithms,Manzano2017Programacion,Gaddis2022Starting}.
						
						\subsubsection*{Ejercicios resueltos: Conversión desde otra base hacia decimal (valores reales)}
						
						\noindent
						A continuación se presentan dos ejercicios completos aplicando expansión posicional con exponentes positivos y negativos. En ambos casos se separa parte entera y fraccionaria, y luego se suman todos los términos.
						
						%------------------------------------------------
						\subsubsection*{Ejemplo 1: Conversión finita}
						
						\noindent
						\textbf{Convertir $1011.011_2$ a decimal}
						
						\subsubsection*{Paso 1: Separar parte entera y fraccionaria}
						
						\[
						1011_2 \quad \text{y} \quad 0.011_2
						\]
						
						\subsubsection*{Paso 2: Expandir parte entera}
						
						\[
						1\cdot2^3 + 0\cdot2^2 + 1\cdot2^1 + 1\cdot2^0
						\]
						
						\[
						= 8 + 0 + 2 + 1 = 11
						\]
						
						\subsubsection*{Paso 3: Expandir parte fraccionaria}
						
						\[
						0\cdot2^{-1} + 1\cdot2^{-2} + 1\cdot2^{-3}
						\]
						
						\[
						= 0 + 0.25 + 0.125 = 0.375
						\]
						
						\subsubsection*{Resultado final}
						
						\[
						1011.011_2 = 11.375_{10}
						\]
						
						\noindent
						\emph{Observación adicional:} La conversión es finita porque la fracción binaria tiene un número limitado de dígitos; toda fracción binaria finita produce un decimal exacto.
						
						%------------------------------------------------
						\subsubsection*{Ejemplo 2: Conversión finita}
						
						\noindent
						\textbf{Convertir $27.34_8$ a decimal}
						
						\subsubsection*{Paso 1: Separar parte entera y fraccionaria}
						
						\[
						27_8 \quad \text{y} \quad 0.34_8
						\]
						
						\subsubsection*{Paso 2: Expandir parte entera}
						
						\[
						2\cdot8^1 + 7\cdot8^0
						\]
						
						\[
						= 16 + 7 = 23
						\]
						
						\subsubsection*{Paso 3: Expandir parte fraccionaria}
						
						\[
						3\cdot8^{-1} + 4\cdot8^{-2}
						\]
						
						\[
						= 3\cdot0.125 + 4\cdot0.015625
						\]
						
						\[
						= 0.375 + 0.0625 = 0.4375
						\]
						
						\subsubsection*{Resultado final}
						
						\[
						27.34_8 = 23.4375_{10}
						\]
						
						\noindent
						\emph{Observación adicional:} Las fracciones en base 8 también son potencias de 2, por lo que su representación decimal es exacta.
						
						%------------------------------------------------
						\subsubsection*{Ejemplo 3: Conversión periódica}
						
						\noindent
						\textbf{Convertir $0.333\ldots_3$ a decimal}
						
						\subsubsection*{Paso 1: Interpretar la fracción}
						
						\[
						0.333\ldots_3
						\]
						
						\subsubsection*{Paso 2: Expandir con potencias negativas}
						
						\[
						3\cdot3^{-1} + 3\cdot3^{-2} + 3\cdot3^{-3} + \ldots
						\]
						
						\[
						= 3\left(\frac{1}{3} + \frac{1}{9} + \frac{1}{27} + \ldots\right)
						\]
						
						\noindent
						Se trata de una serie geométrica infinita:
						
						\[
						= 3 \cdot \frac{\frac{1}{3}}{1 - \frac{1}{3}} = 3 \cdot \frac{\frac{1}{3}}{\frac{2}{3}} = 3 \cdot \frac{1}{2} = 1.5
						\]
						
						\subsubsection*{Resultado final}
						
						\[
						0.333\ldots_3 = 1.5_{10}
						\]
						
						\noindent
						\emph{Observación adicional:} Aunque la representación en base 3 es infinita, el valor decimal converge a un número racional exacto.
						
						%------------------------------------------------
						\subsubsection*{Ejemplo 4: Conversión periódica}
						
						\noindent
						\textbf{Convertir $0.\overline{1}_3$ a decimal}
						
						\subsubsection*{Paso 1: Expansión}
						
						\[
						1\cdot3^{-1} + 1\cdot3^{-2} + 1\cdot3^{-3} + \ldots
						\]
						
						\[
						= \frac{1}{3} + \frac{1}{9} + \frac{1}{27} + \ldots
						\]
						
						\noindent
						Serie geométrica:
						
						\[
						= \frac{\frac{1}{3}}{1 - \frac{1}{3}} = \frac{\frac{1}{3}}{\frac{2}{3}} = \frac{1}{2}
						\]
						
						\subsubsection*{Resultado final}
						
						\[
						0.\overline{1}_3 = 0.5_{10}
						\]
						
						\noindent
						\emph{Observación adicional:} La periodicidad en una base distinta puede producir un decimal exacto; este fenómeno ilustra cómo la representación depende de la relación entre los factores primos de la base original y la base destino.
						
						\paragraph{4. Limitaciones fundamentales: representaciones no exactas.} No todos los números reales pueden representarse exactamente en todas las bases. Por ejemplo, $0.1_{10}$ no tiene representación finita en binario. Este fenómeno se debe a que la fracción depende de factores primos distintos de la base. En consecuencia, la representación en binario puede ser infinita o periódica, y el sistema debe aproximarla \cite{Goldberg1991What,IEEE2019Standard754,Chapra2014Numerical}.
						
						En programación, esta limitación explica resultados como:
						
						\[
						0.1 + 0.2 \neq 0.3
						\]
						
						\noindent
						cuando se utiliza punto flotante binario. Este comportamiento no constituye un error del lenguaje, sino una consecuencia matemática de la representación digital \cite{Goldberg1991What,IEEE2019Standard754,Gaddis2022Starting}.
						
						\paragraph{5. Estándar IEEE 754 y punto flotante.} La mayoría de los lenguajes utilizan el estándar IEEE 754 para representar números reales en binario. Este estándar define:
						
						\begin{itemize}
							\item 1 bit para el signo.
							\item Bits para exponente.
							\item Bits para mantisa.
						\end{itemize}
						
						\noindent
						La representación permite manejar un rango amplio de valores, aunque introduce redondeo y errores acumulativos en operaciones repetidas \cite{IEEE2019Standard754,Goldberg1991What,Tanenbaum2021Structured}.
						
						Para quien aprende a programar en IS, esta información resulta indispensable al trabajar con:
						
						\begin{itemize}
							\item Cálculos financieros.
							\item Indicadores estadísticos.
							\item Promedios y porcentajes.
						\end{itemize}
						
						\paragraph{6. Buenas prácticas en programación con reales.} El manejo responsable de valores reales incluye:
						
						\begin{enumerate}
							\item Evitar comparaciones directas de igualdad.
							\item Utilizar tolerancias: $|a-b| < \varepsilon$.
							\item Controlar redondeo antes de mostrar resultados.
							\item Documentar precisión esperada según dominio organizacional.
						\end{enumerate}
						\noindent
						Estas prácticas se alinean con principios de calidad y robustez en ingeniería de software \cite{Ghezzi2003Fundamentals,Sommerville2015Software,Pressman2019Software}.
						
						\paragraph{7. Implicación formativa.} La representación de números reales amplía la visión del estudiante sobre la naturaleza finita de los sistemas digitales. Programar con conciencia de precisión fortalece criterio técnico y evita interpretaciones erróneas de resultados en entornos organizacionales. Este aprendizaje trasciende ejercicios académicos y prepara al desarrollador para diseñar soluciones confiables dentro de Sistemas de Información \cite{Laudon2020Management,Leidig2021Competency,Ghezzi2003Fundamentals}.
						
					\subsubsection{Operaciones bit a bit, máscaras y estados}
						\noindent
						Las operaciones bit a bit ofrecen un mecanismo directo para manipular estados codificados. En IS, estados, permisos y banderas pueden representarse en bits para compactar información y habilitar verificaciones rápidas mediante AND, OR, XOR y desplazamientos~\cite{Wirth1976Algorithms,Manzano2017Programacion,Tanenbaum2021Structured}.
						
						\paragraph{Operadores bit a bit.}
						
						Las operaciones bit a bit permiten manipular directamente los bits que representan un número entero. En programación, esto permite activar, desactivar o verificar estados codificados dentro de un valor numérico.
						
						%=====================================================
						\subparagraph{1. Operador OR (|) a nivel de bit}
						\noindent
						\textbf{Problema:} Dado dos números enteros positivos, combinar sus bits utilizando la operación OR bit a bit y mostrar el resultado.
						
						\begin{lstlisting}[style=upsamStyle,caption={Operador OR (|) a nivel de bit}]
	Algoritmo OperadorOR
	Var
		a, b, resultado : entero
	Inicio
		a <- 10        // 1010 en binario
		b <- 12        // 1100 en binario
		
		resultado <- a | b
		
		Escribir("Resultado OR bit a bit : ", resultado)
	Fin \end{lstlisting}
						
						\noindent
						\textbf{Explicación:}
						\begin{lstlisting}
	10 (1010)  
	12 (1100)  
	OR produce 1110 = 14  \end{lstlisting}  
						Si alguno de los bits es 1, el resultado es 1.
						
						%=====================================================
						\subparagraph{2. Operador AND (\&) a nivel de bit}
						\noindent
						\textbf{Problema:} Determinar qué bits están activos simultáneamente en dos números.
						
						\begin{lstlisting}[style=upsamStyle,caption={Operador AND (\&) a nivel de bit}]
	Algoritmo OperadorAND
	Var
		a, b, resultado : entero
	inicio
		a <- 10        // 1010
		b <- 12        // 1100
		
		resultado <- a & b
		
		Escribir("Resultado AND: ", resultado)
	Fin \end{lstlisting}
						
						\noindent
						\textbf{Explicación:}
						\begin{lstlisting}
		Solo los bits que son 1 en ambos números permanecen en 1.  
		1010
		1100  
		AND produce 1000 = 8  \end{lstlisting}				
						%=====================================================
						\subparagraph{3. Operador XOR (\textasciicircum )}
						
						\noindent
						\textbf{Problema:} Determinar qué bits son diferentes entre dos números.
						
						\begin{lstlisting}[style=upsamStyle,caption={Determininar los bits diferentes entre dos números}]
	Algoritmo OperadorXOR
	Var
		a, b, resultado : entero
	Inicio
		a <- 10        // 1010
		b <- 12        // 1100
		
		resultado <- a XOR b
		
		Escribir("Resultado XOR: ", resultado)
	Fin \end{lstlisting}
						
						\noindent
						\textbf{Explicación:} El resultado es 1 cuando los bits son distintos. 
						\begin{lstlisting}
	1010
	1100
	XOR produce 0110 = 6 \end{lstlisting}
						%=====================================================
						\subparagraph{4. Desplazamiento Izquierdo}
						
						\noindent
						\textbf{Problema:} Multiplicar un número entero por 2 usando desplazamiento de bits.
						
						\begin{lstlisting}[style=upsamStyle,caption={Multiplicación entero por 2 con desplazamiento}]
	Algoritmo DesplazamientoIzquierdo
	Var
		numero, resultado : entero
	Inicio
		numero <- 5      // 0101
		
		resultado <- numero << 1
		
		Escribir("Resultado desplazamiento izquierdo: ", resultado)
	Fin \end{lstlisting}
						
						\noindent
						\textbf{Explicación:} Desplazar a la izquierda equivale a multiplicar por 2.  \texttt{0101 << 1} produce \texttt{1010 = 10}
						
						%=====================================================
						\subparagraph{5. Desplazamiento Derecho}
						
						\noindent
						\textbf{Problema:} Dividir un número entero entre 2 usando desplazamiento de bits.
						
						\begin{lstlisting}[style=upsamStyle,caption={Disión de enteros para 2 por desplazamiento}]
	Algoritmo DesplazamientoDerecho
	Var
	numero, resultado : ENTERO
	Inicio
	numero <- 8      // 1000
	
	resultado <- numero >> 1
	
	Escribir("Resultado desplazamiento derecho: ", resultado)
	Fin \end{lstlisting}
						
						\noindent
						\textbf{Explicación:} Desplazar a la derecha equivale a dividir entre 2.  
						\begin{lstlisting}
	1000 >> 1 produce 0100 = 4  \end{lstlisting}
						
						%=====================================================
						\subsubsection*{6. Diferencia entre | y ||}
						
						\textbf{Problema:}  
						Mostrar la diferencia entre OR lógico y OR bit a bit.
						
						\begin{lstlisting}[style=upsamStyle,caption={Diferencia entre OR bit a bit y OR lógico}]
	
	Algoritmo DiferenciaOR
	Var
		a, b : entero
	inicio
		a <- 5
		b <- 0
		
		Si (a | b) > 0 Entonces
			Escribir("OR bit a bit produjo valor distinto de 0")
		FinSi
		
		Si (a > 0) OR (b > 0) Entonces
			Escribir("OR logico verdadero")
		FinSi
	Fin \end{lstlisting}
						
						\noindent
						\textbf{Explicación:}
						
						\begin{itemize}[label=-]
							\item \texttt{|} combina bits.
							\item \texttt{||} evalúa condiciones lógicas.
							\item \texttt{||} produce \texttt{VERDADERO} o \texttt{FALSO}.
							\item \texttt{|} produce un número entero.
						\end{itemize}
						
						Estos algoritmos permiten que el estudiante observe cómo los números se manipulan a nivel binario, reforzando la relación entre representación digital y programación estructurada.
						
						\noindent
						Para quien aprende a programar, las máscaras introducen un repertorio práctico de técnicas. Verificar si un estado está activo, activar o desactivar banderas y construir combinaciones controladas permiten ejercitar operadores lógicos y condicionales con un sentido operativo inmediato~\cite{Gaddis2022Starting,Hanly2015Problem,Sebesta2018Concepts}.
						
						El uso de estados codificados se relaciona con diseño de datos. Definir qué bit representa qué condición requiere disciplina de especificación y documentación, lo que favorece programas más legibles y sostenibles. Esta práctica se conecta con principios de calidad y mantenibilidad en ingeniería de software~\cite{Sommerville2015Software,Ghezzi2003Fundamentals,Pressman2019Software}.
						
						Destacando la dimensión organizacional, las máscaras permiten modelar reglas sin inflar estructuras. En sistemas con gran cantidad de registros, representar atributos booleanos como bits reduce almacenamiento y acelera filtrado, lo que incide en desempeño del SI~\cite{Laudon2020Management,Sedgewick2011Algorithms,Tanenbaum2021Structured}.
						
						En síntesis, aprender operaciones bit a bit amplía la visión del lector sobre cómo el software controla estados reales y cómo una representación cuidadosa habilita soluciones robustas y eficientes~\cite{Wirth1976Algorithms,Gaddis2022Starting,Hanly2015Problem}.
						
				\subsection{Representación de texto, números y contenidos multimedia}
					\noindent
					Los SI manejan contenidos heterogéneos: nombres, direcciones, descripciones, cantidades, fechas e incluso imágenes o audio. Cada tipo de contenido exige una codificación adecuada para preservar significado, permitir búsquedas y sostener reglas de negocio~\cite{Laudon2020Management,Date2019Database,Elmasri2016Database}.
					
					La representación de texto y números constituye una fuente frecuente de defectos cuando se programa sin criterios. Incompatibilidades de codificación, supuestos sobre longitudes o errores por redondeo pueden degradar integridad del sistema y generar resultados que usuarios interpretan como inconsistencias operativas~\cite{ISO247722024Programming,Goldberg1991What,IEEE2019Standard754}.
					
					Para el aprendizaje, estos contenidos permiten ejercicios orientados a IS: normalización de entradas textuales, validación de campos, tratamiento de identificadores, cálculo de métricas y generación de reportes. Cada ejercicio vincula estructuras de datos con reglas organizacionales~\cite{Gaddis2022Starting,Hanly2015Problem,Kendall2014Systems}.
					
					De manera complementaria, la codificación de contenidos multimedia aparece en escenarios de gestión documental y sistemas que almacenan evidencias. Aunque su implementación completa suele ser avanzada, una introducción conceptual motiva al estudiante a reconocer que un archivo representa bytes con formato, cabeceras y restricciones de interpretación~\cite{Tanenbaum2021Structured,Silberschatz2018Operating,Laudon2020Management}.
					
					Este bloque se organiza en cinco líneas: codificación de caracteres, enteros, reales, formatos multimedia y representación temporal. Cada línea ofrece un motivo técnico para programar con precisión y un puente hacia prácticas de validación y prueba~\cite{Sommerville2015Software,Ghezzi2003Fundamentals,Pressman2019Software}.
					
					\subsubsection{Codificación de caracteres}
						\noindent
						La codificación de caracteres define cómo símbolos textuales se representan en bytes. En IS, texto incluye nombres, descripciones y mensajes; una codificación inadecuada introduce pérdida de información, errores de visualización y fallos en comparaciones o búsquedas~\cite{Laudon2020Management,ISO247722024Programming,Silberschatz2018Operating}.
						
						En programación, el lector debe reconocer que una cadena es una secuencia de códigos y que operaciones como longitud, recorte o concatenación dependen de la codificación subyacente. Esta perspectiva orienta a diseñar validaciones coherentes y evita suposiciones sobre “un carácter igual a un byte” en entornos multilingües~\cite{Gaddis2022Starting,Hanly2015Problem,Sebesta2018Concepts}.
						
						La codificación también afecta intercambio entre sistemas. Cuando un SI integra fuentes diversas, la uniformidad en codificación resulta indispensable para mantener consistencia y evitar corrupción de datos en almacenamiento o transmisión~\cite{Date2019Database,Elmasri2016Database,Laudon2020Management}.
						
						No obstante, el problema no se limita a visualización. Una codificación inconsistente puede alterar validaciones, ordenamientos y reglas de negocio basadas en texto, lo que se traduce en comportamientos incorrectos del sistema~\cite{Kendall2014Systems,ISO247722024Programming,Ghezzi2003Fundamentals}.
						
						BUSCAR
						
					\subsubsection{Representación de números enteros}
						\noindent
						Los enteros suelen representarse en formato binario con un número fijo de bits, lo cual determina rangos y comportamiento ante desbordamiento. En IS, cantidades discretas como conteos, identificadores y estados se apoyan en enteros, por lo que el programador debe elegir tamaños coherentes con el dominio~\cite{Tanenbaum2021Structured,Gaddis2022Starting,Hanly2015Problem}.
						
						Para aprender a programar, los enteros constituyen un terreno idóneo para entrenar validaciones. Definir rangos, evitar conversiones peligrosas y controlar operaciones de incremento y multiplicación fortalece disciplina y reduce defectos previsibles~\cite{ISO247722024Programming,Ghezzi2003Fundamentals,Pressman2019Software}.
						
						El desbordamiento enseña un principio útil: la corrección depende de supuestos explícitos. Cuando el estudiante documenta límites y aplica verificaciones antes de operar, mejora robustez del programa y preserva integridad de resultados~\cite{Sommerville2015Software,Hanly2015Problem,ISO247722024Programming}.
						
						Dentro de este panorama, el uso de enteros se conecta con estructuras de datos. Índices, tamaños de arreglos y conteos de iteraciones dependen de enteros; un error en este nivel altera recorridos y acceso a memoria, generando fallos difíciles de depurar~\cite{Wirth1976Algorithms,Sedgewick2011Algorithms,Gaddis2022Starting}.
						
						De manera complementaria, los enteros se usan en codificación de estados y máscaras. Esta práctica integra lógica, representación y control, proporcionando ejercicios motivadores para aprender operadores bit a bit con significado organizacional~\cite{Manzano2017Programacion,Wirth1976Algorithms,Laudon2020Management}.
						
					\subsubsection{Representación de números reales}
						\noindent
						Los números reales se representan habitualmente mediante punto flotante, siguiendo estándares que definen signo, exponente y mantisa. Esta representación ofrece rango amplio, aunque introduce aproximaciones y errores de redondeo que el programador debe anticipar~\cite{IEEE2019Standard754,Goldberg1991What,Tanenbaum2021Structured}.
						
						En IS, el impacto aparece en cálculos financieros, promedios y métricas de rendimiento. Comparaciones directas entre reales pueden fallar por diferencias mínimas de representación; por ello, resulta aconsejable entrenar criterios de tolerancia, redondeo controlado y pruebas con casos límite~\cite{Goldberg1991What,IEEE2019Standard754,Chapra2014Numerical}.
						
						Aprender a programar con estos criterios forma un hábito técnico valioso: evaluar qué tipo numérico se ajusta al problema. En dominios sensibles, el uso de enteros escalados o representaciones decimales controladas reduce ambigüedad y mejora consistencia de resultados~\cite{Chapra2014Numerical,Hanly2015Problem,Pressman2019Software}.
						
						No obstante, la selección de representación exige coherencia con almacenamiento y salida. Un valor que se calcula con punto flotante puede mostrarse redondeado para usuario y guardarse con otra precisión; el estudiante debe documentar y alinear estas decisiones para evitar discrepancias entre reporte y persistencia~\cite{Laudon2020Management,Date2019Database,Elmasri2016Database}.
						
						En contraste con el tratamiento de enteros, el punto flotante obliga a pensar en error numérico. Esta práctica fortalece criterio científico-técnico y promueve pruebas que evalúen estabilidad del resultado, no únicamente ejecución del programa~\cite{Goldberg1991What,IEEE2019Standard754,Ghezzi2003Fundamentals}.
						
					\subsubsection{Representación de imágenes, audio y video}
						\noindent
						Los contenidos multimedia se almacenan como secuencias de bytes que siguen formatos con cabeceras, metadatos y reglas de decodificación. En IS, estos contenidos aparecen en gestión documental, evidencia digital, sistemas educativos y registros audiovisuales asociados a procesos~\cite{Laudon2020Management,Tanenbaum2021Structured,Silberschatz2018Operating}.
						
						Para el aprendizaje, los formatos multimedia permiten introducir el concepto de “estructura dentro del archivo”. Leer una cabecera, verificar un identificador de formato y calcular tamaños de bloques enseña programación orientada a especificaciones, con validaciones precisas~\cite{Hanly2015Problem,Gaddis2022Starting,ISO247722024Programming}.
						
						La compresión constituye otro punto formativo. Aunque el diseño de códecs es avanzado, reconocer que compresión implica transformar datos para reducir tamaño sin perder propiedades relevantes aporta criterio para elegir formatos en sistemas organizacionales~\cite{Tanenbaum2021Structured,Laudon2020Management,Sommerville2015Software}.
						
						Destacando el vínculo con integridad, un archivo multimedia corrupto puede ser ilegible o inducir fallas de procesamiento. Validar longitudes, controlar lecturas y verificar condiciones de consistencia se alinea con prácticas de robustez que deben entrenarse desde programación básica~\cite{ISO247722024Programming,Ghezzi2003Fundamentals,Pressman2019Software}.
						
					\subsubsection{Representación temporal: fechas, horas y zonas}
						\noindent
						Los SI dependen de tiempo para auditoría, secuenciación de eventos y análisis histórico. Representar fechas y horas exige definir convenciones: zona horaria, formato, precisión y reglas de calendario, dado que discrepancias temporales afectan reportes y control de procesos~\cite{Laudon2020Management,Kendall2014Systems,Date2019Database}.
						
						En programación, el tiempo se expresa mediante tipos específicos o marcas numéricas. Esta representación obliga a manejar conversiones, comparaciones y cálculos de duración, aportando ejercicios ricos para reforzar estructuras de control y validación~\cite{Gaddis2022Starting,Hanly2015Problem,Wirth1976Algorithms}.
						
						La consistencia temporal requiere validar entradas. Formatos ambiguos, fechas inexistentes o diferencias de zona introducen fallos sutiles; por ello, se recomienda diseñar rutinas de parseo y normalización con pruebas que cubran casos límite~\cite{ISO247722024Programming,Pressman2019Software,Hanly2015Problem}.
						
						De manera complementaria, la representación temporal se vincula con almacenamiento y consulta. Índices por fecha, filtros por período y agregaciones temporales requieren coherencia entre formato persistido y formato de presentación, lo cual fortalece disciplina de diseño~\cite{Elmasri2016Database,Silberschatz2020Database,Laudon2020Management}.
						
				\subsection{Riesgos de representación y prácticas de programación robusta}
					\noindent
					La representación digital ofrece potencia, aunque introduce riesgos previsibles cuando se programa sin criterios: desbordamientos, pérdidas de precisión, incompatibilidades de codificación y discrepancias de interpretación entre componentes. En SI, estos riesgos afectan integridad, trazabilidad y confianza del usuario en resultados~\cite{ISO247722024Programming,Ghezzi2003Fundamentals,Laudon2020Management}.
					
					Desde la formación, tratar estos riesgos aporta un beneficio directo: el estudiante aprende a programar con pruebas, validaciones y documentación de supuestos. Este marco garantista mejora capacidad de depuración y fortalece calidad del código desde etapas iniciales~\cite{Pressman2019Software,Sommerville2015Software,Gaddis2022Starting}.
					
					El diseño robusto también requiere reconocer que un SI integra múltiples tecnologías. Datos pueden circular entre aplicaciones, bases de datos y dispositivos; una representación válida en un componente puede fallar en otro si no existe alineación de formatos, rangos y codificaciones~\cite{Kendall2014Systems,Silberschatz2018Operating,Elmasri2016Database}.
					
					No obstante, la robustez no se limita a prevención de fallos. Programar con representaciones explícitas facilita mantenimiento: reglas bien documentadas y conversiones centralizadas reducen cambios dispersos y disminuyen defectos al evolucionar el sistema~\cite{Ghezzi2003Fundamentals,Sommerville2015Software,Martin2008Clean}.
					
					Este bloque se ha consolidado como una guía práctica para el lector: elegir tipos con criterio, validar entradas, controlar conversiones y probar casos límite. Tales prácticas acompañan a quien aprende a programar en problemas académicos y en escenarios organizacionales~\cite{Hanly2015Problem,Gaddis2022Starting,ISO247722024Programming}.
					
					\subsubsection{Desbordamiento, subdesbordamiento y rangos}
						\noindent
						El desbordamiento aparece cuando una operación excede el rango representable por un tipo. En enteros, puede producir valores inesperados; en punto flotante, puede generar infinitos o subdesbordamientos hacia cero. En IS, estos efectos alteran métricas, cálculos acumulativos y validaciones de reglas~\cite{Tanenbaum2021Structured,ISO247722024Programming,Gaddis2022Starting}.
						
						Para aprender a programar, este riesgo enseña a definir precondiciones. Verificar rangos antes de operar, usar tipos adecuados y registrar errores cuando un valor se sale del dominio fortalece el hábito de programar con contratos explícitos~\cite{Hanly2015Problem,Pressman2019Software,Ghezzi2003Fundamentals}.
						
						El tratamiento riguroso incluye pruebas. Diseñar casos en los límites del rango y observar comportamiento permite al estudiante indagar fallas que, de otro modo, se manifestarían en producción como inconsistencias difíciles de atribuir~\cite{Sommerville2015Software,Gaddis2022Starting,ISO247722024Programming}.
						
					\subsubsection{Orden de bytes, alineación y serialización}
						\noindent
						El \textbf{orden de bytes} (endianness) describe cómo se almacenan bytes de un valor multibyte. Sistemas distintos pueden ordenar de manera diferente; sin una serialización explícita, datos intercambiados pueden interpretarse de forma incorrecta~\cite{Tanenbaum2021Structured,Silberschatz2018Operating,Laudon2020Management}.
						
						\paragraph{Ejemplos prácticos de orden de bytes (Endianness).} El orden de bytes determina cómo se almacenan en memoria los bytes que componen un valor multibyte (por ejemplo, enteros de 16, 32 o 64 bits). Existen dos esquemas principales:
						
						\begin{itemize}
							\item \textbf{Big-endian}: el byte más significativo se almacena primero.
							\item \textbf{Little-endian}: el byte menos significativo se almacena primero.
						\end{itemize}
						
						\subparagraph{Ejemplo 1: Entero de 32 bits.} Considérese el valor hexadecimal:
						
						\[
						0x12345678
						\]
						
						Este número está compuesto por 4 bytes:
						
						\[
						12 \quad 34 \quad 56 \quad 78
						\]
						
						\paragraph{Almacenamiento en Big-endian}
						
						\[
						\begin{array}{c c c c }
							\hline
							\text{Dirección 0} & \text{Dirección 1} & \text{Dirección 2} & \text{Dirección 3} \\
							\hline
							12 & 34 & 56 & 78 \\
							\hline
						\end{array}
						\]
						
						\paragraph{Almacenamiento en Little-endian}
						
						\[
						\begin{array}{ c c c c }
							\hline
							\text{Dirección 0} & \text{Dirección 1} & \text{Dirección 2} & \text{Dirección 3} \\
							\hline
							78 & 56 & 34 & 12 \\
							\hline
						\end{array}
						\]
						
						Obsérvese que el valor lógico es el mismo, pero el orden físico en memoria cambia.
						
						%--------------------------------------------------
						
						\subparagraph{Ejemplo 2: Entero de 16 bits.} Valor:
						
						\[
						0x1234
						\]
						
						\paragraph{Big-endian}
						
						\[
						12 \quad 34
						\]
						
						\paragraph{Little-endian}
						
						\[
						34 \quad 12
						\]
						
						Si un sistema little-endian envía estos bytes sin especificar el orden y un sistema big-endian los interpreta directamente, el valor leído sería:
						
						\[
						0x3412
						\]
						
						lo cual representa un número completamente distinto.
						
						%--------------------------------------------------
						
						\subparagraph{Ejemplo 3: Comunicación en redes.} En redes, el estándar TCP/IP define el uso de \textbf{network byte order}, que es big-endian.
						
						Si un procesador Intel (little-endian) envía el número:
						
						\[
						0x12345678
						\]
						
						debe convertirlo antes de transmitirlo.
						
						En lenguaje C, esto se realiza con:
						
						\begin{lstlisting}[language=C]
	uint32_t valor = 0x12345678;
	uint32_t red = htonl(valor); \end{lstlisting}
						
						Si no se realiza esta conversión, el receptor interpretará bytes invertidos.
						
						%--------------------------------------------------
						
						\subparagraph{Ejemplo 4: Archivos binarios. }Supóngase que se guarda en un archivo binario el entero decimal 305419896, que en hexadecimal es:
						
						\[
						0x12345678
						\]
						
						Un sistema little-endian lo almacenará como:
						
						\[
						78\ 56\ 34\ 12
						\]
						
						Si el archivo se abre en un sistema big-endian sin conversión, el valor leído será:
						
						\[
						0x78563412
						\]
						
						equivalente a:
						
						\[
						2018915346_{10}
						\]
						
						Lo que demuestra cómo la ausencia de serialización explícita produce corrupción lógica de datos.
						
						%--------------------------------------------------
						
						\subparagraph{Ejemplo 5: Caso con UTF-16.} El carácter Unicode:
						
						\[
						U+00F1
						\]
						
						En UTF-16:
						
						\paragraph{Big-endian}
						
						\[
						00\ F1
						\]
						
						\paragraph{Little-endian}
						
						\[
						F1\ 00
						\]
						
						Para indicar el orden, algunos archivos incluyen un \textbf{BOM (Byte Order Mark)}:
						
						\[
						\text{FE FF} \quad (\text{Big-endian})
						\]
						\[
						\text{FF FE} \quad (\text{Little-endian})
						\]
						
						%--------------------------------------------------
						
						\subparagraph{Conclusión técnica.} El problema del endianness no altera el valor abstracto, sino su representación física. Cuando se intercambian datos entre sistemas heterogéneos (arquitecturas x86, ARM, sistemas de red, almacenamiento binario), es imprescindible:
						
						\begin{itemize}
							\item Definir un orden estándar (ej. network byte order).
							\item Utilizar funciones de conversión.
							\item Especificar el formato de serialización.
						\end{itemize}
						
						\noindent
						En programación, la \textbf{serialización} traduce estructuras en secuencias de bytes para almacenamiento o transmisión. Implementarla enseña a definir formatos, incluir longitudes y validar consistencia, lo que fortalece habilidades de diseño orientadas a especificación~\cite{Hanly2015Problem,Gaddis2022Starting,ISO247722024Programming}.
						
						\paragraph{Ejemplos prácticos de serialización}
						
						En programación, la \textbf{serialización} consiste en transformar una estructura de datos en una secuencia ordenada de bytes para su almacenamiento o transmisión. 
						
						Diseñar un formato de serialización implica definir explícitamente:
						
						\begin{itemize}
							\item El orden de los campos.
							\item El tamaño en bytes de cada campo.
							\item El orden de bytes (endianness).
							\item La inclusión de longitudes para datos variables.
							\item Mecanismos de validación (checksum, versión, delimitadores).
						\end{itemize}
						
						\subparagraph{Ejemplo 1: Serialización binaria simple.} Supóngase la siguiente estructura:
						
						\begin{lstlisting}[language=C]
	struct Persona {
		uint32_t id;
		uint8_t edad;
	}; \end{lstlisting}
						
						Si:
						
						\[
						id = 1000_{10} = 0x000003E8
						\]
						\[
						edad = 25_{10} = 0x19
						\]
						
						\paragraph{Formato definido (big-endian):}
						
						\begin{itemize}
							\item id: 4 bytes
							\item edad: 1 byte
						\end{itemize}
						
						\paragraph{Secuencia serializada:}
						
						\[
						00\ 00\ 03\ E8\ 19
						\]
						
						\paragraph{Explicación.} El diseño es explícito: siempre se esperan 5 bytes.  
						Si se reciben menos, el mensaje es inválido.
						
						\subparagraph{Ejemplo 2: Inclusión de longitud en cadenas.} Supóngase:
						
						\begin{lstlisting}[language=C]
	struct Usuario {
		uint16_t longitudNombre;
		char nombre[];
	}; \end{lstlisting}
						
						Si el nombre es:
						
						\[
						"ANA"
						\]
						
						En ASCII:
						
						\[
						41\ 4E\ 41
						\]
						
						\paragraph{Serialización}
						
						\[
						00\ 03\ 41\ 4E\ 41
						\]
						
						\paragraph{Interpretación}
						
						\begin{itemize}
							\item 00 03 indica que vienen 3 bytes.
							\item Luego se leen exactamente 3 bytes.
						\end{itemize}
						
						Este mecanismo evita ambigüedades y permite validar consistencia.
						
						\subparagraph{Ejemplo 3: Error por ausencia de longitud.} Si solo se transmitiera:
						
						\[
						41\ 4E\ 41
						\]
						
						El receptor no sabría:
						
						\begin{itemize}
							\item Cuándo termina el nombre.
							\item Si vienen más campos después.
							\item Si los datos están incompletos.
						\end{itemize}
						
						Esto demuestra la importancia de definir especificaciones formales.
						
						\subparagraph{Ejemplo 4: Serialización con versión y checksum.} Formato definido:
						
						\begin{itemize}
							\item 1 byte: versión
							\item 4 bytes: id
							\item 1 byte: edad
							\item 1 byte: checksum (suma módulo 256)
						\end{itemize}
						
						Datos:
						
						\[
						versión = 01
						\]
						\[
						id = 00\ 00\ 03\ E8
						\]
						\[
						edad = 19
						\]
						
						Suma de bytes:
						
						\[
						01 + 00 + 00 + 03 + E8 + 19
						\]
						
						Checksum:
						
						\[
						(01 + 00 + 00 + 03 + E8 + 19) \bmod 256 = F3
						\]
						
						Mensaje final:
						
						\[
						01\ 00\ 00\ 03\ E8\ 19\ F3
						\]
						
						Si el receptor calcula un checksum distinto, el mensaje se descarta.
						
						\subparagraph{Ejemplo 5: Serialización en formato textual (JSON).} Estructura:
						
						\begin{lstlisting}
	{
		"id": 1000,
		"edad": 25
	} \end{lstlisting}
						
						\paragraph{Ventaja}
						
						\begin{itemize}
							\item Legible por humanos.
							\item Independiente de endianness.
						\end{itemize}
						
						\paragraph{Desventaja}
						
						\begin{itemize}
							\item Mayor tamaño.
							\item Requiere análisis sintáctico.
						\end{itemize}
						
						\subparagraph{Ejemplo 6: Problema de endianness.} Si un sistema little-endian serializa:
						
						\[
						0x12345678
						\]
						
						como:
						
						\[
						78\ 56\ 34\ 12
						\]
						
						y otro sistema asume big-endian, interpretará:
						
						\[
						0x78563412
						\]
						
						lo cual altera completamente el valor.
						
						Por ello, las especificaciones deben definir:
						
						\begin{itemize}
							\item Orden de bytes.
							\item Tamaño fijo de campos.
							\item Convenciones de codificación.
						\end{itemize}
						
						\subparagraph{Conclusión conceptual.} Implementar serialización enseña:
						
						\begin{itemize}
							\item Pensamiento estructural.
							\item Definición formal de formatos.
							\item Control de tamaño y memoria.
							\item Validación de integridad.
							\item Diseño orientado a especificación.
						\end{itemize}
						
						Estos principios son fundamentales en sistemas distribuidos, redes, bases de datos y arquitecturas IoT.
						
						La \textbf{alineación de datos en memoria} también influye en desempeño y corrección cuando se trabaja cerca del hardware. Aunque muchos lenguajes abstraen esta complejidad, reconocer su existencia prepara al lector para interpretar fallos y optimizar estructuras en escenarios avanzados~\cite{Tanenbaum2021Structured,Sebesta2018Concepts,Silberschatz2018Operating}.
						
						\paragraph{Ejemplos prácticos de alineación de datos en memoria.}
						La \textbf{alineación} (alignment) describe la relación entre la dirección de memoria donde comienza un dato y el tamaño natural de acceso que la arquitectura utiliza para leerlo o escribirlo. En términos operativos, un dato de 4 bytes suele considerarse \emph{alineado} si su dirección es múltiplo de 4; un dato de 8 bytes, si su dirección es múltiplo de 8. Esta regla surge de la forma en que la CPU y el subsistema de memoria transfieren información en bloques, y su incumplimiento puede introducir penalizaciones de desempeño o, en algunas arquitecturas, fallos de acceso \cite{Tanenbaum2021Structured,Silberschatz2018Operating,Sebesta2018Concepts}.
						
						\subparagraph{Ejemplo 1: Alineación básica por múltiplos (16, 32 y 64 bits).}
						\textbf{Objetivo del ejemplo:} identificar cuándo una dirección es alineada para distintos tamaños de palabra y por qué importa al leer datos multibyte \cite{Tanenbaum2021Structured,Silberschatz2018Operating}.
						
						Supóngase un bloque de memoria donde se almacenan bytes en direcciones consecutivas:
						
						\[
						\begin{array}{ c c c c c c c c c }
							\hline
							\text{Dir} & 1000 & 1001 & 1002 & 1003 & 1004 & 1005 & 1006 & 1007 \\
							\hline
							\text{Byte} & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot & \cdot \\
							\hline
						\end{array}
						\]
						\begin{itemize}
							\renewcommand{\labelitemi}{}
							\renewcommand{\labelitemii}{}
							\renewcommand{\labelitemiii}{}
							\renewcommand{\labelitemiv}{}
							
							\item \textbf{Paso 1:} considerar un entero de 32 bits (4 bytes). Si empieza en 1000, ocupa 1000--1003. Como $1000 \bmod 4 = 0$, el entero está alineado a 4 bytes.
						
							\item \textbf{Paso 2:} si el mismo entero empieza en 1001, ocupa 1001--1004. Como $1001 \bmod 4 \neq 0$, el entero está \emph{desalineado}.
						
							\item \textbf{Paso 3:} para un entero de 64 bits (8 bytes), la dirección inicial debería cumplir $dir \bmod 8 = 0$. En el ejemplo, 1000 no es múltiplo de 8, por lo que un valor de 8 bytes comenzando en 1000 ya sería desalineado.
						\end{itemize}
						
						\AcadBubble{Observación adicional}{
							Aun cuando una CPU permita accesos desalineados, puede requerir lecturas internas adicionales y reensamblado, introduciendo latencias \cite{Tanenbaum2021Structured,Silberschatz2018Operating}.
						}
						%------------------------------------------------
						
						\subparagraph{Ejemplo 2: Estructuras y relleno (padding) automático}
						
						\noindent
						\textbf{Problema a resolver:} explicar por qué una estructura ocupa más bytes de lo esperado cuando el compilador inserta relleno para mantener alineación \cite{Sebesta2018Concepts,Tanenbaum2021Structured}.
						
						\noindent
						Considérese la estructura:
						
						\begin{lstlisting}[language=C,caption={Estructura con posibles bytes de relleno},label={lst:struct_padding}]
	typedef struct {
		char  c;   // 1 byte
		int   i;   // 4 bytes
		char  d;   // 1 byte
	} Registro; \end{lstlisting}
						
						\begin{itemize}
							\renewcommand{\labelitemi}{}
							\renewcommand{\labelitemii}{}
							\renewcommand{\labelitemiii}{}
							\renewcommand{\labelitemiv}{}
							
							\item \textbf{Paso 1:} $c$ ocupa 1 byte. Si la estructura inicia en una dirección múltiplo de 4, después de $c$ el siguiente byte queda en una dirección que normalmente no es múltiplo de 4.
						
							\item \textbf{Paso 2:} para que $i$ (4 bytes) comience en una dirección múltiplo de 4, el compilador inserta \textbf{3 bytes de relleno} tras $c$.
							
							\item \textbf{Paso 3:} $i$ ocupa 4 bytes. Luego $d$ ocupa 1 byte.
						
							\item \textbf{Paso 4:} para que el tamaño total sea múltiplo del mayor alineamiento del bloque (usualmente 4 en este caso), el compilador puede insertar relleno final (por ejemplo, 3 bytes) tras $d$.
							
							\item \textbf{Resultado típico:} la estructura puede ocupar 12 bytes:
							\[
							1\ (\text{c}) + 3\ (\text{padding}) + 4\ (\text{i}) + 1\ (\text{d}) + 3\ (\text{padding}) = 12
							\]
						\end{itemize}
						\AcadBubble{Observación adicional} 
						{
							Este relleno mejora el desempeño porque evita accesos desalineados repetidos cuando se procesan arreglos de estructuras \cite{Tanenbaum2021Structured,Silberschatz2018Operating}.
						}
						%------------------------------------------------
						
						\subparagraph{Ejemplo 3: Reordenamiento de campos para optimizar tamaño}
						
						\noindent
						\textbf{Problema a resolver:} reducir el tamaño de una estructura sin perder información, aplicando un criterio de diseño que también se aprende al programar con disciplina: ordenar campos por tamaño decreciente \cite{Sebesta2018Concepts,Silberschatz2018Operating}.
						A partir de \ref{lst:struct_padding}, se propone:
						
						\begin{lstlisting}[language=C,caption={Estructura reordenada para disminuir padding},label={lst:struct_reorder}]
	typedef struct {
		int   i;   // 4 bytes
		char  c;   // 1 byte
		char  d;   // 1 byte
	} RegistroOpt; \end{lstlisting}
						
						\begin{itemize}
							\renewcommand{\labelitemi}{}
							\renewcommand{\labelitemii}{}
							\renewcommand{\labelitemiii}{}
							\renewcommand{\labelitemiv}{}
							
							\item \textbf{Paso 1:} $i$ comienza alineado (múltiplo de 4).
							
							\item \textbf{Paso 2:} $c$ y $d$ se ubican después; al agrupar bytes pequeños al final, se reduce el relleno intermedio.
						
							\item \textbf{Resultado típico:} el tamaño baja, por ejemplo, a 8 bytes:
							\[
							4\ (\text{i}) + 1\ (\text{c}) + 1\ (\text{d}) + 2\ (\text{padding final}) = 8
							\]
						\end{itemize}
						
						\AcadBubble{Observación adicional}
						{
							En arreglos grandes, esta reducción disminuye consumo de memoria y mejora localidad de caché, lo que se traduce en operaciones más eficientes \cite{Tanenbaum2021Structured,Silberschatz2018Operating}.
						}
						%------------------------------------------------

						\subparagraph{Ejemplo 4: Corrección al leer bytes como enteros (acceso desalineado)}
						
						\noindent
						\textbf{Problema a resolver:} mostrar cómo un acceso desalineado puede ser incorrecto o fallar según la arquitectura, y cuál es el patrón de solución profesional \cite{Tanenbaum2021Structured,Silberschatz2018Operating}.
						
						Supóngase un arreglo de bytes que representa un encabezado binario de red/archivo:
						
						\begin{lstlisting}[language=C,caption={Lectura riesgosa por conversión directa de puntero},label={lst:unalignedBad}]
	uint8_t buf[] = {0x01, 0x02, 0x03, 0x04, 0xFF, 0xEE};
	uint32_t *p = (uint32_t*)&buf[1]; // comienza en dirección no múltiplo de 4
	uint32_t x = *p;                  // acceso potencialmente desalineado \end{lstlisting}
						
						\begin{itemize}
							\renewcommand{\labelitemi}{}
							\renewcommand{\labelitemii}{}
							\renewcommand{\labelitemiii}{}
							\renewcommand{\labelitemiv}{}
							
							\item \textbf{Paso 1:} \texttt{\&buf[1]} no garantiza alineación a 4 bytes.
						
							\item \textbf{Paso 2:} el acceso \texttt{*p} puede:
							\begin{itemize}
								\item funcionar con penalización (CPU que soporta unaligned),
								\item generar excepción/fallo (CPU/ABI que no lo permite),
								\item producir resultados no portables (según compilador/optimización).
							\end{itemize}
							
							\item \textbf{Solución directa y portable:} copiar bytes con \texttt{memcpy} a una variable alineada y luego interpretar.
						\end{itemize}
						
						\begin{lstlisting}[language=C,caption={Lectura segura usando memcpy},label={lst:unalignedGood}]
	uint32_t x;
	memcpy(&x, &buf[1], sizeof(uint32_t)); // copia a variable alineada \end{lstlisting}
						
						\noindent
						
						\AcadBubble{Observación adicional} {
							Esta práctica introduce una disciplina útil: separar representación en bytes de la representación como tipos, lo que prepara al lector para depuración en redes, archivos binarios y serialización \cite{Silberschatz2018Operating,Tanenbaum2021Structured}.
						}
						%------------------------------------------------
						
						\subparagraph{Ejemplo 5: Alineación y desempeño en arreglos (localidad y caché)}
						
						\textbf{Problema a resolver:} explicar por qué estructuras más compactas mejoran iteraciones y reducen fallos de caché, conectando el concepto con desempeño observable \cite{Tanenbaum2021Structured,Silberschatz2018Operating}.
						
						\noindent
						Considérese un arreglo con un millón de registros. Si cada registro ocupa 12 bytes, el conjunto total consume más memoria que si ocupa 8. Al recorrer el arreglo secuencialmente, se cargan líneas de caché (por ejemplo, 64 bytes) que contienen menos registros cuando cada uno es más grande.
						
						\begin{itemize}
							\renewcommand{\labelitemi}{}
							\renewcommand{\labelitemii}{}
							\renewcommand{\labelitemiii}{}
							\renewcommand{\labelitemiv}{}
							
							\item \textbf{Paso 1:} estructura grande $\Rightarrow$ menos elementos por línea de caché.
							
							\item \textbf{Paso 2:} menos elementos por línea $\Rightarrow$ más lecturas desde memoria principal.
							
							\item \textbf{Paso 3:} más lecturas $\Rightarrow$ mayor latencia acumulada.
						\end{itemize}
						
						\AcadBubble{Observación adicional}{
							Aunque esta optimización no se exige en ejercicios iniciales, reconocer el fenómeno permite interpretar por qué un programa ``equivalente'' puede rendir distinto tras un cambio de estructura o compilador \cite{Silberschatz2018Operating,Tanenbaum2021Structured,Sebesta2018Concepts}.
						}
						%------------------------------------------------
						
						\subparagraph{Cierre pedagógico}
						
						La alineación y el relleno no se introducen para complicar el aprendizaje, sino para fortalecer una habilidad valiosa: razonar sobre cómo una abstracción (tipos y estructuras) se materializa en memoria. Esta visión orienta mejores decisiones al diseñar formatos binarios, estructuras de datos y módulos de serialización, y facilita diagnosticar fallos que aparecen únicamente en ciertos equipos o arquitecturas \cite{Tanenbaum2021Structured,Sebesta2018Concepts,Silberschatz2018Operating}.
						
						De manera complementaria, un formato de serialización bien definido mejora mantenibilidad. Centralizar conversiones reduce duplicación y facilita evolución de estructuras sin romper compatibilidad~\cite{Martin2008Clean,Ghezzi2003Fundamentals,Sommerville2015Software}.
						
					\subsubsection{Normalización y consistencia de codificaciones}
						\noindent
						Las codificaciones inconsistentes producen fallos en comparación, búsqueda y validación. Un SI puede almacenar texto con una codificación y recibir entradas con otra; sin normalización, se generan registros duplicados y reglas que fallan por desigualdad de símbolos equivalentes~\cite{Laudon2020Management,ISO247722024Programming,Date2019Database}.
						
						Para el aprendizaje, esta situación refuerza la práctica de normalizar entradas. Recortar espacios, unificar mayúsculas/minúsculas según política y validar caracteres permitidos convierten ejercicios simples en prácticas profesionales aplicables a formularios y registros~\cite{Gaddis2022Starting,Hanly2015Problem,Kendall2014Systems}.
						
						No obstante, normalizar requiere documentar criterios. Una regla de normalización cambia el significado percibido por los usuarios; por ello, se recomienda registrar decisiones y asegurar coherencia entre presentación y almacenamiento~\cite{Ghezzi2003Fundamentals,Sommerville2015Software,Laudon2020Management}.
						
						%====================================================
						\paragraph{Ejemplo 1: Diferencias invisibles en Unicode}
						
						\noindent
						Considérese el nombre:
						
						\[
						José
						\]
						
						Este puede almacenarse de dos formas distintas en Unicode:
						
						\textbf{Forma 1 (precompuesta)}:
						\[
						U+00E9
						\]
						
						\textbf{Forma 2 (descompuesta)}:
						\[
						U+0065\ U+0301
						\]
						
						Visualmente son idénticas, pero a nivel binario son distintas.
						
						\paragraph{Problema práctico}
						
						Si un sistema almacena la forma precompuesta y recibe la forma descompuesta, una comparación directa de bytes devuelve falso.
						
						\paragraph{Solución}
						
						Aplicar normalización Unicode (NFC o NFD) antes de almacenar o comparar.
						
						\paragraph{Ejercicio guiado}
						
						\begin{enumerate}
							\item Recibir dos cadenas visualmente iguales.
							\item Mostrar sus códigos Unicode.
							\item Comparar byte a byte.
							\item Aplicar normalización NFC.
							\item Comparar nuevamente.
							\item Verificar igualdad.
						\end{enumerate}
						
						\noindent
						Este ejercicio enseña que la igualdad visual no implica igualdad binaria.
						
						%====================================================
						\paragraph{Ejemplo 2: Espacios invisibles y registros duplicados}
						
						\noindent
						Entrada A:
						\[
						"ANA"
						\]
						
						Entrada B:
						\[
						"ANA\ "
						\]
						
						La segunda contiene un espacio final.
						
						\paragraph{Problema}
						
						Almacenar ambas entradas genera dos registros distintos.
						
						\paragraph{Solución paso a paso}
						
						\begin{enumerate}
							\item Recortar espacios iniciales y finales.
							\item Validar longitud mínima.
							\item Aplicar política uniforme antes de persistir.
						\end{enumerate}
						
						\paragraph{Ejercicio práctico}
						
						Diseñar una función que:
						
						\begin{itemize}
							\item Elimine espacios laterales.
							\item Convierta a mayúsculas.
							\item Valide que solo contenga letras.
						\end{itemize}
						
						Probar con:
						
						\[
						" ana ",\quad "ANA",\quad "Ana"
						\]
						
						Verificar que todas se almacenen como:
						
						\[
						"ANA"
						\]
						
						%====================================================
						\paragraph{Ejemplo 3: Sensibilidad a mayúsculas y reglas de negocio}
						
						\noindent
						Supóngase un sistema donde:
						
						\[
						"admin" \neq "ADMIN"
						\]
						
						\paragraph{Problema}
						
						En un módulo, la comparación es sensible a mayúsculas; en otro no.
						
						Esto genera:
						
						\begin{itemize}
							\item Inconsistencia en autenticación.
							\item Errores de búsqueda.
							\item Resultados inesperados.
						\end{itemize}
						
						\paragraph{Ejercicio analítico}
						
						\begin{enumerate}
							\item Definir una política: ¿el sistema será case-sensitive?
							\item Documentar la decisión.
							\item Implementar función uniforme.
							\item Probar búsquedas con combinaciones de mayúsculas/minúsculas.
						\end{enumerate}
						
						\noindent
						Este ejercicio conecta decisiones técnicas con impacto organizacional.
						
						%====================================================
						\paragraph{Ejemplo 4: Codificaciones mixtas (UTF-8 vs ISO-8859-1)}
						
						\noindent
						Supóngase que un sistema almacena:
						
						\[
						Señor
						\]
						
						En UTF-8:
						
						\[
						53\ 65\ C3\ B1\ 6F\ 72
						\]
						
						Pero otro módulo interpreta esos bytes como ISO-8859-1, mostrando:
						
						\[
						SeÃ±or
						\]
						
						\paragraph{Problema}
						
						La base de datos ahora contiene valores aparentemente distintos.
						
						\paragraph{Ejercicio diagnóstico}
						
						\begin{enumerate}
							\item Mostrar bytes almacenados.
							\item Interpretar con codificación incorrecta.
							\item Detectar incoherencia.
							\item Forzar conversión explícita a UTF-8.
						\end{enumerate}
						
						\noindent
						Este ejercicio refuerza la importancia de especificar codificación en interfaces.
						
						%====================================================
						\paragraph{Ejemplo 5: Normalización en bases de datos}
						
						\noindent
						Tabla de clientes:
						
						\begin{center}
							\begin{tabular}{|c|c|}
								\hline
								ID & Nombre \\
								\hline
								1 & José \\
								2 & Jose \\
								3 & JOSE \\
								\hline
							\end{tabular}
						\end{center}
						
						\paragraph{Problema}
						
						Búsquedas por nombre devuelven resultados inconsistentes.
						
						\paragraph{Ejercicio de diseño}
						
						\begin{enumerate}
							\item Definir política (conservar acentos o no).
							\item Aplicar transformación antes de insertar.
							\item Crear índice sobre campo normalizado.
							\item Comparar rendimiento y consistencia.
						\end{enumerate}
						
						\noindent
						Este ejercicio integra programación, reglas de negocio y diseño de datos.
						
						%====================================================
						\paragraph{Conclusión pedagógica}
						
						Normalizar no es simplemente “modificar texto”; es definir una política coherente que garantice:
						
						\begin{itemize}
							\item Igualdad semántica.
							\item Integridad de datos.
							\item Coherencia entre módulos.
							\item Comportamiento predecible en comparaciones.
						\end{itemize}
						
						La práctica sistemática de normalización fortalece el pensamiento orientado a especificación y previene errores que, en entornos reales, pueden escalar a fallos operacionales significativos.
						
					\subsubsection{Precisión numérica, redondeo y comparación segura}
					\noindent
						La precisión numérica afecta cualquier indicador calculado a partir de reales. Operaciones repetidas acumulan error de redondeo; comparaciones directas pueden fallar al evaluar igualdad. Estas propiedades son inherentes al punto flotante, por lo que deben tratarse como parte del diseño~\cite{Goldberg1991What,IEEE2019Standard754,Chapra2014Numerical}.
						
						Para aprender a programar, la comparación segura introduce un patrón didáctico: usar tolerancias y verificar magnitud de la diferencia. Este patrón se integra con pruebas y con documentación de supuestos sobre precisión requerida por el dominio~\cite{Hanly2015Problem,Ghezzi2003Fundamentals,Goldberg1991What}.
						
						La elección de estrategia de redondeo también importa. En reportes, un redondeo distinto puede generar discrepancias entre sistemas o entre períodos, afectando confianza en el SI. Un diseño coherente alinea cálculo interno, almacenamiento y presentación~\cite{Laudon2020Management,Date2019Database,IEEE2019Standard754}.
						
						%====================================================
						\paragraph{Ejemplo 1: Representación imperfecta de 0.1}
						
						\noindent
						\textbf{Problema a demostrar:} por qué 0.1 no se representa exactamente en binario.
						
						\[
						0.1_{10} = 0.00011001100110011\ldots_2
						\]
						
						La expansión es infinita periódica, por lo que debe truncarse en memoria (IEEE 754).  
						
						\paragraph{Ejercicio paso a paso}
						
						\begin{enumerate}
							\item Convertir 0.1 a binario mediante multiplicaciones sucesivas.
							\item Observar repetición del patrón 0011.
							\item Explicar que el almacenamiento es aproximado.
							\item Mostrar que:
							\[
							0.1 + 0.2 \neq 0.3
							\]
							\item Calcular:
							\[
							0.1 + 0.2 = 0.30000000000000004
							\]
						\end{enumerate}
						
						\noindent
						Este ejercicio evidencia que la comparación directa puede fallar.
						
						%====================================================
						\paragraph{Ejemplo 2: Comparación insegura}
						
						\noindent
						\textbf{Código conceptual}
						
						\begin{lstlisting}[language=C]
	double a = 0.1 + 0.2;
	if (a == 0.3) {
		printf("Iguales");
	} \end{lstlisting}
						
						\noindent
						\textbf{Resultado esperado:} la condición puede no cumplirse.
						
						\paragraph{Ejercicio correctivo}
						
						\begin{enumerate}
							\item Calcular la diferencia:
							\[
							|a - 0.3|
							\]
							\item Definir tolerancia:
							\[
							\epsilon = 10^{-9}
							\]
							\item Comparar:
							\[
							|a - 0.3| < \epsilon
							\]
							\item Verificar que ahora la condición es verdadera.
						\end{enumerate}
						
						\noindent
						Este patrón introduce el concepto de comparación segura.
						
						%====================================================
						\paragraph{Ejemplo 3: Acumulación de error}
						
						\noindent
						\textbf{Problema a demostrar:} error acumulado en sumas repetidas.
						
						\begin{lstlisting}[language=C]
	double suma = 0.0;
	for (int i = 0; i < 1000; i++) {
		suma += 0.1;
	} \end{lstlisting}
						
						\noindent
						\textbf{Resultado teórico esperado:}
						\[
						100.0
						\]
						
						\noindent
						\textbf{Resultado real aproximado:}
						\[
						99.99999999998
						\]
						
						\paragraph{Ejercicio analítico}
						
						\begin{enumerate}
							\item Explicar que cada suma introduce pequeño error.
							\item Multiplicar error por número de iteraciones.
							\item Relacionar con indicadores financieros o científicos.
						\end{enumerate}
						
						\noindent
						Este ejercicio muestra cómo operaciones repetidas amplifican desviaciones.
						
						%====================================================
						\paragraph{Ejemplo 4: Estrategias de redondeo}
						
						\noindent
						Considérese el valor:
						
						\[
						2.345
						\]
						
						\paragraph{Redondeo tradicional (half-up)}
						
						\[
						2.35
						\]
						
						\paragraph{Redondeo hacia abajo}
						
						\[
						2.34
						\]
						
						\paragraph{Redondeo bancario (half-even)}
						
						\[
						2.34 \quad \text{si el dígito anterior es par}
						\]
						
						\paragraph{Ejercicio práctico}
						
						\begin{enumerate}
							\item Calcular promedio mensual con distintos métodos de redondeo.
							\item Comparar totales anuales.
							\item Analizar discrepancias acumuladas.
						\end{enumerate}
						
						\noindent
						Este ejercicio demuestra que la estrategia de redondeo impacta resultados organizacionales.
						
						%====================================================
						\paragraph{Ejemplo 5: Precisión en almacenamiento y presentación}
						
						\noindent
						Supóngase un sistema financiero:
						
						\[
						\text{Monto real} = 1234.56789
						\]
						
						\paragraph{Almacenamiento interno:}
						double con alta precisión.
						
						\paragraph{Presentación al usuario:}
						2 decimales.
						
						\[
						1234.57
						\]
						
						\paragraph{Ejercicio de coherencia}
						
						\begin{enumerate}
							\item Definir precisión interna.
							\item Definir precisión de almacenamiento en base de datos.
							\item Definir formato de presentación.
							\item Documentar política.
						\end{enumerate}
						
						\noindent
						Este ejercicio integra diseño técnico y confianza organizacional.
						
						%====================================================
						\AcadBubble{Conclusión aplicada}
						{
							La precisión numérica no es un detalle de implementación sino una propiedad estructural del punto flotante.  
							
							Aplicar tolerancias, definir estrategias de redondeo y documentar supuestos convierte ejercicios básicos en prácticas de ingeniería rigurosa. Esta disciplina previene errores invisibles que, en sistemas reales, pueden generar inconsistencias financieras, científicas o administrativas.
						}
					\subsubsection{Integridad de datos: detección de errores y validación cruzada}
					\noindent
						La integridad requiere detectar errores durante captura, transmisión y almacenamiento. Validaciones de formato, verificaciones de longitud y controles cruzados entre campos reducen la probabilidad de registrar información defectuosa~\cite{ISO247722024Programming,Elmasri2016Database,Laudon2020Management}. En programación básica, estas prácticas se implementan mediante funciones de validación y pruebas sistemáticas. El estudiante aprende a separar reglas de negocio de lógica de entrada, lo que mejora legibilidad y facilita mantenimiento~\cite{Martin2008Clean,Gaddis2022Starting,Hanly2015Problem}.
						
						De manera complementaria, la integridad se beneficia de restricciones en almacenamiento: claves, dominios y relaciones preservan coherencia cuando múltiples módulos escriben datos. Esta visión conecta programación con fundamentos de bases de datos~\cite{Silberschatz2020Database,Elmasri2016Database,Date2019Database}. No obstante, la validación cruzada debe diseñarse con criterio para evitar reglas contradictorias. Documentar decisiones y alinear validaciones con el proceso organizacional reduce fricción y fortalece trazabilidad~\cite{Kendall2014Systems,Tegarden2025Systems,Ghezzi2003Fundamentals}.
						
						%====================================================
						\paragraph{Ejemplo 1: Validación de formato}
						
						\noindent
						\textbf{Problema:} capturar una dirección de correo electrónico válida.
						
						\paragraph{Regla de formato}
						Debe contener:
						\begin{itemize}
							\item Un símbolo @
							\item Un dominio posterior
							\item Sin espacios
						\end{itemize}
						
						\paragraph{Ejercicio práctico}
						
						\begin{enumerate}
							\item Solicitar entrada de usuario.
							\item Verificar presencia de @.
							\item Verificar que la longitud sea mayor que 5 caracteres.
							\item Rechazar entradas como:
							\[
							"usuario@",\quad "@dominio.com",\quad "usuario dominio.com"
							\]
						\end{enumerate}
						
						\noindent
						Este ejercicio enseña validación de formato antes de almacenar.
						
						%====================================================
						\paragraph{Ejemplo 2: Verificación de longitud}
						
						\noindent
						\textbf{Problema:} un código de producto debe tener exactamente 8 caracteres.
						
						\paragraph{Ejercicio paso a paso}
						
						\begin{enumerate}
							\item Leer código.
							\item Calcular longitud.
							\item Si longitud $\neq 8$, mostrar error.
							\item Permitir reingreso.
						\end{enumerate}
						
						\noindent
						Esto previene registros incompletos o inconsistentes.
						
						%====================================================
						\paragraph{Ejemplo 3: Validación cruzada entre campos}
						
						\noindent
						\textbf{Problema:} en un sistema académico, un estudiante no puede tener estado ``Graduado'' si créditos aprobados $<$ créditos requeridos.
						
						\paragraph{Ejercicio de control cruzado}
						
						\begin{enumerate}
							\item Leer créditos aprobados.
							\item Leer estado académico.
							\item Si estado = ``Graduado'' y créditos $<$ 240:
							\[
							\text{Error de coherencia}
							\]
							\item Registrar inconsistencia.
						\end{enumerate}
						
						\noindent
						Este ejercicio demuestra que la validación no depende de un solo campo, sino de relaciones entre ellos.
						
						%====================================================
						\paragraph{Ejemplo 4: Separación de reglas de negocio}
						
						\noindent
						\textbf{Problema:} no mezclar validación con lógica principal.
						
						\paragraph{Diseño adecuado}
						
						\begin{itemize}
							\item Función validarEdad(edad)
							\item Función validarCorreo(correo)
							\item Función registrarUsuario()
						\end{itemize}
						
						\paragraph{Ejercicio estructural}
						
						\begin{enumerate}
							\item Crear función validarEdad (18--65).
							\item Crear función validarCorreo.
							\item En programa principal, llamar validaciones.
							\item Si todas son correctas, registrar.
						\end{enumerate}
						
						\noindent
						Esto mejora mantenimiento y claridad del código.
						
						%====================================================
						\paragraph{Ejemplo 5: Restricciones en almacenamiento (Base de datos)}
						
						\noindent
						Supóngase una tabla de clientes:
						
						\begin{center}
							\begin{tabular}{|c|c|}
								\hline
								ID & Email \\
								\hline
							\end{tabular}
						\end{center}
						
						\paragraph{Restricciones necesarias}
						
						\begin{itemize}
							\item ID como clave primaria.
							\item Email como único (UNIQUE).
							\item Dominio restringido (CHECK).
						\end{itemize}
						
						\paragraph{Ejercicio conceptual}
						
						\begin{enumerate}
							\item Intentar insertar dos clientes con mismo email.
							\item Verificar que la base rechaza duplicado.
							\item Explicar por qué la restricción protege integridad.
						\end{enumerate}
						
						\noindent
						Este ejercicio conecta programación con fundamentos de bases de datos.
						
						%====================================================
						\paragraph{Ejemplo 6: Validación contradictoria}
						
						\noindent
						\textbf{Problema:} un módulo exige edad mínima 18, otro módulo acepta desde 16.
						
						\paragraph{Ejercicio de análisis}
						
						\begin{enumerate}
							\item Detectar inconsistencias entre módulos.
							\item Documentar política oficial.
							\item Ajustar validaciones para coherencia.
						\end{enumerate}
						
						\noindent
						Este caso muestra la importancia de alinear reglas con el proceso organizacional.
						
						%====================================================
						\paragraph{Conclusión aplicada}
						
						La integridad de datos no depende de una única validación, sino de un conjunto coherente de controles en múltiples niveles:
						
						\begin{itemize}
							\item Validación de entrada.
							\item Control cruzado.
							\item Restricciones de almacenamiento.
							\item Documentación formal de reglas.
						\end{itemize}
						
						Estos ejercicios transforman conceptos teóricos en prácticas aplicables a sistemas reales, fortaleciendo la capacidad del estudiante para diseñar software robusto y coherente.
						
					\subsubsection{Implicaciones de seguridad en la representación}
					\noindent
						La representación afecta seguridad cuando el programa interpreta entradas sin control, convierte tipos de manera insegura o asume longitudes sin verificarlas. Estas situaciones abren espacio a defectos y ataques basados en entradas maliciosas, incluso en programas sencillos~\cite{ISO247722024Programming,Pressman2019Software,Ghezzi2003Fundamentals}.
						
						Para aprender a programar, la seguridad se entrena como un hábito: validar, limitar, registrar y fallar de manera controlada. Esta práctica fortalece robustez y alinea el desarrollo con estándares que catalogan vulnerabilidades comunes y recomiendan mitigaciones~\cite{ISO247722024Programming,Sommerville2015Software,Hanly2015Problem}.
						
						El tratamiento de archivos y de formatos constituye un caso ilustrativo. Leer longitudes sin verificar o procesar cabeceras sin validar puede conducir a lecturas fuera de rango o a corrupción de memoria en lenguajes que exponen esos riesgos. La disciplina de validación reduce probabilidad de fallas~\cite{Silberschatz2018Operating,Tanenbaum2021Structured,ISO247722024Programming}.
						
						En síntesis, la seguridad vinculada a representación invita al lector a programar con criterio profesional desde el inicio. La inversión en validación y pruebas produce sistemas más estables, facilita mantenimiento y fortalece confianza en resultados del SI~\cite{Pressman2019Software,Ghezzi2003Fundamentals,Laudon2020Management}.
						
						%====================================================
						\paragraph{Ejemplo 1: Conversión insegura de tipos}
						
						\noindent
						\textbf{Problema:} convertir entrada de usuario directamente a entero sin validar.
						
						\begin{lstlisting}[language=C]
	char entrada[10];
	scanf("%s", entrada);
	int valor = atoi(entrada); \end{lstlisting}
						
						\noindent
						Si el usuario ingresa:
						
						\[
						"999999999999"
						\]
						
						Puede producir desbordamiento o comportamiento indefinido.
						
						\paragraph{Ejercicio correctivo}
						
						\begin{enumerate}
							\item Verificar que la entrada contenga solo dígitos.
							\item Validar longitud máxima.
							\item Usar función segura (por ejemplo, \texttt{strtol}).
							\item Comprobar rango antes de asignar.
						\end{enumerate}
						
						\noindent
						Este ejercicio demuestra que convertir tipos sin control abre vulnerabilidades.
						
						%====================================================
						\paragraph{Ejemplo 2: Desbordamiento por asumir longitud}
						
						\noindent
						\textbf{Problema:} copiar cadena sin verificar tamaño.
						
						\begin{lstlisting}[language=C]
	char destino[8];
	strcpy(destino, entrada); \end{lstlisting}
						
						\noindent
						Si \texttt{entrada} contiene más de 7 caracteres, se produce sobrescritura de memoria.
						
						\paragraph{Ejercicio preventivo}
						
						\begin{enumerate}
							\item Medir longitud antes de copiar.
							\item Usar \texttt{strncpy}.
							\item Limitar tamaño máximo permitido.
							\item Registrar intento inválido.
						\end{enumerate}
						
						\noindent
						Este caso ilustra cómo la representación incorrecta puede derivar en corrupción de memoria.
						
						%====================================================
						\paragraph{Ejemplo 3: Lectura insegura de archivo binario}
						
						\noindent
						Supóngase un archivo cuyo encabezado contiene un campo de longitud:
						
						\begin{lstlisting}[language=C]
							uint32_t longitud;
							fread(&longitud, sizeof(uint32_t), 1, archivo);
							char buffer[100];
							fread(buffer, 1, longitud, archivo);
						\end{lstlisting}
						
						\noindent
						\textbf{Problema:} si el archivo indica longitud = 5000, se intenta leer más allá del tamaño del buffer.
						
						\paragraph{Ejercicio de validación}
						
						\begin{enumerate}
							\item Verificar que longitud $\leq$ tamaño del buffer.
							\item Validar que longitud sea coherente con tamaño real del archivo.
							\item Rechazar archivo si condición falla.
						\end{enumerate}
						
						\noindent
						Este ejercicio conecta representación binaria con riesgo de explotación.
						
						%====================================================
						\paragraph{Ejemplo 4: Interpretación incorrecta de formato}
						
						\noindent
						\textbf{Problema:} asumir que todos los datos están en UTF-8.
						
						Un atacante envía datos con codificación distinta, provocando interpretación errónea o bypass de filtros.
						
						\paragraph{Ejercicio de mitigación}
						
						\begin{enumerate}
							\item Detectar codificación.
							\item Convertir explícitamente a formato interno estándar.
							\item Validar caracteres permitidos.
						\end{enumerate}
						
						\noindent
						Este ejercicio demuestra que la representación textual también impacta seguridad.
						
						%====================================================
						\paragraph{Ejemplo 5: Validación cruzada en autenticación}
						
						\noindent
						\textbf{Problema:} aceptar credenciales sin validar coherencia entre usuario y rol.
						
						\paragraph{Escenario}
						
						Usuario: \texttt{"admin"}  
						Rol: \texttt{"usuario"}
						
						\paragraph{Ejercicio}
						
						\begin{enumerate}
							\item Validar que el rol asignado corresponda al perfil almacenado.
							\item Registrar intento inconsistente.
							\item Rechazar operación.
						\end{enumerate}
						
						\noindent
						Este caso muestra que la seguridad no depende solo del formato, sino de la coherencia semántica.
						
						%====================================================
						\paragraph{Ejemplo 6: Fallo controlado}
						
						\noindent
						\textbf{Problema:} programa termina abruptamente ante error de entrada.
						
						\paragraph{Ejercicio de diseño robusto}
						
						\begin{enumerate}
							\item Detectar entrada inválida.
							\item Mostrar mensaje claro.
							\item Registrar evento.
							\item Permitir reintento.
						\end{enumerate}
						
						\noindent
						Fallar de manera controlada reduce impacto y mejora experiencia de usuario.
						
						%====================================================
						\AcadBubble{Conclusión aplicada}
						{
							La representación no es neutra: afecta memoria, interpretación, seguridad y confiabilidad.  
							
							Los ejercicios anteriores muestran que validar longitudes, tipos y coherencia semántica transforma programas simples en sistemas robustos. La disciplina de validar antes de procesar constituye una práctica profesional que previene defectos y mitiga vulnerabilidades desde etapas tempranas del desarrollo.
						}
	
			\section{Formulación del problema informacional}
			\noindent
				La formulación del problema informacional establece la relación explícita entre una necesidad organizacional y una solución programable. En Ingeniería en Sistemas de Información, el software se concibe como un artefacto socio-técnico: integra procesos, datos y reglas operativas para producir resultados verificables que apoyan coordinación, control y toma de decisiones. Por ello, el problema informacional se define como la especificación de \emph{qué} hechos del negocio deben registrarse, \emph{bajo qué} reglas deben transformarse y \emph{cómo} se presentan sus resultados con utilidad operativa y gerencial \cite{Laudon2020Management,Kendall2014Systems,Sommerville2015Software}.
				
				En formación inicial, esta actividad orienta el aprendizaje hacia programación con propósito. Cuando el estudiante parte de un enunciado organizacional y lo traduce a entradas, procesos y salidas, adquiere un criterio de diseño que trasciende la sintaxis: decide estructuras de datos por significado, elabora validaciones por política y delimita responsabilidades del programa por función. Esta práctica enlaza pensamiento algorítmico con análisis y diseño de sistemas, facilitando que el código refleje de manera rastreable el comportamiento esperado del proceso que representa \cite{Pressman2019Software,SWEBOK2014}.
				
				Una formulación rigurosa también fortalece verificabilidad. Estándares de ingeniería de requisitos insisten en claridad, ausencia de ambigüedad, trazabilidad y posibilidad de prueba; estos atributos permiten derivar casos de prueba, criterios de aceptación y evidencia de cumplimiento. Incluso en ejercicios básicos, adoptar esta disciplina reduce errores de interpretación, mejora la consistencia de soluciones y proporciona un marco estable para iterar sin perder control sobre el alcance \cite{ISO29148,IEEE12207}.
				
				Desde la perspectiva de construcción del programa, formular el problema equivale a definir un contrato operativo: qué condiciones deben cumplir las entradas, qué transformaciones deben ejecutarse y qué salidas deben producirse con formato y significado precisos. De manera complementaria, esta formalización delimita estados del sistema y escenarios de error (datos faltantes, formatos inválidos, combinaciones inconsistentes), lo que conduce a programas más robustos, más fáciles de probar y con depuración más directa, porque cada fallo puede asociarse a un punto de la especificación \cite{Gaddis2022Starting,Hanly2015Problem,Wirth1976Algorithms}.
				
				En Sistemas de Información Transaccionales (\textit{Transactional Information Systems} TIS), la formulación incorpora propiedades que condicionan la programación desde el inicio. Cada operación relevante se expresa como transacción que modifica datos persistentes y, por tanto, debe preservar integridad y consistencia entre registros bajo uso concurrente. Este requisito obliga a especificar validaciones cruzadas, reglas de unicidad, relaciones entre entidades y comportamiento ante fallos parciales, conectando programación con fundamentos de bases de datos y control de errores. Dentro de este panorama, la formulación del problema informacional se consolida como una guía para implementar transacciones correctas y auditables, coherentes con reglas de negocio y con la estructura del almacenamiento \cite{Silberschatz2020Database,Elmasri2016Database,Date2019Database}.
				
				\subsection{Entradas del sistema}
				\noindent
					Las entradas del sistema constituyen el punto de contacto entre el entorno organizacional y el modelo computacional que lo representa. En Sistemas de Información en general, toda transacción o proceso depende de datos cuya calidad, formato y consistencia determinan la validez de los resultados posteriores. Por ello, el diseño de las entradas no se limita a la lectura técnica de datos, sino que implica definir reglas de validación, mecanismos de verificación cruzada y estrategias de control que preserven integridad y coherencia desde el momento mismo de la captura \cite{Laudon2020Management,Kendall2014Systems,Sommerville2015Software}. En el contexto formativo, comprender la naturaleza y diversidad de las entradas permite al estudiante anticipar errores, estructurar validaciones y desarrollar programas más robustos y confiables \cite{Gaddis2022Starting,Hanly2015Problem}.
					
					\subsubsection{Ingreso manual de datos (formularios e interfaces gráficas)}
						\noindent
						En entornos transaccionales, el ingreso manual ocurre en puntos de operación como cajas, ventanillas administrativas o módulos académicos. El usuario introduce identificadores, cantidades, fechas o selecciones que deben cumplir restricciones de dominio y formato. Programar este tipo de entrada exige implementar validaciones de obligatoriedad, control de rangos (por ejemplo, cantidades mayores que cero), verificación de formatos (identificaciones, fechas, códigos) y mensajes de retroalimentación claros que faciliten la corrección inmediata \cite{Gaddis2022Starting,Hanly2015Problem,ISO247722024Programming}. Esta práctica refuerza el principio de que la integridad comienza en la interfaz de captura.
						
					\subsubsection{Archivos estructurados (CSV, JSON, XML, TXT)}
					\noindent
						La carga desde archivos se utiliza en procesos por lote, migraciones de datos y conciliaciones contables. Aquí el programa debe validar estructura, número de columnas, tipos de datos, delimitadores y codificación de caracteres antes de incorporar la información al sistema. Además, resulta esencial registrar eventos anómalos (líneas incompletas, campos inválidos) para auditoría y trazabilidad \cite{Pressman2019Software,Elmasri2016Database}. Este medio introduce al estudiante en la lectura secuencial, el manejo de excepciones y la importancia de verificar coherencia antes de persistir datos.
						
					\subsubsection{Bases de datos (consultas y recuperación persistente)}
						\noindent
						En OLTP, muchas entradas no provienen del exterior inmediato, sino del propio almacenamiento persistente. Por ejemplo, registrar una venta requiere consultar la existencia del cliente, verificar disponibilidad de inventario y recuperar precios vigentes. Estas operaciones deben garantizar consistencia referencial y sincronización con el estado actual de los datos \cite{Silberschatz2020Database,Date2019Database,Elmasri2016Database}. Desde la perspectiva pedagógica, este medio enfatiza la diferencia entre datos temporales y datos persistentes, así como la necesidad de validar la existencia y unicidad de registros antes de proceder.
						
					\subsubsection{Consumo de servicios web (APIs e integraciones externas)}
					\noindent
						Las integraciones con sistemas externos —como verificación de identidad, pasarelas de pago o facturación electrónica— representan una fuente crítica de entrada. Programar estas interacciones implica manejar tiempos de espera, respuestas parciales, códigos de estado HTTP, autenticación y validación de esquemas de datos serializados \cite{Fielding2000REST,Pressman2019Software,Sommerville2015Software}. En formación, este medio permite comprender que la estabilidad del sistema depende no solo del código propio, sino también del comportamiento de servicios externos, lo que exige mecanismos de reintento y control de errores.
						
					\subsubsection{Mensajería y colas de eventos}
						\noindent
						En arquitecturas orientadas a eventos, las entradas llegan como notificaciones asincrónicas (por ejemplo, confirmación de pago). En estos casos, el programa debe implementar procesamiento idempotente para evitar duplicidades y garantizar que una transacción no se ejecute más de una vez ante reenvíos del mismo mensaje \cite{ISO247722024Programming,Date2019Database,Sommerville2015Software}. Este enfoque introduce conceptos de concurrencia y control transaccional que amplían la comprensión del estudiante sobre integridad en entornos distribuidos.
						
					\subsubsection{Dispositivos y captura automatizada (lectores, sensores, terminales)}
						\noindent
						Algunos sistemas integran dispositivos físicos como lectores de códigos de barras, balanzas o sensores ambientales. Estas entradas exigen validación de tramas, control de rangos y sincronización inmediata con el flujo transaccional \cite{Tanenbaum2021Structured,Silberschatz2018Operating}. Desde el punto de vista formativo, este medio ilustra la interacción entre hardware y software, y la necesidad de verificar coherencia antes de aceptar datos generados automáticamente.
						
						\AcadBubble{Importante...}
						{
							En conjunto, las entradas del sistema no deben entenderse como simples valores iniciales para un algoritmo, sino como representaciones formales de hechos organizacionales cuya precisión condiciona todo el ciclo de procesamiento. Diseñarlas adecuadamente implica aplicar criterios de validación, consistencia y control que reflejen las políticas del dominio y las restricciones técnicas del entorno. Así, el estudiante aprende que la calidad del resultado depende, en gran medida, de la calidad del dato capturado y validado desde su origen \cite{Laudon2020Management,Pressman2019Software,Silberschatz2020Database}.
						}
						
				\subsection{Salidas esperadas}
					\noindent	
					Las salidas de un Sistema de Información representan la materialización observable del procesamiento realizado sobre los datos de entrada. En los TIS, la salida no se limita a mostrar un resultado, sino que constituye evidencia formal de que una operación fue validada, ejecutada y registrada conforme a reglas organizacionales y restricciones técnicas previamente definidas. Por ello, el diseño de las salidas exige precisión estructural, control de formato y definición explícita del medio de entrega, garantizando consistencia, trazabilidad y protección de la información según el rol del usuario \cite{Laudon2020Management,Pressman2019Software,Sommerville2015Software}.
					
					Desde una perspectiva funcional, una primera categoría corresponde a \textbf{salidas interactivas en pantalla}. Estas incluyen confirmaciones, advertencias y detalles inmediatos de la transacción (por ejemplo, número de comprobante, subtotal, impuestos y total). Su correcta implementación requiere coherencia entre validaciones y mensajes, claridad en la retroalimentación y consistencia semántica con el estado del proceso ejecutado. En el ámbito formativo, este tipo de salida permite al estudiante consolidar la relación entre estructuras condicionales, control de errores y presentación de resultados comprensibles para el usuario final \cite{Gaddis2022Starting,Hanly2015Problem,Kendall2014Systems}.
					
					Una segunda categoría comprende la \textbf{persistencia estructurada de resultados}. En los TIS, la salida principal suele consistir en la escritura consistente de registros en bases de datos: inserción de cabeceras y detalles, actualización de inventarios o generación de bitácoras. Estas salidas son fundamentales para auditoría, trazabilidad histórica y generación posterior de reportes. La implementación exige garantizar integridad referencial, unicidad de identificadores y coherencia transaccional, aspectos que conectan programación con fundamentos de bases de datos y control de concurrencia \cite{Silberschatz2020Database,Elmasri2016Database,Date2019Database}.
					
					Otra forma relevante corresponde a la generación de \textbf{documentos formales}, tales como facturas, tickets, certificados o reportes en PDF. Aquí se evidencia la separación entre cálculo y presentación: el programa realiza operaciones numéricas con precisión interna y posteriormente aplica reglas de formato, redondeo y representación monetaria para producir un documento legible y normativamente válido. Este proceso introduce al estudiante en consideraciones sobre precisión numérica y consistencia de representación, particularmente en contextos financieros \cite{IEEE2019Standard754,Chapra2014Numerical,Laudon2020Management}.
					
					Asimismo, las salidas pueden materializarse como \textbf{archivos de intercambio} (CSV, JSON, XML) destinados a conciliaciones contables o integración con otros sistemas. La correcta generación de estos archivos requiere controlar delimitadores, orden estable de campos, codificación de caracteres y validación de totales agregados para evitar discrepancias en procesos posteriores. Desde el punto de vista pedagógico, este formato refuerza la noción de interoperabilidad y la importancia de respetar contratos de datos definidos entre sistemas \cite{ISO247722024Programming,Date2019Database,Elmasri2016Database}.
					
					En arquitecturas distribuidas, la salida puede expresarse como \textbf{respuestas de servicios} o \textbf{mensajes asincrónicos}. En el primer caso, el sistema devuelve estructuras serializadas acompañadas de códigos de estado que indican éxito o error; en el segundo, publica eventos que desencadenan acciones en otros módulos (por ejemplo, notificaciones de stock bajo). Estas modalidades introducen conceptos de contrato de interfaz, consistencia eventual y control de idempotencia, ampliando la comprensión del estudiante sobre sistemas interconectados \cite{Pressman2019Software,Sommerville2015Software,ISO247722024Programming}.
					
					\AcadBubble{Resumiendo...}
					{
						El diseño de salidas debe considerar la \textbf{segmentación por roles organizacionales}. La información generada no se distribuye indiscriminadamente: mientras un operador visualiza detalles operativos, un directivo requiere indicadores agregados, y un usuario final accede únicamente a datos que le competen. Este principio articula programación con gobierno de datos y control de acceso, reforzando la dimensión organizacional del sistema \cite{Laudon2020Management,Kendall2014Systems,Date2019Database}.
					}
					
					En conjunto, las salidas esperadas no constituyen meros productos finales del algoritmo, sino componentes estructurales que garantizan verificabilidad, consistencia y utilidad organizacional. Diseñarlas adecuadamente implica integrar criterios de precisión numérica, control transaccional, interoperabilidad y segmentación de información, consolidando así una visión profesional del desarrollo de Sistemas de Información.
											
				\subsection{Procesos}
					\noindent
					En el contexto de los TIS, el proceso constituye el núcleo transformador que convierte entradas validadas en resultados consistentes y persistentes. Desde una perspectiva formal, un proceso se define como una secuencia estructurada de operaciones gobernadas por reglas explícitas del dominio organizacional. En programación básica, esta estructura se materializa mediante decisiones condicionales, ciclos iterativos, funciones auxiliares y mecanismos de control de errores; sin embargo, en TIS el proceso adquiere una dimensión adicional al estar vinculado con estados persistentes y con la necesidad de preservar integridad bajo uso concurrente \cite{Pressman2019Software,Sommerville2015Software,Laudon2020Management}.
					
					En términos operativos, el proceso transaccional se organiza como una transacción: una secuencia ordenada que (i) valida entradas, (ii) consulta el estado actual del almacenamiento persistente, (iii) aplica reglas de negocio, y (iv) confirma cambios de manera consistente. Esta estructura introduce al estudiante en principios fundamentales como atomicidad, consistencia e aislamiento, esenciales cuando múltiples usuarios interactúan simultáneamente con el sistema \cite{Silberschatz2020Database,Date2019Database,Elmasri2016Database}. De este modo, el proceso deja de ser únicamente una transformación lógica y se convierte en un mecanismo formal de preservación del estado organizacional.
					
					Desde una perspectiva didáctica, resulta conveniente estructurar el proceso como un \emph{pipeline} de etapas claramente delimitadas: normalización de entradas, validación de formato y dominio, verificación cruzada contra datos persistentes, cálculo de resultados y persistencia controlada. Esta descomposición facilita pruebas unitarias, depuración incremental y trazabilidad entre requisito y código implementado \cite{Hanly2015Problem,Gaddis2022Starting,Sommerville2015Software}. Además, fomenta la modularidad y la claridad estructural, atributos recomendados en prácticas de ingeniería de software.
					
					Un aspecto crítico en TIS es el tratamiento sistemático de excepciones. Condiciones como inexistencia de registros, duplicidad de identificadores, insuficiencia de recursos o fallos de comunicación externa deben gestionarse mediante rutas alternativas claramente definidas, evitando efectos colaterales no deseados. Programar excepciones fortalece la robustez del sistema y enseña a documentar condiciones límite, en coherencia con recomendaciones de programación segura \cite{ISO247722024Programming,Pressman2019Software,Silberschatz2018Operating}.
					
					Asimismo, la construcción de procesos requiere definir invariantes explícitos del dominio. Por ejemplo, en una venta transaccional: el total debe coincidir con la suma de sus ítems, el inventario no puede quedar en valores negativos y el identificador del comprobante debe ser único. Estas invariantes, implementadas como validaciones o aserciones, previenen inconsistencias silenciosas y refuerzan la disciplina de verificación interna del sistema \cite{Date2019Database,Elmasri2016Database,ISO247722024Programming}.
					
					\AcadBubble{Importante...}
					{
						En escenarios multiusuario, los procesos deben considerar concurrencia y sincronización. Dos operaciones simultáneas sobre el mismo registro pueden generar condiciones de carrera si no existen mecanismos adecuados de aislamiento. El análisis y simulación de estos escenarios en el aula permite introducir nociones de bloqueo, control transaccional y manejo de conflictos, ampliando la comprensión del estudiante sobre el comportamiento real de los TIS \cite{Silberschatz2020Database,Tanenbaum2021Structured,Date2019Database}.
					}
					
					% -----------------------------
					% Ejemplo aplicado (TIS): Registrar venta
					% -----------------------------
					\textbf{Ejemplo aplicado (TIS): Registro de una venta con control de inventario.}
					
					Se considera el siguiente escenario transaccional: un operador registra una venta compuesta por varios productos; el sistema debe validar existencia de cliente y productos, verificar disponibilidad de inventario, calcular subtotales e impuestos, actualizar existencias y generar un comprobante persistente. Este ejemplo integra validación, cálculo, persistencia y control transaccional en una sola unidad coherente \cite{Laudon2020Management,Silberschatz2020Database,Pressman2019Software}.
						
					\begin{lstlisting}[caption={Pseudocódigo: Proceso transaccional \texttt{registrarVenta}},label={lst:registrarVenta},basicstyle=\small\ttfamily]
	Algoritmo registrarVenta
	Entrada: listaItems (productoId, cantidad), clienteId
	Salida: comprobanteId, total, estado
	
	// 1) Validaciones iniciales
	Si clienteId es vacio Entonces
		devolver Error("Cliente requerido")
	FinSi
	
	Para cada item en listaItems Haga
		Si item.cantidad <= 0 Entonces
			devolver Error("Cantidad invalida")
		FinSi
	FinPara
	
	// 2) Validacion cruzada contra almacenamiento persistente
	Si no existeCliente(clienteId) Entonces
		devolver Error("Cliente inexistente")
	FinSi
	
	Para cada item en listaItems Haga
		Si no existeProducto(item.productoId) Entonces
			devolver Error("Producto inexistente")
		FinSi
		Si stock(item.productoId) < item.cantidad Entonces
			devolver Error("Stock insuficiente")
		FinSi
	FinPara
	
	// 3) Calculo de montos
	total <- 0
	Para cada item en listaItems Haga
		precio <- precioVigente(item.productoId)
		total <- total + (precio * item.cantidad)
	FinPara
	impuestos <- calcularImpuesto(total)
	totalFinal <- total + impuestos
	
	// 4) Persistencia atomica
	IniciarTransaccion()
	comprobanteId <- insertarVenta(clienteId, totalFinal, impuestos)
	Para cada item en listaItems Haga
		insertarDetalle(comprobanteId, item.productoId, item.cantidad, precioVigente(item.productoId))
		actualizarStock(item.productoId, stock(item.productoId) - item.cantidad)
	FinPara
	ConfirmarTransaccion()
	
	devolver OK(comprobanteId, totalFinal)
	FinAlgoritmo \end{lstlisting}
						
					\noindent
					\textbf{Utilidad formativa:} este ejemplo permite ejercitar validación estructurada, ciclos, modularización y manejo de errores, a la vez que introduce el principio de atomicidad propio de los TIS: la transacción se aplica íntegramente o no se aplica en absoluto. Esta propiedad garantiza coherencia y evita estados intermedios inconsistentes \cite{Silberschatz2020Database,Date2019Database,ISO247722024Programming}.
					
					% -----------------------------
					% Diagrama de flujo actualizado
					% -----------------------------
					\begin{figure}[ht]
						\centering
						\begin{tikzpicture}[
							node distance=8mm and 10mm,
							every node/.style={font=\small},
							startstop/.style={ellipse,draw,align=center,minimum width=32mm,minimum height=7mm},
							process/.style={rectangle,draw,rounded corners=2pt,align=center,minimum width=45mm,minimum height=7mm},
							decision/.style={diamond,draw,aspect=2.0,align=center,inner sep=1pt,minimum width=34mm,minimum height=8mm},
							arrow/.style={-Latex,thick}
							]
							\node[startstop] (start) {Inicio};
							\node[process,below=of start] (read) {Leer clienteId y listaItems};
							\node[decision,below=of read] (valid1) {¿Entradas válidas?};
							\node[process,below left=of valid1,xshift=-6mm] (err1) {Mostrar error\\y finalizar};
							\node[process,below right=of valid1,xshift=6mm] (cross) {Verificar cliente y productos\\(almacenamiento)};
							\node[decision,below=of cross] (valid2) {¿Stock suficiente?};
							\node[process,below left=of valid2,xshift=-6mm] (err2) {Mostrar error\\y finalizar};
							\node[process,below right=of valid2,xshift=6mm] (calc) {Calcular total e impuestos};
							\node[process,below=of calc] (tx) {Iniciar transacción\\Insertar venta y detalle\\Actualizar inventario};
							\node[process,below=of tx] (commit) {Confirmar transacción};
							\node[startstop,below=of commit] (end) {Fin (OK)};
							
							\draw[arrow] (start) -- (read);
							\draw[arrow] (read) -- (valid1);
							\draw[arrow] (valid1) -- node[above left]{No} (err1);
							\draw[arrow] (valid1) -- node[above right]{Sí} (cross);
							\draw[arrow] (cross) -- (valid2);
							\draw[arrow] (valid2) -- node[above left]{No} (err2);
							\draw[arrow] (valid2) -- node[above right]{Sí} (calc);
							\draw[arrow] (calc) -- (tx);
							\draw[arrow] (tx) -- (commit);
							\draw[arrow] (commit) -- (end);
						\end{tikzpicture}
						\caption{Flujo general del proceso transaccional en un Sistema de Información Transaccional (TIS).}
						\label{fig:flujo-registrar-venta-tis}
					\end{figure}
					
					\subsection{Restricciones organizacionales y técnicas}
					\noindent
						Las restricciones organizacionales incluyen políticas internas, normativas legales y reglas institucionales. Por ejemplo, protección de datos personales según regulaciones vigentes.
						
						Existen restricciones técnicas como capacidad de almacenamiento, rendimiento esperado o compatibilidad con sistemas heredados.
						
						El presupuesto y los recursos humanos también limitan alcance y complejidad.
						
						Las restricciones de seguridad exigen controles de autenticación y autorización.
						
						Finalmente, las restricciones temporales (plazos académicos o administrativos) condicionan la priorización de funcionalidades \cite{Sommerville2015Software}.
						
						\subsection{Del enunciado organizacional al modelo resoluble}
						
						Traducir un enunciado organizacional en modelo computacional implica abstraer la realidad en estructuras de datos y algoritmos. Por ejemplo, “gestionar biblioteca universitaria” se convierte en entidades: Libro, Usuario, Préstamo.
						
						\subsubsection{Stakeholders/Interesados}
						
						Los stakeholders incluyen usuarios finales, administradores, desarrolladores y directivos. Cada uno tiene expectativas distintas.
						
						Por ejemplo, el estudiante desea rapidez y claridad; el administrador requiere reportes consolidados.
						
						Identificar interesados permite priorizar requisitos y definir criterios de aceptación \cite{ISO29148}.
						
						\subsubsection{Supuestos operativos}
						
						Los supuestos delimitan el contexto de operación. Ejemplo: “Se asume conexión estable a Internet” o “Todos los usuarios están previamente registrados”.
						
						Documentar supuestos evita malentendidos y facilita validación posterior \cite{Sommerville2015Software}.
						
						\subsubsection{Casos de prueba representativos}
						
						Un caso de prueba para registro académico puede ser:  
						Entrada: estudiante con identificación válida.  
						Proceso: validación de requisitos académicos.  
						Salida esperada: matrícula aprobada.
						
						Otro caso: estudiante con deuda pendiente.  
						Salida esperada: rechazo con mensaje explícito.
						
						Estos casos permiten verificar funcionalidad antes de despliegue \cite{Pressman2019Software}.
						
						\subsubsection{Criterios de aceptación funcional}
						
						Un criterio de aceptación debe ser medible. Ejemplo: “El sistema calcula correctamente el promedio con dos decimales de precisión”.
						
						Otro criterio puede establecer tiempos máximos de respuesta.
						
						Definir criterios explícitos fortalece calidad y coherencia entre requisito y solución implementada \cite{ISO29148,SWEBOK2014}.
	
	%---------------------------------------------------------
	\chapter{Algoritmos y Modelado de Soluciones Informacionales}
	%---------------------------------------------------------
	
	\section{Proceso de resolución de problemas en Sistemas de Información}
	
	\subsection{Análisis del problema organizacional}
	
	\subsubsection{Identificación de variables relevantes}
	
	\subsubsection{Definición de casos límite}
	
	\subsubsection{Validación de requisitos funcionales}
	
	\subsection{Diseño de soluciones informacionales}
	
	\subsubsection{Estrategias de descomposición}
	
	\subsubsection{Refinamiento sucesivo}
	
	\subsubsection{Selección de estructuras lógicas}
	
	\subsection{Verificación y mejora continua}
	
	\subsubsection{Pruebas funcionales}
	
	\subsubsection{Depuración}
	
	\subsubsection{Optimización básica}
	
	\section{Algoritmos: fundamento para soluciones organizacionales}
	
	\subsection{Definición y propósito en IS}
	
	\subsubsection{Finitud}
	
	\subsubsection{Precisión}
	
	\subsubsection{Efectividad}
	
	\subsection{Correctitud y eficiencia}
	
	\subsubsection{Correctitud funcional}
	
	\subsubsection{Complejidad temporal}
	
	\subsubsection{Complejidad espacial}
	
	\section{Lenguajes formales y lenguajes de programación}
	
	\subsection{Lenguajes formales}
	
	\subsubsection{Alfabeto}
	
	\subsubsection{Gramática}
	
	\subsubsection{Sintaxis}
	
	\subsection{Lenguajes de programación en Sistemas de Información}
	
	\subsubsection{Semántica}
	
	\subsubsection{Paradigmas}
	
	\subsubsection{Compilación e interpretación}
	
	\section{Representación estructurada de soluciones}
	
	\subsection{Lenguaje natural estructurado}
	
	\subsubsection{Ventajas}
	
	\subsubsection{Limitaciones}
	
	\subsubsection{Buenas prácticas}
	
	\subsection{Pseudocódigo}
	
	\subsubsection{Convenciones}
	
	\subsubsection{Estructuras básicas}
	
	\subsubsection{Legibilidad}
	
	\subsection{Diagramas de flujo}
	
	\subsubsection{Simbología}
	
	\subsubsection{Construcción correcta}
	
	\subsubsection{Errores comunes}
	
	\section{Estrategias para el aprendizaje técnico en IS}
	
	\subsection{Práctica deliberada}
	
	\subsubsection{Frecuencia y consistencia}
	
	\subsubsection{Resolución guiada e independiente}
	
	\subsubsection{Registro de errores}
	
	\subsection{Estrategias cognitivas aplicadas}
	
	\subsubsection{Trazado manual}
	
	\subsubsection{Pruebas con casos límite}
	
	\subsubsection{Explicación estructurada}
	
	%=========================================================
	\part{Desarrollo de Aplicaciones para Sistemas de Información}
	%=========================================================
	
	%---------------------------------------------------------
	\chapter{Lenguajes de Programación y Desarrollo de Aplicaciones}
	%---------------------------------------------------------
	
	\section{Del algoritmo a la aplicación organizacional}
	
	\subsection{Estructura mínima de un programa}
	
	\subsubsection{Entradas y salidas}
	
	\subsubsection{Bloques y alcance}
	
	\subsubsection{Ejecución paso a paso}
	
	\subsection{Errores frecuentes en el desarrollo inicial}
	
	\subsubsection{Errores de sintaxis}
	
	\subsubsection{Errores lógicos}
	
	\subsubsection{Errores de ejecución}
	
	\section{Entorno de desarrollo profesional}
	
	\subsection{IDE y flujo de trabajo}
	
	\subsubsection{Creación de proyectos}
	
	\subsubsection{Compilación y ejecución}
	
	\subsubsection{Depuración}
	
	\subsection{Estándares básicos de codificación}
	
	\subsubsection{Indentación}
	
	\subsubsection{Nombres significativos}
	
	\subsubsection{Comentarios técnicos}
	
	\section{Gestión de entrada y salida de datos}
	
	\subsection{Lectura y validación}
	
	\subsubsection{Validación de entrada}
	
	\subsubsection{Conversión de tipos}
	
	\subsubsection{Manejo de datos inválidos}
	
	\subsection{Presentación de resultados}
	
	\subsubsection{Mensajes informativos}
	
	\subsubsection{Salidas principales y secundarias}
	
	\subsubsection{Formato de resultados}
	
	%---------------------------------------------------------
	\chapter{Modelado de Datos y Expresiones en Aplicaciones}
	%---------------------------------------------------------
	
	\section{Tipos de datos en aplicaciones informacionales}
	
	\subsection{Datos numéricos y lógicos}
	
	\subsubsection{Enteros}
	
	\subsubsection{Reales}
	
	\subsubsection{Booleanos}
	
	\subsection{Texto y estructuras básicas}
	
	\subsubsection{Caracteres}
	
	\subsubsection{Cadenas}
	
	\subsubsection{Operaciones frecuentes}
	
	\section{Variables y gestión del estado}
	
	\subsection{Declaración e inicialización}
	
	\subsubsection{Buenas prácticas}
	
	\subsubsection{Ámbito y ciclo de vida}
	
	\subsubsection{Constantes}
	
	\subsection{Asignación y actualización}
	
	\subsubsection{Asignación simple}
	
	\subsubsection{Asignación compuesta}
	
	\subsubsection{Efectos colaterales}
	
	\section{Operadores y construcción de expresiones}
	
	\subsection{Operadores aritméticos, relacionales y lógicos}
	
	\subsubsection{Precedencia}
	
	\subsubsection{Asociatividad}
	
	\subsubsection{Expresiones compuestas}
	
	\subsection{Conversión y validación de datos}
	
	\subsubsection{Conversión implícita}
	
	\subsubsection{Conversión explícita}
	
	\subsubsection{Errores por conversión}
	
	%=========================================================
	\part{Control de Flujo y Gestión de Datos}
	%=========================================================
	
	%---------------------------------------------------------
	\chapter{Estructuras de Control en Aplicaciones Informacionales}
	%---------------------------------------------------------
	
	\section{Estructuras de selección}
	
	\subsection{Selección simple y doble}
	
	\subsubsection{Condición}
	
	\subsubsection{Bloques alternativos}
	
	\subsubsection{Anidamiento}
	
	\subsection{Selección múltiple}
	
	\subsubsection{Casos}
	
	\subsubsection{Cobertura}
	
	\subsubsection{Errores frecuentes}
	
	\section{Estructuras de repetición}
	
	\subsection{Repetición condicional}
	
	\subsubsection{Precondición}
	
	\subsubsection{Postcondición}
	
	\subsubsection{Condiciones de parada}
	
	\subsection{Repetición por contador}
	
	\subsubsection{Contadores}
	
	\subsubsection{Acumuladores}
	
	\subsubsection{Iteraciones}
	
	%---------------------------------------------------------
	\chapter{Estructuración y Organización de Datos}
	%---------------------------------------------------------
	
	\section{Arreglos unidimensionales}
	
	\subsection{Concepto y uso}
	
	\subsubsection{Índices}
	
	\subsubsection{Recorridos}
	
	\subsubsection{Errores de rango}
	
	\section{Arreglos bidimensionales}
	
	\subsection{Matrices}
	
	\subsubsection{Filas y columnas}
	
	\subsubsection{Recorridos}
	
	\subsubsection{Aplicaciones organizacionales}
	
	\section{Registros y datos compuestos}
	
	\subsection{Estructuras simples}
	
	\subsubsection{Campos}
	
	\subsubsection{Acceso}
	
	\subsubsection{Validación}
	
	%=========================================================
	\part{Modularidad, Calidad e Integración en Sistemas de Información}
	%=========================================================
	
	%---------------------------------------------------------
	\chapter{Modularidad y Funciones en Aplicaciones}
	%---------------------------------------------------------
	
	\section{Abstracción y descomposición funcional}
	
	\subsection{Diseño modular}
	
	\subsubsection{Responsabilidad única}
	
	\subsubsection{Cohesión y acoplamiento}
	
	\subsubsection{Reutilización}
	
	\section{Funciones y procedimientos}
	
	\subsection{Definición e invocación}
	
	\subsubsection{Firma}
	
	\subsubsection{Paso de parámetros}
	
	\subsubsection{Ámbito}
	
	\section{Pruebas y calidad básica}
	
	\subsection{Estrategia de pruebas}
	
	\subsubsection{Casos representativos}
	
	\subsubsection{Casos límite}
	
	\subsubsection{Regresión}
	
	%=========================================================
	\part{}
	%=========================================================
	
	%---------------------------------------------------------
	\chapter{Proyecto Integrador en Sistemas de Información}
	%---------------------------------------------------------
	
	\section{Planteamiento organizacional}
	
	\subsection{Contexto y alcance}
	
	\subsubsection{Objetivo}
	
	\subsubsection{Requisitos}
	
	\subsubsection{Restricciones}
	
	\section{Diseño e implementación}
	
	\subsection{Estructura del sistema}
	
	\subsubsection{Módulos}
	
	\subsubsection{Flujo principal}
	
	\subsubsection{Casos alternativos}
		
	%---------------------------------------------------------
	\chapter{Gestión básica de versiones en entornos colaborativos}
	
	\section{Fundamentos}
	
	\subsection{Repositorio y control de cambios}
	
	\subsubsection{Repositorio}
	
	\subsubsection{Commit}
	
	\subsubsection{Ramas}
	
	%---------------------------------------------------------
	\chapter{Glosario y Recursos Académicos}
	
	\section{Términos fundamentales}
	
	\section{Bibliografía y fuentes de consulta}
	
	\appendix
	\chapter{Operaciones bit a bit, máscaras y estados}		
		Las operaciones bit a bit permiten manipular directamente los bits que componen un valor almacenado en memoria. En lenguajes como C y C++, estas operaciones actúan sobre representaciones binarias completas (palabras de 8, 16, 32 o 64 bits), mientras que los operadores lógicos trabajan sobre valores booleanos derivados de expresiones. Distinguir entre ambos niveles resulta fundamental en programación de SI cuando se diseñan mecanismos de control de estados, permisos y banderas codificadas dentro de variables enteras.
		
		%------------------------------------------------
		\section{Operador OR bit a bit \texttt{|}}
		
		\noindent
		El operador \texttt{|} realiza una operación OR entre cada par de bits correspondientes de dos operandos. Actúa a nivel de bit dentro de una palabra completa.
		
		\subsection{Ejemplo 1: OR a nivel de bit (8 bits)}
		
		\[
		A = 01011010_2
		\]
		\[
		B = 00110101_2
		\]
		
		\noindent
		Aplicando OR bit a bit:
		
		\[
		\begin{array}{r}
			01011010 \\
			00110101 \\
			\hline
			01111111
		\end{array}
		\]
		
		\[
		A \, | \, B = 01111111_2
		\]
		
		\noindent
		Cada posición binaria se evalúa de manera independiente. El bit resultante es 1 cuando al menos uno de los bits comparados es 1.
		
		\bigskip
		
		\subsection{Ejemplo 2: OR a nivel de palabra (32 bits en C)}
		
		\begin{lstlisting}[language=C, caption={Uso de OR bit a bit en C}]
			#include <stdio.h>
			
			int main() {
				unsigned int permisos = 0x00000004;  // 00000000 00000000 00000000 00000100
				unsigned int escritura = 0x00000002; // 00000000 00000000 00000000 00000010
				
				permisos = permisos | escritura;
				
				printf("%u\n", permisos);
				return 0;
			} \end{lstlisting}
		
		\noindent
		Resultado binario:
		
		\[
		00000000\;00000000\;00000000\;00000110
		\]
		
		\noindent
		Aquí se activan simultáneamente dos banderas dentro de una palabra de 32 bits.
		
		%------------------------------------------------
		\section{Operador OR lógico \texttt{||}}
		
		\noindent
		El operador \texttt{||} es un operador lógico que evalúa expresiones completas y produce un valor booleano (0 o 1 en C/C++). No actúa bit a bit.
		
		\subsection{Ejemplo 1: Evaluación lógica con cortocircuito}
		
		\begin{lstlisting}[language=C, caption={Uso de OR lógico en C}]
			#include <stdio.h>
			
			int main() {
				int a = 5;
				int b = 0;
				
				if (a || b) {
					printf("Verdadero\n");
				}
				
				return 0;
			} \end{lstlisting}
		
		\noindent
		Como \texttt{a} es distinto de 0, la expresión es verdadera y \texttt{b} no necesita evaluarse (cortocircuito).
		
		\subsection{Ejemplo 2: Diferencia práctica entre \texttt{|} y \texttt{||}}
		
		\begin{lstlisting}[language=C, caption={Comparación entre OR bit a bit y OR lógico}]
			#include <stdio.h>
			
			int main() {
				int x = 2;   // 00000010
				int y = 1;   // 00000001
				
				int r1 = x | y;   // OR bit a bit
				int r2 = x || y;  // OR lógico
				
				printf("r1 = %d\n", r1);
				printf("r2 = %d\n", r2);
				
				return 0;
			} \end{lstlisting}
		
		\[
		x | y = 00000011_2 = 3
		\]
		\[
		x || y = 1
		\]
		
		\noindent
		\texttt{|} conserva estructura binaria.  
		\texttt{||} produce únicamente 0 (falso) o 1 (verdadero).
		
		\bigskip
		
		%------------------------------------------------
		\section{Operador AND \texttt{\&}}
		
		\noindent
		El operador \texttt{\&} realiza una operación AND bit a bit. El bit resultante es 1 únicamente cuando ambos bits son 1.
		
		\[
		\begin{array}{r}
			11001010 \\
			10101100 \\
			\hline
			10001000
		\end{array}
		\]
		
		\noindent
		Uso típico: verificación de bandera.
		
		\begin{lstlisting}[language=C, caption={Verificación de una bandera con AND}]
			if (permisos & 0x04) {
				// permiso activo
			} \end{lstlisting}
		
		%------------------------------------------------
		\section{Operador XOR \texttt{\textasciicircum }}
		\noindent
		El operador \texttt{\string^} produce 1 cuando los bits comparados son diferentes.
		
		\[
		\begin{array}{r}
			1100 \\
			1010 \\
			\hline
			0110
		\end{array}
		\]
		
		\noindent
		Uso típico: alternar un estado.
		
		\begin{lstlisting}[language=C, caption={Alternar un bit con XOR}]
			bandera = bandera ^ 0x01; \end{lstlisting}
		
		%------------------------------------------------
		\section{Desplazamientos}
		
		\subsection{Desplazamiento a la izquierda \texttt{<<}}
		
		\[
		00000101 << 1 = 00001010
		\]
		
		\noindent
		Equivale a multiplicar por 2 cuando no hay desbordamiento.
		
		\begin{lstlisting}[language=C, caption={Desplazamiento a la izquierda}]
			unsigned int x = 5;  // 00000101
			x = x << 1;          // 00001010 \end{lstlisting}
		
		\subsection{Desplazamiento a la derecha \texttt{>>}}
		
		\[
		00001010 >> 1 = 00000101
		\]
		
		\noindent
		Equivale a dividir entre 2 para enteros sin signo.
		
		\begin{lstlisting}[language=C, caption={Desplazamiento a la derecha}]
			unsigned int y = 10; // 00001010
			y = y >> 1;          // 00000101 \end{lstlisting}
		
		\bigskip
		
		%------------------------------------------------
		\section{Resumen comparativo}
		
		\begin{center}
			\begin{tabular}{l l}
				Operador & Nivel de operación \\
				\hline
				\texttt{|}  & Bit a bit (palabra completa) \\
				\texttt{\&} & Bit a bit \\
				\texttt{\^} & Bit a bit \\
				\texttt{<< >>} & Bit a bit (desplazamiento) \\
				\texttt{||} & Lógico (booleano) \\
				\texttt{\&\&} & Lógico (booleano) \\
			\end{tabular}
		\end{center}
		
		\AcadBubble{Importante}{%
			Las operaciones bit a bit modifican directamente la representación binaria almacenada en memoria. Los operadores lógicos evalúan expresiones completas y producen valores booleanos. Esta distinción permite diseñar estructuras compactas de control y validación dentro de sistemas computacionales.
		}
	
	\chapter{Codificación de caracteres: de ASCII a Unicode}
	\noindent
		La \emph{codificación de caracteres} establece una correspondencia entre símbolos (letras, dígitos, signos, controles) y valores numéricos que un sistema digital puede almacenar, transmitir y procesar. En programación, este mapeo condiciona tareas tan diversas como validación de entradas, serialización de datos, interoperabilidad entre sistemas, normalización de texto y depuración de errores por interpretación de bytes. Por tal motivo, un aprendizaje riguroso de programación se beneficia cuando el estudiante distingue con precisión entre: (i) \emph{repertorio} de caracteres (qué símbolos existen), (ii) \emph{codificación} (cómo se traducen a números) y (iii) \emph{codificación de bytes} (cómo esos números se representan en memoria y en archivos) \cite{Unicode2025Standard,ISOIEC6461991,Yergeau2003UTF8}.
		
		\noindent
		Dentro de este panorama, ASCII se consolidó como base histórica de múltiples convenciones de software al definir un repertorio mínimo de 128 caracteres sobre 7 bits, suficiente para el alfabeto inglés y señales de control heredadas de teletipos. No obstante, la evolución hacia lenguas con acentos, símbolos monetarios y tipografías diversas motivó extensiones de 8 bits (\emph{code pages}) y, posteriormente, la adopción de Unicode como estándar global. Esta progresión explica por qué, en sistemas actuales, UTF-8 domina como codificación de intercambio: mantiene compatibilidad hacia atrás con ASCII en el rango 0--127 y habilita la representación de prácticamente todos los sistemas de escritura \cite{Unicode2025Standard,Yergeau2003UTF8,ISOIEC1998Information}.
					
		\subsection{ASCII (7 bits): repertorio base 0--127}
		\noindent
			ASCII define 128 posiciones numeradas de 0 a 127. Las posiciones 0--31 y 127 se reservan para caracteres de control (no imprimibles), mientras que 32--126 representan caracteres imprimibles (espacio, signos, dígitos y letras). La tabla siguiente presenta el mapeo completo, expresado en decimal y hexadecimal, destacando el nombre convencional de los controles \cite{Cerf1969ASCII,ISOIEC6461991}.
			
			\small
			\begin{longtable}{r r c l r r c l}
				\hline
				Dec & Hex & Car. & Nombre & Dec & Hex & Car. & Nombre \\
				\hline
				\endfirsthead
				
				\hline
				Dec & Hex & Car. & Nombre & Dec & Hex & Car. & Nombre \\
				\hline
				\endhead
				
				\hline
				\endfoot
				
				\hline
				\endlastfoot
				
				0 & 00 &  & NUL & 64 & 40 & @ & Car. Arroba \\
				1 & 01 &  & SOH & 65 & 41 & A & A \\
				2 & 02 &  & STX & 66 & 42 & B & B \\
				3 & 03 &  & ETX & 67 & 43 & C & C \\
				4 & 04 &  & EOT & 68 & 44 & D & D \\
				5 & 05 &  & ENQ & 69 & 45 & E & E \\
				6 & 06 &  & ACK & 70 & 46 & F & F \\
				7 & 07 &  & BEL & 71 & 47 & G & G \\
				8 & 08 &  & BS  & 72 & 48 & H & H \\
				9 & 09 &  & HT  & 73 & 49 & I & I \\
				10 & 0A &  & LF  & 74 & 4A & J & J \\
				11 & 0B &  & VT  & 75 & 4B & K & K \\
				12 & 0C &  & FF  & 76 & 4C & L & L \\
				13 & 0D &  & CR  & 77 & 4D & M & M \\
				14 & 0E &  & SO  & 78 & 4E & N & N \\
				15 & 0F &  & SI  & 79 & 4F & O & O \\
				16 & 10 &  & DLE & 80 & 50 & P & P \\
				17 & 11 &  & DC1 & 81 & 51 & Q & Q \\
				18 & 12 &  & DC2 & 82 & 52 & R & R \\
				19 & 13 &  & DC3 & 83 & 53 & S & S \\
				20 & 14 &  & DC4 & 84 & 54 & T & T \\
				21 & 15 &  & NAK & 85 & 55 & U & U \\
				22 & 16 &  & SYN & 86 & 56 & V & V \\
				23 & 17 &  & ETB & 87 & 57 & W & W \\
				24 & 18 &  & CAN & 88 & 58 & X & X \\
				25 & 19 &  & EM  & 89 & 59 & Y & Y \\
				26 & 1A &  & SUB & 90 & 5A & Z & Z \\
				27 & 1B &  & ESC & 91 & 5B & [ & Corchete izquierdo \\
				28 & 1C &  & FS  & 92 & 5C & $\backslash$ & Barra invertida \\
				29 & 1D &  & GS  & 93 & 5D & ] & Corchete derecho \\
				30 & 1E &  & RS  & 94 & 5E & \^ & Acento circunflejo \\
				31 & 1F &  & US  & 95 & 5F & \_ & Guion bajo \\
				32 & 20 &   & Espacio & 96 & 60 & ` & Acento grave \\
				33 & 21 & ! & Signo de exclamación & 97 & 61 & a & a \\
				34 & 22 & " & Comillas dobles & 98 & 62 & b & b \\
				35 & 23 & \# & Signo numeral & 99 & 63 & c & c \\
				36 & 24 & \$ & Signo dólar & 100 & 64 & d & d \\
				37 & 25 & \% & Signo de porcentaje & 101 & 65 & e & e \\
				38 & 26 & \& & Ampersand & 102 & 66 & f & f \\
				39 & 27 & ' & Apóstrofo & 103 & 67 & g & g \\
				40 & 28 & ( & Paréntesis izquierdo & 104 & 68 & h & h \\
				41 & 29 & ) & Paréntesis derecho & 105 & 69 & i & i \\
				42 & 2A & * & Asterisco & 106 & 6A & j & j \\
				43 & 2B & + & Signo más & 107 & 6B & k & k \\
				44 & 2C & , & Coma & 108 & 6C & l & l \\
				45 & 2D & - & Guion & 109 & 6D & m & m \\
				46 & 2E & . & Punto & 110 & 6E & n & n \\
				47 & 2F & / & Barra diagonal & 111 & 6F & o & o \\
				48 & 30 & 0 & 0 & 112 & 70 & p & p \\
				49 & 31 & 1 & 1 & 113 & 71 & q & q \\
				50 & 32 & 2 & 2 & 114 & 72 & r & r \\
				51 & 33 & 3 & 3 & 115 & 73 & s & s \\
				52 & 34 & 4 & 4 & 116 & 74 & t & t \\
				53 & 35 & 5 & 5 & 117 & 75 & u & u \\
				54 & 36 & 6 & 6 & 118 & 76 & v & v \\
				55 & 37 & 7 & 7 & 119 & 77 & w & w \\
				56 & 38 & 8 & 8 & 120 & 78 & x & x \\
				57 & 39 & 9 & 9 & 121 & 79 & y & y \\
				58 & 3A & : & Dos puntos & 122 & 7A & z & z \\
				59 & 3B & ; & Punto y coma & 123 & 7B & \{ & Llave izquierda \\
				60 & 3C & < & Signo menor que & 124 & 7C & | & Barra vertical \\
				61 & 3D & = & Signo igual & 125 & 7D & \} & Llave derecha \\
				62 & 3E & > & Signo mayor que & 126 & 7E & \textasciitilde & Virgulilla \\
				63 & 3F & ? & Signo de interrogación & 127 & 7F &  & Suprimir (DEL) \\
			\end{longtable}
			
			\noindent
			La tabla ASCII resulta indispensable para lectura de archivos, protocolos y depuración, debido a que múltiples formatos interpretan bytes 0--127 como ASCII. Paralelamente, el estudiante adquiere un criterio operativo: una cadena es, en última instancia, una secuencia de códigos, y el comportamiento de comparaciones, ordenamiento y validaciones depende de esa codificación \cite{Cerf1969ASCII,Unicode2025Standard}.
			
			\subsubsection{Extensiones de 8 bits: por qué ``ASCII extendido'' no es una tabla única}
				\noindent
				En la práctica se usa la expresión ``ASCII extendido'' para referirse a codificaciones de 8 bits que preservan ASCII en 0--127 y asignan caracteres a 128--255. No obstante, ese bloque superior depende de una tabla específica. Dos referencias ampliamente citadas son: (i) ISO/IEC 8859-1 (Latin-1), utilizada históricamente en sistemas UNIX y protocolos antiguos; y (ii) Windows-1252, extensión dominante en entornos Windows que asigna símbolos tipográficos a 0x80--0x9F (posición que en ISO/IEC 8859-1 se reserva para controles) \cite{ISOIEC1998Information,Microsoft2021CodePage,Unicode2025Standard}.
				
				\subsubsection*{Tabla completa ISO/IEC 8859-1 (Latin-1) para 128--255}
				\noindent
					En ISO/IEC 8859-1, el rango 0x80--0x9F corresponde a controles C1. El rango 0xA0--0xFF contiene símbolos y letras latinas acentuadas.
					
					\small
					\begin{longtable}{r r c l r r c l}
						\caption{Códigos ASCII extendidos (128--255) según ISO-8859-1}
						\label{tab:ascii-extendido}\\
						
						\hline
						Dec & Hex & Car. & Nombre & Dec & Hex & Car. & Nombre \\
						\hline
						\endfirsthead
						
						\multicolumn{8}{c}%
						{\small\tablename\ \thetable\ (continuación)}\\
						\hline
						Dec & Hex & Car. & Nombre & Dec & Hex & Car. & Nombre \\
						\hline
						\endhead
						
						\hline
						\multicolumn{8}{r}{\small Continúa en la siguiente página}\\
						\endfoot
						
						\hline
						\endlastfoot
						
						128 & 80 &  & Control & 192 & C0 & À & A grave \\
						129 & 81 &  & Control & 193 & C1 & Á & A aguda \\
						130 & 82 &  & Control & 194 & C2 & Â & A circunfleja \\
						131 & 83 &  & Control & 195 & C3 & Ã & A tilde \\
						132 & 84 &  & Control & 196 & C4 & Ä & A diéresis \\
						133 & 85 &  & Control & 197 & C5 & Å & A anillo \\
						134 & 86 &  & Control & 198 & C6 & Æ & AE \\
						135 & 87 &  & Control & 199 & C7 & Ç & C cedilla \\
						136 & 88 &  & Control & 200 & C8 & È & E grave \\
						137 & 89 &  & Control & 201 & C9 & É & E aguda \\
						138 & 8A &  & Control & 202 & CA & Ê & E circunfleja \\
						139 & 8B &  & Control & 203 & CB & Ë & E diéresis \\
						140 & 8C &  & Control & 204 & CC & Ì & I grave \\
						141 & 8D &  & Control & 205 & CD & Í & I aguda \\
						142 & 8E &  & Control & 206 & CE & Î & I circunfleja \\
						143 & 8F &  & Control & 207 & CF & Ï & I diéresis \\
						144 & 90 &  & Control & 208 & D0 & Ð & Eth mayúscula \\
						145 & 91 &  & Control & 209 & D1 & Ñ & N con tilde \\
						146 & 92 &  & Control & 210 & D2 & Ò & O grave \\
						147 & 93 &  & Control & 211 & D3 & Ó & O aguda \\
						148 & 94 &  & Control & 212 & D4 & Ô & O circunfleja \\
						149 & 95 &  & Control & 213 & D5 & Õ & O tilde \\
						150 & 96 &  & Control & 214 & D6 & Ö & O diéresis \\
						151 & 97 &  & Control & 215 & D7 & × & Multiplicación \\
						152 & 98 &  & Control & 216 & D8 & Ø & O tachada \\
						153 & 99 &  & Control & 217 & D9 & Ù & U grave \\
						154 & 9A &  & Control & 218 & DA & Ú & U aguda \\
						155 & 9B &  & Control & 219 & DB & Û & U circunfleja \\
						156 & 9C &  & Control & 220 & DC & Ü & U diéresis \\
						157 & 9D &  & Control & 221 & DD & Ý & Y aguda \\
						158 & 9E &  & Control & 222 & DE & Þ & Thorn mayúscula \\
						159 & 9F &  & Control & 223 & DF & ß & Eszett \\
						160 & A0 & ~ & Espacio no separable & 224 & E0 & à & a grave \\
						161 & A1 & ¡ & Exclamación invertida & 225 & E1 & á & a aguda \\
						162 & A2 & ¢ & Centavo & 226 & E2 & â & a circunfleja \\
						163 & A3 & £ & Libra esterlina & 227 & E3 & ã & a tilde \\
						164 & A4 & ¤ & Moneda & 228 & E4 & ä & a diéresis \\
						165 & A5 & ¥ & Yen & 229 & E5 & å & a anillo \\
						166 & A6 & ¦ & Barra partida & 230 & E6 & æ & ae \\
						167 & A7 & § & Sección & 231 & E7 & ç & c cedilla \\
						168 & A8 & ¨ & Diéresis & 232 & E8 & è & e grave \\
						169 & A9 & © & Copyright & 233 & E9 & é & e aguda \\
						170 & AA & ª & Ordinal femenino & 234 & EA & ê & e circunfleja \\
						171 & AB & « & Comillas angulares izq. & 235 & EB & ë & e diéresis \\
						172 & AC & ¬ & Negación & 236 & EC & ì & i grave \\
						173 & AD & ­ & Guion suave & 237 & ED & í & i aguda \\
						174 & AE & ® & Marca registrada & 238 & EE & î & i circunfleja \\
						175 & AF & ¯ & Macrón & 239 & EF & ï & i diéresis \\
						176 & B0 & ° & Grado & 240 & F0 & ð & eth minúscula \\
						177 & B1 & ± & Más/menos & 241 & F1 & ñ & n con tilde \\
						178 & B2 & ² & Superíndice 2 & 242 & F2 & ò & o grave \\
						179 & B3 & ³ & Superíndice 3 & 243 & F3 & ó & o aguda \\
						180 & B4 & ´ & Acento agudo & 244 & F4 & ô & o circunfleja \\
						181 & B5 & µ & Micro & 245 & F5 & õ & o tilde \\
						182 & B6 & ¶ & Párrafo & 246 & F6 & ö & o diéresis \\
						183 & B7 & · & Punto medio & 247 & F7 & ÷ & División \\
						184 & B8 & ¸ & Cedilla & 248 & F8 & ø & o tachada \\
						185 & B9 & ¹ & Superíndice 1 & 249 & F9 & ù & u grave \\
						186 & BA & º & Ordinal masculino & 250 & FA & ú & u aguda \\
						187 & BB & » & Comillas angulares der. & 251 & FB & û & u circunfleja \\
						188 & BC & ¼ & Un cuarto & 252 & FC & ü & u diéresis \\
						189 & BD & ½ & Un medio & 253 & FD & ý & y aguda \\
						190 & BE & ¾ & Tres cuartos & 254 & FE & þ & thorn minúscula \\
						191 & BF & ¿ & Interrogación invertida & 255 & FF & ÿ & y diéresis \\
					\end{longtable}					
				
				\subsubsection*{Tabla completa Windows-1252 para 128--255}
					\noindent
					Windows-1252 mantiene ASCII en 0--127, pero asigna caracteres tipográficos a 0x80--0x9F. Esta distinción resulta indispensable en programación al interpretar archivos de texto ``ANSI\textbf{15}'' de Windows que contienen comillas curvas, guiones largos o el símbolo del euro \cite{Microsoft2021CodePage,Unicode2025Standard}.
					
					\small
					\begin{longtable}{r r c l r r c l}
						\caption{Códigos 128--255 según Windows-1252 (CP1252)}
						\label{tab:cp1252-128-255}\\
						\hline
						Dec & Hex & Car. & Nombre & Dec & Hex & Car. & Nombre \\
						\hline
						\endfirsthead
						
						\multicolumn{8}{c}{\small\tablename\ \thetable\ (continuación)}\\
						\hline
						Dec & Hex & Car. & Nombre & Dec & Hex & Car. & Nombre \\
						\hline
						\endhead
						
						\hline
						\multicolumn{8}{r}{\small Continúa en la siguiente página}\\
						\endfoot
						
						\hline
						\endlastfoot
						
						128 & 80 & \texteuro & Euro & 192 & C0 & À & A grave \\
						129 & 81 &  & No asignado & 193 & C1 & Á & A aguda \\
						130 & 82 & ‚ & Comilla baja simple & 194 & C2 & Â & A circunfleja \\
						131 & 83 & ƒ & Florín & 195 & C3 & Ã & A tilde \\
						132 & 84 & „ & Comillas bajas dobles & 196 & C4 & Ä & A diéresis \\
						133 & 85 & … & Puntos suspensivos & 197 & C5 & Å & A anillo \\
						134 & 86 & † & Daga & 198 & C6 & Æ & AE \\
						135 & 87 & ‡ & Daga doble & 199 & C7 & Ç & C cedilla \\
						136 & 88 & ˆ & Acento circunflejo (diacrítico) & 200 & C8 & È & E grave \\
						137 & 89 & ‰ & Por mil & 201 & C9 & É & E aguda \\
						138 & 8A & Š & S carón (mayúscula) & 202 & CA & Ê & E circunfleja \\
						139 & 8B & ‹ & Comilla angular izq. & 203 & CB & Ë & E diéresis \\
						140 & 8C & Œ & OE (mayúscula) & 204 & CC & Ì & I grave \\
						141 & 8D &  & No asignado & 205 & CD & Í & I aguda \\
						142 & 8E & Ž & Z carón (mayúscula) & 206 & CE & Î & I circunfleja \\
						143 & 8F &  & No asignado & 207 & CF & Ï & I diéresis \\
						144 & 90 &  & No asignado & 208 & D0 & Ð & Eth (mayúscula) \\
						145 & 91 & ‘ & Comilla simple izquierda & 209 & D1 & Ñ & N con tilde \\
						146 & 92 & ’ & Comilla simple derecha & 210 & D2 & Ò & O grave \\
						147 & 93 & “ & Comilla doble izquierda & 211 & D3 & Ó & O aguda \\
						148 & 94 & ” & Comilla doble derecha & 212 & D4 & Ô & O circunfleja \\
						149 & 95 & • & Viñeta & 213 & D5 & Õ & O tilde \\
						150 & 96 & – & Raya corta (en dash) & 214 & D6 & Ö & O diéresis \\
						151 & 97 & — & Raya larga (em dash) & 215 & D7 & × & Multiplicación \\
						152 & 98 & ˜ & Tilde (diacrítico) & 216 & D8 & Ø & O tachada \\
						153 & 99 & ™ & Marca registrada (TM) & 217 & D9 & Ù & U grave \\
						154 & 9A & š & s carón (minúscula) & 218 & DA & Ú & U aguda \\
						155 & 9B & › & Comilla angular der. & 219 & DB & Û & U circunfleja \\
						156 & 9C & œ & oe (minúscula) & 220 & DC & Ü & U diéresis \\
						157 & 9D &  & No asignado & 221 & DD & Ý & Y aguda \\
						158 & 9E & ž & z carón (minúscula) & 222 & DE & Þ & Thorn (mayúscula) \\
						159 & 9F & Ÿ & Y diéresis & 223 & DF & ß & Eszett \\
						160 & A0 & ~ & Espacio no separable & 224 & E0 & à & a grave \\
						161 & A1 & ¡ & Exclamación invertida & 225 & E1 & á & a aguda \\
						162 & A2 & ¢ & Centavo & 226 & E2 & â & a circunfleja \\
						163 & A3 & £ & Libra esterlina & 227 & E3 & ã & a tilde \\
						164 & A4 & ¤ & Signo monetario & 228 & E4 & ä & a diéresis \\
						165 & A5 & ¥ & Yen & 229 & E5 & å & a anillo \\
						166 & A6 & ¦ & Barra partida & 230 & E6 & æ & ae \\
						167 & A7 & § & Sección & 231 & E7 & ç & c cedilla \\
						168 & A8 & ¨ & Diéresis & 232 & E8 & è & e grave \\
						169 & A9 & © & Copyright & 233 & E9 & é & e aguda \\
						170 & AA & ª & Ordinal femenino & 234 & EA & ê & e circunfleja \\
						171 & AB & « & Comillas angulares izq. & 235 & EB & ë & e diéresis \\
						172 & AC & ¬ & Negación & 236 & EC & ì & i grave \\
						173 & AD & ­ & Guion suave & 237 & ED & í & i aguda \\
						174 & AE & ® & Marca registrada & 238 & EE & î & i circunfleja \\
						175 & AF & ¯ & Macrón & 239 & EF & ï & i diéresis \\
						176 & B0 & ° & Grado & 240 & F0 & ð & eth (minúscula) \\
						177 & B1 & ± & Más/menos & 241 & F1 & ñ & n con tilde \\
						178 & B2 & ² & Superíndice 2 & 242 & F2 & ò & o grave \\
						179 & B3 & ³ & Superíndice 3 & 243 & F3 & ó & o aguda \\
						180 & B4 & ´ & Acento agudo & 244 & F4 & ô & o circunfleja \\
						181 & B5 & µ & Micro & 245 & F5 & õ & o tilde \\
						182 & B6 & ¶ & Párrafo & 246 & F6 & ö & o diéresis \\
						183 & B7 & · & Punto medio & 247 & F7 & ÷ & División \\
						184 & B8 & ¸ & Cedilla & 248 & F8 & ø & o tachada \\
						185 & B9 & ¹ & Superíndice 1 & 249 & F9 & ù & u grave \\
						186 & BA & º & Ordinal masculino & 250 & FA & ú & u aguda \\
						187 & BB & » & Comillas angulares der. & 251 & FB & û & u circunfleja \\
						188 & BC & ¼ & Un cuarto & 252 & FC & ü & u diéresis \\
						189 & BD & ½ & Un medio & 253 & FD & ý & y aguda \\
						190 & BE & ¾ & Tres cuartos & 254 & FE & þ & thorn (minúscula) \\
						191 & BF & ¿ & Interrogación invertida & 255 & FF & ÿ & y diéresis \\
					\end{longtable}
										
					\noindent
					En síntesis, cuando un programa recibe un byte con valor 0x93, el símbolo resultante depende de la tabla: en Windows-1252 corresponde a comillas tipográficas (\textquotedblleft), mientras que en ISO/IEC 8859-1 ese valor se reserva para control C1. Esta diferencia explica fallas de interoperabilidad, aparición de caracteres ``extraños'' y necesidad de conversiones explícitas en lectura de archivos \cite{Microsoft2021CodePage,Unicode2025Standard}.
					
				\subsubsection*{Unicode y UTF-8: estándar global para texto}
					\noindent
					Unicode define un repertorio amplio de caracteres (códigos U+XXXX) y asigna puntos de código a letras, símbolos, emoji y escrituras completas. En la práctica, UTF-8 codifica esos puntos de código en secuencias de 1 a 4 bytes: para U+0000 a U+007F coincide con ASCII, lo cual facilita compatibilidad con software heredado. Este diseño sugiere una práctica de programación recomendada: conservar UTF-8 como codificación por defecto en archivos y comunicaciones, y convertir a tablas de 8 bits únicamente cuando el contexto lo exija (por ejemplo, archivos legacy) \cite{Unicode2025Standard,Yergeau2003UTF8}.
					
					De manera complementaria, UTF-16 y UTF-32 existen para necesidades específicas: UTF-16 usa unidades de 16 bits (con pares sustitutos en rangos superiores) y UTF-32 usa 32 bits fijos. En términos pedagógicos, la distinción más útil al inicio es que Unicode separa ``caracter'' (punto de código) de ``cómo se almacena'' (UTF-8/UTF-16/UTF-32). Esa idea permite al estudiante razonar con rigor sobre longitudes de cadenas, índices, conteos de bytes y validaciones de entrada \cite{Unicode2025Standard,Hoffman2000UTF16}.
					
			\subsubsection{Codificación Unicode: UTF-8, UTF-16 y UTF-32}
				\noindent	
				Unicode define un repertorio universal de caracteres asignando a cada uno un \textbf{punto de código} único en el rango U+0000 hasta U+10FFFF. 
				Esta asignación está normada por el estándar ISO/IEC 10646 \cite{ISOIEC2020Information} y especificada operativamente en distintos esquemas de codificación, entre ellos UTF-8, UTF-16 y UTF-32 \cite{Yergeau2003UTF8,Unicode2025Standard}.
				
				\noindent
				\textbf{1. Codificación UTF-8.} Es una codificación de longitud variable (1 a 4 bytes) compatible hacia atrás con ASCII.
				
				\paragraph{Estructura general}
				
				\begin{center}
					\begin{tabular}{ c c }
						\hline
						Rango Unicode & Patrón binario UTF-8 \\
						\hline
						U+0000--007F & 0xxxxxxx \\
						U+0080--07FF & 110xxxxx 10xxxxxx \\
						U+0800--FFFF & 1110xxxx 10xxxxxx 10xxxxxx \\
						U+10000--10FFFF & 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx \\
						\hline
					\end{tabular}
				\end{center}
				
				\paragraph{Diagrama visual de bits. }
				
				Ejemplo: carácter ``ñ'' (U+00F1)
				
				\[
				U+00F1 = 00000000\ 11110001_2
				\]
				
				\noindent
				Distribución en UTF-8 (2 bytes):
				
				\[
				\underbrace{11000011}_{\text{Byte 1}}
				\quad
				\underbrace{10110001}_{\text{Byte 2}}
				\]
				
				\noindent
				En hexadecimal:
				
				\[
				C3\ B1
				\]
				
				\paragraph{Ejemplo con 4 bytes.} Carácter: \emojiFont 😀 (U+1F600)
				
				\[
				1F600_{16} = 0001\ 1111\ 0110\ 0000\ 0000_2
				\]
				
				\noindent
				Distribución en patrón UTF-8:
				
				\[
				\underbrace{11110000}_{F0}
				\quad
				\underbrace{10011111}_{9F}
				\quad
				\underbrace{10011000}_{98}
				\quad
				\underbrace{10000000}_{80}
				\]
				
				\noindent
				Resultado:
				
				\[
				F0\ 9F\ 98\ 80
				\]
				
				\noindent
				\textbf{2. Codificación UTF-16.} Este tipo de codificación utiliza unidades de 16 bits.
				
				\paragraph{Caso simple. } Para puntos U+0000--U+FFFF:
				
				\[
				\text{``ñ''} = 00F1_{16}
				\]
				
				\noindent
				En memoria:
				
				\textbf{Big-endian:}
				\[
				00\ F1
				\]
				
				\textbf{Little-endian:}
				\[
				F1\ 00
				\]
				
				\paragraph{Pares sustitutos (Surrogates).}
				
				Para puntos mayores que U+FFFF:
				
				Carácter 😀 (U+1F600)
				
				\begin{enumerate}
					\item Restar 0x10000:
					\[
					1F600 - 10000 = F600
					\]
					\item Dividir en dos bloques de 10 bits.
					\item Calcular:
					\[
					\text{High surrogate} = D800 + \text{parte alta}
					\]
					\[
					\text{Low surrogate} = DC00 + \text{parte baja}
					\]
					\item Resultado:
					\[
					D83D\ DE00
					\]
				\end{enumerate}
				
				En memoria:
				
				\textbf{Big-endian:}
				\[
				D8\ 3D\ DE\ 00
				\]
				
				\textbf{Little-endian:}
				\[
				3D\ D8\ 00\ DE
				\]
				
				\noindent
				\textbf{3. Codificación UTF-32.} Almacena directamente el punto de código en 32 bits.
				
				Ejemplo:
				
				\[
				\text{``ñ''} = 000000F1_{16}
				\]
				
				En memoria:
				
				\textbf{Big-endian:}
				\[
				00\ 00\ 00\ F1
				\]
				
				\textbf{Little-endian:}
				\[
				F1\ 00\ 00\ 00
				\]
				
				No requiere transformación ni pares sustitutos.
				
				\noindent
				\textbf{4. Diagramas comparativos de almacenamiento}
				
				\begin{center}
					\begin{tabular}{ c c c }
						\hline
						Carácter & UTF-8 & UTF-16 \\
						\hline
						ñ & C3 B1 & 00 F1 \\
						😀 & F0 9F 98 80 & D8 3D DE 00 \\
						\hline
					\end{tabular}
				\end{center}
				
				\noindent
				\textbf{5. Problemas de codificación: Mojibake.} El fenómeno denominado \textit{mojibake} ocurre cuando una secuencia de bytes se interpreta con una codificación distinta a la original.
				
				Ejemplo clásico:
				
				La palabra ``Señor'' en UTF-8:
				
				\[
				53\ 65\ C3\ B1\ 6F\ 72
				\]
				
				Si esos bytes se interpretan como ISO-8859-1, se obtiene:
				
				\[
				SeÃ±or
				\]
				
				Esto ocurre porque:
				
				\begin{itemize}
					\item C3 B1 es correcto en UTF-8 para ``ñ''.
					\item ISO-8859-1 interpreta C3 y B1 como caracteres independientes.
				\end{itemize}
				
				El resultado es una corrupción visual del texto.
				
				\noindent
				\textbf{6. Consideraciones normativas.} UTF-8 está definido formalmente en RFC 3629 \cite{Yergeau2003UTF8}.  
				Unicode y su mapeo con ISO/IEC 10646 están regulados por ISO/IEC 10646 \cite{ISOIEC2020Information}.  
				
				Las diferencias fundamentales son:
				
				\begin{itemize}
					\item UTF-8: eficiente y dominante en Internet.
					\item UTF-16: usado históricamente en Windows y Java.
					\item UTF-32: representación directa, mayor consumo de memoria.
				\end{itemize}
				
				Todas representan exactamente el mismo conjunto Unicode.
			
		\backmatter
		\printbibliography		
	

\end{document}
