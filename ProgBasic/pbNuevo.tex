\documentclass[12pt,oneside]{book}

%---------------------------------------------------------
% Idioma español, con soporte de caracteres modernos
%---------------------------------------------------------
\usepackage[spanish, es-noquoting, es-noshorthands]{babel}

% Codificación recomendada
%\usepackage[utf8]{inputenc}
%\usepackage[T1]{fontenc}

\usepackage{listings}
% Mejoras tipográficas
%\usepackage{lmodern}        % Fuente moderna compatible
\usepackage{microtype}      % Mejora espaciado y legibilidad
\usepackage{multirow}
%---------------------------------------------------------
% Matemáticas y símbolos
%---------------------------------------------------------
\usepackage{amsmath, amssymb, amsfonts}

%---------------------------------------------------------
% Paquetes gráficos y figuras
%---------------------------------------------------------
\usepackage{graphicx}
\usepackage{float}
\usepackage{caption}
\usepackage{subcaption}
\captionsetup{
	font=small,
	labelfont=bf,
	textfont=small
}
% TikZ y librerías necesarias para tus figuras
\usepackage{tikz}
\usetikzlibrary{positioning, arrows.meta, calc, shapes, backgrounds}

%---------------------------------------------------------
% Encabezados y pies de página
%---------------------------------------------------------
\usepackage{fancyhdr}

\pagestyle{fancy}
\fancyhead{}
\fancyhead[LE,RO]{\thepage}
\fancyhead[RE]{\leftmark}
\fancyhead[LO]{\rightmark}

% Ajuste recomendado por fancyhdr
\setlength{\headheight}{15pt}
\addtolength{\topmargin}{-2.5pt}

\renewcommand{\chaptermark}[1]{\markboth{#1}{}}
\renewcommand{\sectionmark}[1]{\markright{#1}}

%---------------------------------------------------------
% Hipervínculos y navegación en PDF
%---------------------------------------------------------
\usepackage[hidelinks]{hyperref}

%---------------------------------------------------------
% Listas mejoradas
%---------------------------------------------------------
\usepackage{enumitem}

%---------------------------------------------------------
% Bibliografía BibLaTeX con estilo IEEE
%---------------------------------------------------------
\usepackage[
backend=biber,
style=ieee,
sorting=none,
doi=true,
url=true
]{biblatex}

\addbibresource{refs.bib}

%---------------------------------------------------------
% Espaciado y formato del documento
%---------------------------------------------------------
\usepackage{setspace}
\onehalfspacing

%---------------------------------------------------------
% Ajuste de tablas (tamaño y espaciado académico)
%---------------------------------------------------------
\usepackage{etoolbox}

% Tablas en tamaño menor y espaciado simple
\AtBeginEnvironment{tabular}{\small\singlespacing}
\AtBeginEnvironment{table}{\small\singlespacing}

\usepackage{geometry}
\geometry{
	letterpaper,
	left=3cm,
	right=2.5cm,
	top=3cm,
	bottom=3cm
}

\usepackage{tabularx}
\usepackage{array}

\lstset{
	basicstyle=\ttfamily\small,
	numbers=left,
	numberstyle=\tiny,
	stepnumber=1,
	numbersep=5pt,
	frame=single,
	columns=fullflexible,
	keepspaces=true,         % <<< Mantiene los espacios tal como están
	showspaces=false,         % <<< Opcional: muestra los espacios visualmente
	showtabs=false,           % <<< Muestra las tabulaciones
	tabsize=2,               % <<< Define cuántos espacios equivale una tabulación
	breaklines=true,
	inputencoding=utf8,
	extendedchars=true,
	literate=
	{á}{{\'a}}1 {é}{{\'e}}1 {í}{{\'i}}1 {ó}{{\'o}}1 {ú}{{\'u}}1
	{Á}{{\'A}}1 {É}{{\'E}}1 {Í}{{\'I}}1 {Ó}{{\'O}}1 {Ú}{{\'U}}1
	{ñ}{{\~n}}1 {Ñ}{{\~N}}1
	{¿}{{\textquestiondown}}1
	{¡}{{\textexclamdown}}1
}

\renewcommand{\arraystretch}{1.15}

%---------------------------------------------------------
% Inicio del documento
%---------------------------------------------------------
\begin{document}
	
	\frontmatter
	
	\title{Programación Básica para Ingeniería en Sistemas de Información:\\
		De los Sistemas de Información al Código}
	\author{Gleiston Guerrero Ulloa}
	\date{}
	\maketitle
	
	\tableofcontents
	
	\chapter*{Prefacio}
	% Propósito del libro, público objetivo,
	% relación con la carrera de Ingeniería en Sistemas de Información,
	% resultado de aprendizaje de la asignatura,
	% recomendaciones de uso para estudiantes y docentes.
	
	\mainmatter
	
	%=========================================================
	\part{Fundamentos de Computación, Sistemas de Información y Algoritmos}
	%=========================================================
	
		\chapter{Computadoras, Información y Sistemas de Programación}
		
			\section{Ingeniería en Sistemas de Información y el rol de la programación}
			% Campo de acción, sistema de información vs sistema informático,
			% programa de computadora como automatización de procesos.
				La Ingeniería en Sistemas de Información se ocupa del estudio, diseño, implementación y gestión de sistemas sociotécnicos que integran personas, procesos y tecnologías con el propósito de optimizar el flujo de información y apoyar la toma de decisiones organizacionales \cite{Gonzalez-Longatt2007Introduccion, Rodriguez-Campillo2003Sistemas}. Desde la perspectiva de obras fundamentales de computación \cite{Sommerville2015Software}, un sistema informático comprende hardware, software y datos, mientras que un sistema de información incorpora además procedimientos, políticas y factores humanos que condicionan su uso efectivo. En este marco, la programación se considera un mecanismo esencial para traducir requerimientos funcionales en procedimientos formales ejecutables por computadoras, permitiendo la automatización de tareas, la reducción de errores y la mejora de la eficiencia operativa \cite{Ekmekci2016Introduction, LopezPablos2013Items}. La capacidad de especificar algoritmos y construir software se convierte así en un elemento indispensable para materializar soluciones que respondan a necesidades reales de las organizaciones.
				
				Asimismo, el rol de la programación dentro de la Ingeniería en Sistemas de Información se fundamenta en su potencial para modelar la lógica de los procesos y representar digitalmente las operaciones que se ejecutan en un entorno corporativo. Tal como señalan manuales y artículos técnicos \cite{Molero2025Evaluacion, LopezPablos2013Items}, un programa consiste en una secuencia de instrucciones que un procesador interpreta mediante ciclos de lectura, decodificación y ejecución, siendo este principio la base sobre la cual se construyen sistemas de gestión, plataformas empresariales y aplicaciones orientadas al negocio \cite{Joyanes2007Fundamentos}. La programación, por tanto, no solo habilita el funcionamiento técnico del sistema, sino que también estructura la interacción entre los distintos componentes organizacionales mediante reglas lógicas claras y reproducibles \cite{Joyanes2007Fundamentos,Cwu2025Information}.
				
				\subsection{La programación como competencia profesional}
					En el contexto profesional, la programación constituye una competencia central que habilita a los ingenieros de sistemas para diseñar soluciones computacionales alineadas con las necesidades estratégicas de la organización. Los programadores no se limitan a escribir código, sino que analizan problemas, diseñan modelos conceptuales y transforman esos modelos en implementaciones precisas y optimizadas. Esto encaja con la visión contemporánea de la ingeniería de software como motor de la transformación digital y la innovación en las organizaciones \cite{alenezi2021, Naufal2024Role}.  
					
					Desde la práctica profesional, la programación exige habilidades de abstracción, pensamiento algorítmico, evaluación de alternativas tecnológicas y dominio de lenguajes formales que permitan expresar con claridad la solución propuesta. Esta competencia implica comprender cómo los datos fluyen a través de los sistemas, cómo se gestionan los recursos computacionales y cómo se implementan estructuras que garanticen robustez, escalabilidad y mantenibilidad. De este modo, el profesional se posiciona para traducir requerimientos operativos en sistemas fiables y sostenibles en el tiempo \cite{miquel2013, Pressman2019Software}.  
					
					Finalmente, la programación se consolida como una competencia estratégica debido a su papel en la innovación tecnológica. La capacidad para desarrollar software orientado a necesidades específicas permite crear ventajas competitivas, incorporar nuevas modalidades de servicio y adaptar organizaciones a entornos digitales en constante evolución \cite{varzaru2024, fadhlurrahman2024}. Así, la programación no solo responde a demandas existentes, sino que posibilita la creación de nuevas oportunidades en áreas como automatización, analítica, inteligencia artificial, sistemas distribuidos y modelos de negocio digitales.  
					
					
				\subsection{Relación entre procesos organizacionales y software}
					Los procesos organizacionales describen la secuencia de actividades que transforman insumos en productos o servicios, y el software constituye el medio principal para estructurar, automatizar y controlar dichos procesos. En obras clásicas y recientes sobre gestión de procesos e integración empresarial, se reconoce que los sistemas de información son efectivos cuando reflejan fielmente los flujos operativos de la organización, asegurando que la captura, procesamiento y salida de datos correspondan a la realidad empresarial \cite{bitkowska2022, fazlollahi2012}.  
					
					El software implementa reglas, restricciones y secuencias lógicas que garantizan que los procesos se ejecuten de manera consistente, uniforme y verificable. La correspondencia entre software y procesos requiere un análisis detallado de las actividades humanas, los puntos de decisión, las dependencias entre tareas y los mecanismos de control. Una vez modelados estos elementos (como en el contexto de Business Process Management – BPM), el software se convierte en la herramienta que soporta su ejecución digital, reduciendo tiempos, minimizando errores y permitiendo trazabilidad \cite{martin-navarro2023, blahusiakova2023}. Esto es evidente en sistemas como control de inventarios, nómina, admisión académica o gestión de ventas, donde el software representa y ejecuta reglas de negocio de forma automática.  
					
					Además, el software facilita la integración entre procesos que anteriormente funcionaban de forma aislada. Gracias a la conexión de módulos y bases de datos, los sistemas permiten compartir información entre departamentos y sincronizar operaciones en tiempo real. Este alineamiento entre tecnología y operación genera mejoras sustanciales en la eficiencia global, en la capacidad de respuesta ante cambios y en la calidad del servicio ofrecido por la organización \cite{irani2003, fosso2013, bitkowska2022}.
					
				\section{El rol del programador en el desarrollo de sistemas de información}
					El programador cumple un rol fundamental en el desarrollo de sistemas de información al actuar como el puente entre los requerimientos del negocio y la implementación técnica. Su responsabilidad no se limita a codificar, sino que incluye analizar, interpretar y traducir reglas de negocio en instrucciones precisas que serán ejecutadas por la computadora. En efecto, un ingeniero de software aplica principios de ingeniería para diseñar, desarrollar y mantener sistemas de software que satisfacen necesidades reales de organizaciones \cite{Sommerville2015Software, fullscale2019}.  
					
					Asimismo, el programador participa activamente en la validación y mejora de los procesos organizacionales al identificar inconsistencias, redundancias y oportunidades de optimización durante el desarrollo del sistema. La implementación técnica obliga a examinar cada paso del proceso, lo que permite proponer mejoras basadas en la capacidad del software para gestionar flujos de trabajo de forma más eficiente, segura y consistente \cite{irani2003, arvanitou2020}.  
					
					Finalmente, el programador es responsable de garantizar la calidad del sistema mediante la aplicación de buenas prácticas de diseño, pruebas, documentación, refactorización y mantenimiento. Su intervención asegura que el software sea confiable, extensible y alineado con los objetivos institucionales, contribuyendo con ello al funcionamiento integral del sistema de información \cite{abid2020, lima2023}.  
					
					
				\subsection{Automatización, digitalización y transformación digital}
					La automatización se refiere a la sustitución de tareas manuales por procedimientos ejecutados por computadoras mediante el uso de algoritmos, sensores, aplicaciones o sistemas automáticos. En este contexto, la automatización permite ejecutar operaciones repetitivas con alta velocidad, precisión y consistencia, reduciendo errores humanos y aumentando la productividad \cite{balic2017, atieh2025}. Este enfoque se aplica en dominios como facturación, control de inventario, registros institucionales o procesamiento de transacciones.
					
					La digitalización implica convertir objetos físicos o procesos manuales en representaciones digitales manipulables por sistemas computacionales. Su objetivo es permitir que la información fluya a través de plataformas tecnológicas, eliminando la dependencia del papel y habilitando nuevas formas de interacción y análisis. Por ejemplo, la digitalización de documentos permite su almacenamiento, búsqueda y procesamiento automático, mientras que la digitalización de procesos facilita su integración en sistemas más amplios \cite{verhoef2021, Jeanneret2024Digital}.  
					
					Por su parte, la transformación digital constituye un cambio organizacional profundo que integra tecnología, estrategias de innovación y rediseño de procesos para mejorar significativamente el desempeño institucional. Esta transformación requiere no solo digitalizar información o automatizar tareas, sino reimaginar modelos de operación, aprovechar capacidades analíticas y utilizar el software como motor de innovación. En este contexto, la programación y la ingeniería de software se convierten en componentes críticos para materializar soluciones que soporten nuevos modelos de negocio, experiencias mejoradas para el usuario y toma de decisiones basada en datos \cite{alenezi2021, ribas2021, balic2017}.
					
					En síntesis, la evolución desde automatización hacia digitalización y transformación digital representa una progresión donde la tecnología deja de ser un soporte operativo para convertirse en un elemento estratégico de la organización. El ingeniero de sistemas participa activamente en este proceso mediante el desarrollo de software, la integración de plataformas y la implementación de soluciones que respondan a los desafíos del entorno digital \cite{gonzalez-varona2024, omol2024}. 
					
			\section{Datos, información y conocimiento}
			% Definiciones, ejemplos, calidad de datos.
				Los datos, la información y el conocimiento constituyen niveles complementarios dentro del ciclo de procesamiento que permite que los sistemas computacionales aporten valor. Los datos corresponden a representaciones simbólicas sin interpretación, la información emerge cuando estos datos adquieren significado en un contexto, y el conocimiento se genera cuando la información se asimila, estructura y utiliza para la toma de decisiones. Autores como Gaddis \cite{Gaddis2022Starting} enfatizan que la computación tiene como propósito central transformar datos en información útil mediante operaciones de entrada, procesamiento, almacenamiento y salida.
				
				\subsection{Definiciones fundamentales}
					Los datos se definen como símbolos o valores que representan hechos, medidas u observaciones, pero que por sí mismos carecen de significado. Pueden adoptar la forma de números, letras, sonidos, imágenes o señales capturadas en bruto por sensores o dispositivos de entrada \cite{hackman2024, reich2017}. Su valor depende del modo en que se organizan, almacenan y procesan para cumplir un propósito específico dentro del sistema.  
					
					La información surge cuando los datos son procesados, estructurados o contextualizados de manera que adquieren relevancia para un usuario o una actividad. Este procesamiento puede incluir cálculos, clasificaciones, comparaciones, transformaciones o agregaciones \cite{Dammann2019Data, zins2007, Marchionini2023Information}. La información constituye la base para la toma de decisiones y la ejecución de acciones dentro de una organización.  
					
					Por tanto, la distinción entre dato e información no es mera formalidad: señala la transición entre materia prima (datos) y producto útil (información) — un proceso que depende de métodos de almacenamiento, procesamiento, reglas, contexto y estructuras semánticas. Este entendimiento es clave en el diseño de sistemas de información eficientes y confiables.  
					
					\subsubsection{Dato como representación simbólica}
						Los datos constituyen la forma más elemental de representación de hechos dentro de un sistema computacional. Según los fundamentos de almacenamiento digital y representación de datos en computación, un dato puede expresarse como un número, una letra, un símbolo o un patrón binario que el sistema aún no ha interpretado \cite{hjorland2018, hans2024}. En esta etapa, los datos no poseen un significado por sí mismos; simplemente existen como elementos aislados que esperan ser procesados. Por ejemplo, el valor \texttt{45}, el carácter \texttt{A} o una cadena como \texttt{2025-03-10} son datos sin contexto, pero pueden adquirir interpretación cuando se insertan en un proceso específico, como un sistema de inventario o un registro académico.  
						
						Asimismo, los datos se caracterizan por su capacidad de ser capturados, almacenados y transmitidos mediante diferentes dispositivos computacionales. Los sistemas informáticos representan los datos en estructuras binarias o en tipos de datos definidos, almacenándolos en memoria principal o secundaria, lo que permite su manipulación sistemática \cite{hans2024, data_representation_topic}. Este ciclo evidencia que los datos funcionan como la materia prima indispensable para generar información y conocimiento en entornos digitales, tras un proceso de interpretación, estructuración o contexto que les da significado \cite{floridi2003, gellert2022}.  
						
					\subsubsection{Información: contexto y significado}
						La información se genera a partir de los datos cuando estos son organizados, procesados o contextualizados para responder a una necesidad concreta. En marcos teóricos ampliamente aceptados, se enfatiza que la información es el resultado de aplicar operaciones tales como clasificación, comparación, cálculo o interpretación sobre los datos crudos \cite{baskarada2013, Calzati2025Ecosystemic, horvitz2020}. Por ejemplo, una lista de números puede convertirse en información cuando se calcula un promedio, se ordena la secuencia o se determina la variación entre elementos. Así, la información aporta significado y facilita la comprensión de fenómenos o situaciones específicas.
						
						El valor de la información está estrechamente ligado al contexto. El mismo dato puede ser irrelevante en un entorno, pero crucial en otro. Por ejemplo, el número \texttt{98} podría no comunicar nada por sí mismo; sin embargo, si se interpreta como la calificación promedio de un estudiante o como la temperatura corporal de un paciente, adquiere sentido inmediato. Este fenómeno coincide con la discusión epistemológica sobre la transformación de datos en información en función del contexto, la estructura y el uso previsto \cite{fricke2019, Calzati2025Ecosystemic}.
						
						Finalmente, la información se convierte en un recurso estratégico para organizaciones gracias a su capacidad de apoyar decisiones, automatizar procesos, mejorar la eficiencia organizacional y orientar políticas o acciones informadas. En entornos digitales y de sistemas de información, la generación de información pertinente depende de la calidad de los datos, la adecuación de los algoritmos de procesamiento y la correcta implementación del software que transforma esos datos en insumos útiles para la toma de decisiones \cite{horvitz2020, silwattananusarn2012}.  .
						
					\subsubsection{Conocimiento: reglas, estructuras y experiencia}
						El conocimiento representa el nivel más sofisticado dentro del ciclo de transformación de datos. Surge cuando la información es interpretada, conectada con experiencias previas y organizada en estructuras que permiten comprender situaciones, anticipar problemas y tomar decisiones \cite{baskarada2013, Cato2020Transforming}. Aunque los sistemas computacionales pueden almacenar y procesar grandes volúmenes de información, su capacidad de generar conocimiento depende de modelos diseñados por seres humanos o de técnicas avanzadas como aprendizaje automático o sistemas inteligentes \cite{spivak2011}. En este sentido, el conocimiento implica integración, generalización y aplicación real de la información.
						
						En ingeniería de sistemas, el conocimiento se manifiesta como reglas de negocio, políticas organizacionales, modelos de decisión o patrones de comportamiento que guían el funcionamiento del software. Por ejemplo, un sistema académico no solo almacena datos de estudiantes e información de calificaciones; también incorpora conocimiento institucional al aplicar reglas como “aprobar con mínimo 7/10”, “permitir matrícula si no existen deudas” o “generar alertas si el estudiante reprueba tres asignaturas consecutivas”. Estas reglas, diseñadas a partir de experiencia y normativas, permiten que el sistema actúe de manera coherente y confiable \cite{bernstein2009}.
						
						El conocimiento también se asocia con estructuras mentales y modelos que permiten interpretar la información de manera más profunda. Mientras la información responde al ``qué'', el conocimiento responde al ``por qué'' y ``para qué''. De esta forma, un sistema de información no solo debe presentar datos, sino proveer mecanismos para generar conocimiento útil para gestores, analistas y tomadores de decisiones \cite{dammann2019,williams2014}.  
						
						La literatura identifica el conocimiento como algo más que datos procesados: es una entidad emergente que requiere interpretación, contexto, experiencia o reglas explícitas — atributos humanos o estructurales — para existir. Por ello, la calidad de los datos y la pertinencia del procesamiento influyen directamente en la confiabilidad del conocimiento generado \cite{Calzati2025Ecosystemic, Cato2020Transforming}. Finalmente, el conocimiento es esencial para retroalimentar sistemas inteligentes y procesos de mejora continua dentro de organizaciones modernas. Un sistema que aprende de errores, patrones o tendencias puede evolucionar y adaptarse a nuevas condiciones, convirtiéndose en un activo estratégico para la institución \cite{silwattananusarn2012}.  
						
				\subsection{Flujo de datos y transformación}
					El flujo de datos describe el movimiento de la información desde su origen hasta su utilización final dentro de un sistema computacional. De acuerdo con los modelos de procesamiento estudiados en textos introductorios \cite{BhattComputer}, los datos ingresan al sistema a través de dispositivos de entrada, son transformados mediante operaciones lógicas y aritméticas, se almacenan temporalmente y finalmente se presentan como información útil. Este flujo garantiza que el sistema pueda operar de manera continua y coherente.
					
					Durante la transformación, los datos pueden ser validados, normalizados, agrupados o convertidos en otros formatos. Por ejemplo, una fecha ingresada como \texttt{10-03-25} puede convertirse en \texttt{2025-03-10} para garantizar uniformidad. Asimismo, valores numéricos pueden ser sumados, promediados o comparados para generar indicadores útiles. Estas transformaciones permiten adaptar los datos a los requerimientos de los procesos internos.
					
					El análisis del flujo de datos es fundamental en el diseño de sistemas porque permite identificar posibles redundancias, cuellos de botella o riesgos de inconsistencia. Una representación adecuada del flujo garantiza que la información llegue oportunamente a los usuarios o módulos que la requieren, evitando pérdidas o duplicación de datos y mejorando la eficiencia global del sistema.
					
					\subsubsection{Procesos de captura, procesamiento y salida}
						El proceso de captura consiste en recoger datos desde fuentes internas o externas mediante dispositivos como teclados, sensores, micrófonos, cámaras o sistemas conectados. Según \cite{BhattComputer}, la captura debe asegurar precisión, completitud y coherencia para evitar errores en etapas posteriores. Un ejemplo común es el registro de productos en un sistema de inventarios mediante un lector de código de barras, que garantiza rapidez y precisión en la recolección de datos.
						
						El procesamiento involucra transformaciones lógicas y aritméticas que convierten los datos capturados en información con significado. Estas operaciones pueden incluir sumar, restar, ordenar, clasificar, comparar o aplicar fórmulas más complejas. Por ejemplo, en un sistema académico, el cálculo automático del promedio de un estudiante a partir de sus calificaciones constituye un proceso típico de procesamiento.
						
						La salida corresponde a la presentación de la información procesada al usuario o a otro sistema. Puede materializarse mediante reportes en pantalla, documentos impresos, gráficos o almacenamiento estructurado. Ejemplos comunes incluyen la generación de facturas, la actualización de dashboards o la emisión de certificados. De acuerdo con \cite{Gaddis2022Starting}, los dispositivos de salida como monitores e impresoras traducen la información digital en representaciones comprensibles para el usuario.
						
					\subsubsection{Criterios de calidad de datos}
						La calidad de los datos se evalúa mediante diversos criterios, entre ellos precisión, completitud, consistencia, actualidad y validez. A continuación, se desarrolla cada criterio con su respectivo ejemplo.
						
						\textbf{Precisión.} La precisión se refiere a que los datos reflejen correctamente la realidad. Por ejemplo, registrar que un estudiante obtuvo \texttt{85} en un examen cuando realmente obtuvo \texttt{58} constituye un dato impreciso que afectará todos los cálculos posteriores. Según \cite{BhattComputer}, la precisión es esencial porque errores pequeños pueden amplificarse durante el procesamiento.
						
						\textbf{Completitud.} Se refiere a que no falten datos necesarios para procesar la información. Un registro de cliente sin número de identificación o sin dirección puede impedir la validación de operaciones o la entrega de productos. La falta de completitud ocasiona fallos en transacciones o bloqueos en procesos de negocio.
						
						\textbf{Consistencia.} Los datos deben mantener coherencia entre diferentes fuentes o módulos del sistema. Por ejemplo, si un empleado aparece con salario \texttt{1200} en el módulo de nómina y \texttt{1500} en el módulo de recursos humanos, existe inconsistencia. Esta situación puede deberse a errores de actualización o duplicación de registros.
						
						\textbf{Actualidad.} Los datos deben encontrarse actualizados para reflejar correctamente el estado del sistema. Una tarifa de servicio desactualizada puede generar cobros incorrectos. Según \cite{Gaddis2022Starting}, la actualidad es crítica en sistemas de comercio y banca, donde los datos cambian frecuentemente.
						
						\textbf{Validez.} Los datos deben cumplir reglas específicas o restricciones definidas por la organización. Por ejemplo, una fecha de nacimiento futura como \texttt{2030-05-10} no es válida en un registro personal. La validez garantiza que los datos se ajusten a dominios y formatos aceptables.
						
				\subsection{Datos en sistemas computacionales}
					Los datos almacenados en sistemas computacionales están sujetos a restricciones propias del hardware y del software que los manipulan. En términos de representación digital, todos los datos deben convertirse a secuencias de bits, tal como se explica en la literatura de fundamentos de programación y arquitectura \cite{Gaddis2022Starting}. Esta representación binaria permite que el procesador interprete, almacene y transforme los datos mediante operaciones lógicas y aritméticas. En un sistema computacional, los datos pueden corresponder a valores numéricos, texto, imágenes, audio o cualquier forma de información digital.
					
					El manejo de datos dentro del sistema implica su ubicación en memoria primaria, su posible transferencia a memoria secundaria y su uso durante la ejecución de programas. Los textos de introducción a la computación \cite{BhattComputer} destacan que los datos fluyen entre CPU, memoria y dispositivos de entrada/salida mediante buses especializados, asegurando una comunicación eficiente entre los componentes del sistema. La forma en que se organizan estos datos influye en la eficiencia, seguridad y consistencia del sistema.
					
					Finalmente, los datos en sistemas computacionales se encuentran estructurados según tipos específicos definidos por el lenguaje de programación y por el sistema operativo. Estos tipos permiten especificar el tamaño, formato y operaciones válidas para cada dato, lo que garantiza integridad y minimiza errores durante la ejecución. Esta estructura formal es esencial para el diseño de algoritmos robustos y sistemas confiables.
					
					\subsubsection{Representación interna}
						La representación interna de los datos en una computadora se basa en el sistema binario, donde cada valor se almacena como una combinación de bits. De acuerdo con \cite{Gaddis2022Starting}, un byte está compuesto por ocho bits, y cada patrón binario representa un número, un carácter o una instrucción dependiendo del contexto. Por ejemplo, el carácter \texttt{A} se representa mediante el código ASCII \texttt{65}, cuyo equivalente binario es \texttt{01000001}. Este proceso permite que la información textual sea manejada de manera uniforme.
						
						Asimismo, los datos numéricos pueden representarse mediante diferentes codificaciones internas. Los enteros utilizan frecuentemente la representación en complemento a dos para manejar valores positivos y negativos, mientras que los números reales se representan mediante notación de punto flotante basada en el estándar IEEE 754. Este método divide el número en signo, exponente y mantisa, permitiendo una representación amplia pero aproximada del valor real. Como señalan los manuales de arquitectura computacional, la precisión depende directamente del número de bits asignados.
						
						Finalmente, la representación interna también afecta la forma en que los programas interpretan y manipulan los datos. Un conjunto de bits puede corresponder a un número, un carácter o una instrucción dependiendo del módulo que lo interprete. Esta versatilidad es fundamental para la ejecución de programas, pero requiere disciplina en su manejo para evitar errores de interpretación y corrupción de datos.
						
					\subsubsection{Persistencia y acceso}
						La persistencia de datos se refiere a su capacidad de mantenerse almacenados incluso cuando el sistema se apaga. Los textos de fundamentos \cite{Gaddis2022Starting} identifican los discos duros, unidades de estado sólido y memorias flash como medios principales para lograr esta finalidad. A diferencia de la memoria RAM, que es volátil, los dispositivos de almacenamiento secundario preservan los datos utilizando tecnologías magnéticas, ópticas o electrónicas. Esto permite que los programas y documentos permanezcan disponibles a largo plazo.
						
						El acceso a los datos puede realizarse de manera secuencial o aleatoria. El acceso secuencial implica recorrer los datos en orden, como ocurre en cintas magnéticas, mientras que el acceso aleatorio permite recuperar cualquier dato directamente mediante su dirección, como en los discos modernos. La eficiencia del acceso influye en el rendimiento del sistema, especialmente en aplicaciones que requieren grandes volúmenes de lectura y escritura.
						
						Finalmente, los mecanismos de persistencia y acceso se integran mediante sistemas de archivos, que organizan la información en directorios, bloques y metadatos. Estos sistemas, gestionados por el sistema operativo, garantizan integridad, seguridad y recuperación ante fallos. La correcta comprensión de estos mecanismos es esencial para el diseño de aplicaciones que gestionen datos de manera segura y eficiente.
						
			\section{La computadora como sistema}
			% Hardware básico, software, modelo de ejecución de un programa.
				Una computadora puede entenderse como un sistema compuesto por elementos interrelacionados que trabajan de manera coordinada para procesar información. Según \cite{Gaddis2022Starting}, este sistema incluye la unidad central de procesamiento (CPU), la memoria principal, los dispositivos de almacenamiento, los dispositivos de entrada y salida, y el software que gestiona la interacción entre los componentes. La computadora opera bajo un modelo secuencial de ejecución que permite transformar datos en resultados útiles para el usuario.
				
				\subsection{Arquitectura básica}
					La arquitectura básica de una computadora se fundamenta en el modelo de Von Neumann, que establece que tanto los datos como las instrucciones se almacenan en la misma memoria. Este enfoque permite que el procesador obtenga instrucciones y datos desde ubicaciones similares, simplificando el diseño del hardware. Los elementos principales incluyen la unidad de control, la unidad aritmético-lógica (ALU), los registros internos y la memoria principal.
					
					En los textos de fundamentos de computación \cite{BhattComputer}, se establece que la CPU coordina todas las operaciones, mientras que la memoria sirve como espacio temporal para guardar instrucciones y datos que están siendo procesados. Los dispositivos de entrada permiten introducir datos al sistema y los dispositivos de salida permiten presentar resultados en forma visual, auditiva o impresa. Esta estructura modular facilita la expansión del sistema mediante nuevos dispositivos o componentes.
					
					Finalmente, la arquitectura básica contempla buses que interconectan los componentes principales. El bus de direcciones especifica dónde se encuentran los datos, el bus de datos transporta la información y el bus de control coordina las señales necesarias para ejecutar operaciones. Estos elementos garantizan la integridad y sincronización del sistema.
					
					\subsubsection{CPU y unidad de control}
						La Unidad Central de Procesamiento (CPU) es el componente encargado de ejecutar instrucciones y coordinar las operaciones del sistema. Según \cite{Gaddis2022Starting}, la CPU se compone principalmente de la unidad de control y la unidad aritmético-lógica (ALU). La unidad de control interpreta las instrucciones del programa, genera señales de control y dirige el flujo de datos dentro del sistema. Esta unidad determina qué operación debe realizarse en cada ciclo y qué componentes deben activarse.
						
						La ALU, por su parte, realiza operaciones aritméticas como suma, resta, multiplicación y división, así como operaciones lógicas como comparación, conjunción y disyunción. Estas operaciones permiten que los programas ejecuten cálculos, evaluaciones de condiciones y manipulación de datos. La ALU trabaja estrechamente con los registros internos, que almacenan valores temporales necesarios para las operaciones.
						
						Los registros son pequeñas ubicaciones de memoria extremadamente rápidas que permiten guardar direcciones, resultados intermedios e instrucciones. Entre ellos destacan el contador de programa (PC), que indica la siguiente instrucción a ejecutar, y el registro de instrucción (IR), que almacena la instrucción actual. Estos componentes permiten que el ciclo de ejecución se realice de manera eficiente.
						
						Finalmente, la CPU ejecuta el ciclo de \emph{fetch–decode–execute}, descrito ampliamente en la literatura \cite{Gaddis2022Starting}. En este ciclo, la CPU obtiene una instrucción desde memoria, la decodifica para determinar la operación requerida y luego la ejecuta. Este proceso se repite miles de millones de veces por segundo en los procesadores modernos.
						
					\subsubsection{Memoria principal}
						La memoria principal, conocida como RAM, almacena temporalmente los programas y datos que se encuentran en ejecución. Según \cite{Gaddis2022Starting}, la RAM es volátil, lo que implica que su contenido se pierde cuando el sistema se apaga. Su principal ventaja es la rapidez de acceso, ya que permite que la CPU lea y escriba datos de manera casi instantánea.
						
						La memoria se organiza en celdas numeradas mediante direcciones, lo que permite recuperar datos específicos de manera eficiente. Cada celda almacena un byte y varias celdas pueden combinarse para representar valores más grandes. Esta organización facilita la ejecución de programas complejos que requieren acceso frecuente a diferentes porciones de memoria.
						
						Por último, la capacidad y velocidad de la memoria influyen directamente en el rendimiento del sistema. Sistemas con mayor cantidad de RAM pueden ejecutar múltiples programas de manera simultánea y manejar conjuntos de datos más extensos. Por ello, la memoria es un componente crítico para aplicaciones científicas, empresariales y multimedia.
						
					\subsubsection{Dispositivos de entrada y salida}
						Los dispositivos de entrada permiten que el usuario o un entorno externo introduzcan datos en el sistema computacional; estos mecanismos incluyen teclados, ratones, escáneres, micrófonos y sensores especializados, cuya función es convertir fenómenos físicos en señales digitales interpretables por el procesador \cite{Stallings2021Computer}. Cada dispositivo transforma información analógica o simbólica en datos binarios, asegurando que pueda ser procesada según el modelo de arquitectura de Von Neumann \cite{Tanenbaum2021Structured}.
						
						Por otro lado, los dispositivos de salida presentan información procesada al usuario en formatos visuales, impresos o auditivos. Pantallas, impresoras y proyectores traducen los resultados binarios en representaciones comprensibles mediante controladores especializados que ejecutan rutinas en coordinación con el sistema operativo \cite{Silberschatz2018Operating}. La correcta operación de estos dispositivos depende de un flujo continuo entre CPU, memoria y buses, conforme describen los modelos clásicos de organización computacional \cite{Stallings2021Computer}.
						
						Asimismo, muchos dispositivos cumplen funciones mixtas, como discos, memorias USB o redes, que pueden actuar simultáneamente como entrada y salida al transferir datos entre sistemas mediante protocolos estandarizados \cite{Tanenbaum2024Modern}. Esta característica permite la interoperabilidad y soporta sistemas distribuidos en los que la información fluye de manera bidireccional.
						
					\subsubsection{Almacenamiento}
						El almacenamiento secundario conserva datos de forma persistente aun cuando el sistema pierde energía, a diferencia de la memoria principal que es volátil \cite{Gaddis2022Starting}. Discos duros, unidades de estado sólido y memorias flash emplean tecnologías magnéticas, electrónicas u ópticas para asegurar la retención de la información, siguiendo estándares como SATA, NVMe o USB \cite{Stallings2021Computer}. La capacidad de almacenamiento y su velocidad influyen directamente en el rendimiento de sistemas de información, especialmente en aplicaciones de alta demanda como bases de datos o sistemas transaccionales \cite{Sommerville2015Software}.
						
						Los modelos de dispositivos descritos en la literatura señalan que el acceso puede ser secuencial ―como en cintas magnéticas― o aleatorio, como en los discos modernos, lo que permite recuperar cualquier bloque de datos mediante su dirección física o lógica \cite{Tanenbaum2021Structured}. Esta característica posibilita algoritmos de entrada/salida eficientes y estructuras de almacenamiento optimizadas como árboles B o índices hash.
						
						Finalmente, los sistemas operativos gestionan el almacenamiento mediante sistemas de archivos, asignación de bloques, metadatos y mecanismos de journaling que permiten recuperar el estado del sistema después de fallos, tal como explican los textos canónicos de sistemas operativos \cite{Silberschatz2018Operating}.
						
				\subsection{Software del sistema y de aplicación}
					El software del sistema coordina los recursos computacionales y actúa como interfaz entre hardware y programas de usuario. Se compone principalmente del sistema operativo, controladores de dispositivos y utilidades que permiten gestionar procesos, memoria, almacenamiento y dispositivos externos \cite{Silberschatz2018Operating}. Este conjunto de programas es esencial para que el hardware opere según lo previsto y para que los programas de aplicación se ejecuten correctamente.
					
					Por su parte, el software de aplicación corresponde a programas diseñados para resolver necesidades específicas del usuario o de una organización. Procesadores de texto, hojas de cálculo, navegadores web y sistemas empresariales se incluyen en esta categoría, cada uno construido sobre abstracciones proporcionadas por el sistema operativo \cite{Sommerville2015Software}. La estructura modular del software moderno facilita su reutilización y mantenimiento mediante principios de ingeniería de software \cite{Pressman2019Software}.
					
					La correcta interacción entre software del sistema y software de aplicación permite que la computadora funcione como un sistema coherente capaz de ejecutar múltiples tareas y gestionar recursos de forma segura y eficiente \cite{Stallings2021Computer}.
					
					\subsubsection{Sistema operativo}
						El sistema operativo es el componente esencial del software del sistema. Sus funciones incluyen administrar procesos, asignar memoria, controlar dispositivos, gestionar almacenamiento, proporcionar seguridad y ofrecer una interfaz entre el usuario y el hardware \cite{Silberschatz2018Operating}. Sistemas ampliamente difundidos como Windows, Linux y macOS implementan estas funciones mediante arquitecturas de núcleo monolítico, híbrido o microkernel, cada una con ventajas particulares en rendimiento y modularidad \cite{Tanenbaum2021Structured}.
						
						Una tarea crítica del sistema operativo es el manejo de procesos, donde se administra su creación, suspensión, sincronización y terminación. Esta gestión se realiza mediante algoritmos de planificación como Round Robin, SJF o prioridades, los cuales determinan cómo se asigna el CPU a las tareas \cite{Stallings2021Computer}. 
						
						Asimismo, el sistema operativo gestiona el almacenamiento secundario mediante sistemas de archivos como NTFS, ext4 o APFS, asegurando integridad, eficiencia y control de acceso \cite{Silberschatz2018Operating}. Cada uno utiliza estructuras diferentes para organizar directorios, bloques y metadatos, lo que afecta directamente el rendimiento del sistema.
						
					\subsubsection{Programas utilitarios}
						Los programas utilitarios realizan tareas especializadas que complementan las funciones del sistema operativo. Entre estas herramientas destacan los programas de compresión, antivirus, software de respaldo y herramientas de diagnóstico, que permiten optimizar el rendimiento y proteger la integridad del sistema \cite{Pressman2019Software}. A diferencia de las aplicaciones generales, los utilitarios se centran en tareas específicas de mantenimiento o soporte técnico.
						
						Por ejemplo, los programas antivirus analizan patrones de código y comportamientos sospechosos mediante bases de datos actualizadas según modelos de detección descritos en la literatura de seguridad informática \cite{Stallings2021Computer}. Igualmente, las herramientas de respaldo generan copias de seguridad periódicas para prevenir la pérdida de datos, siguiendo políticas de retención y estrategias como incremental, diferencial o completa \cite{Sommerville2015Software}.
						
					\subsubsection{Aplicaciones orientadas a negocio}
						Las aplicaciones orientadas a negocio permiten automatizar procesos empresariales tales como contabilidad, ventas, logística, recursos humanos y gestión de clientes. Estas aplicaciones se diseñan a partir de modelos de procesos de negocio y requisitos de usuario definidos mediante metodologías de ingeniería de software \cite{Pressman2019Software}. Su arquitectura puede incluir módulos integrados, bases de datos relacionales y servicios distribuidos que garantizan consistencia e interoperabilidad.
						
						Ejemplos comunes incluyen sistemas ERP, CRM y plataformas de comercio electrónico, que integran datos y procesos en una estructura centralizada gestionada por un motor transaccional \cite{Sommerville2015Software}. Estas aplicaciones implementan reglas de negocio específicas que permiten controlar flujos de trabajo, validar transacciones y generar reportes estratégicos.
						
						El éxito de estas aplicaciones depende de su alineación con los objetivos organizacionales y de su capacidad para adaptarse a cambios en el entorno empresarial. La literatura enfatiza que la mantenibilidad, escalabilidad y seguridad del software son elementos decisivos para su adopción efectiva \cite{Pressman2019Software}.
						
				\subsection{Modelo de ejecución de un programa}
					El modelo de ejecución de un programa describe cómo la CPU obtiene instrucciones, las interpreta y las ejecuta según el ciclo de instrucción, un concepto fundamental en arquitectura computacional \cite{Tanenbaum2021Structured}. Toda ejecución comienza con la carga del programa en memoria principal, proceso gestionado por el sistema operativo mediante rutinas de asignación de memoria y creación de procesos \cite{Silberschatz2018Operating}. Esta estructura garantiza que cada programa cuente con un espacio de direcciones protegido, propiedad descrita ampliamente en los modelos de gestión de memoria \cite{Stallings2021Computer}.
					
					Durante la ejecución, la CPU sigue el ciclo clásico \emph{fetch–decode–execute}, en el cual el contador de programa indica la dirección de la siguiente instrucción a recuperar \cite{Gaddis2022Starting}. Posteriormente, la instrucción se decodifica mediante la unidad de control, responsable de interpretar los códigos de operación definidos por la arquitectura del procesador \cite{Stallings2021Computer}. Finalmente, la ALU o las unidades especializadas ejecutan la operación solicitada, ya sea aritmética, lógica o de transferencia de datos, siguiendo el conjunto de instrucciones documentado en microarquitecturas modernas \cite{Tanenbaum2021Structured}.
					
					Además, los sistemas operativos gestionan el estado del programa mediante contextos de ejecución que incluyen registros, pila, contador de programa y tabla de páginas \cite{Silberschatz2018Operating}. Esto permite suspender y reanudar procesos, facilitando la multitarea y la ejecución concurrente. En sistemas multiprocesador y multinúcleo, la planificación se distribuye para mejorar el rendimiento, conforme a las técnicas de escalamiento descritas por Sommerville \cite{Sommerville2015Software}.
					
					El correcto funcionamiento del modelo de ejecución depende de la integridad del código, del manejo adecuado de interrupciones y del uso eficiente de la jerarquía de memoria, cuya estructura se ha documentado de manera exhaustiva en la literatura de organización de computadores \cite{Stallings2021Computer}. Sin estos mecanismos, la ejecución confiable y segura sería imposible.
					
					\subsubsection{Etapas: código → compilación → ejecución}
						El proceso inicia con la escritura del código fuente en un lenguaje de alto nivel, el cual debe cumplir reglas sintácticas y semánticas documentadas por los lenguajes de programación \cite{Gaddis2022Starting}. Posteriormente, un compilador traduce dicho código a lenguaje máquina siguiendo análisis léxico, sintáctico y semántico, procesos descritos por los compiladores clásicos como los de Aho, Sethi y Ullman \cite{Tanenbaum2021Structured}. Esta traducción genera archivos objeto que contienen instrucciones binarias alineadas con la arquitectura del procesador \cite{Stallings2021Computer}.
						
						Durante la fase de enlace, los módulos compilados se integran con bibliotecas y rutinas del sistema para producir un ejecutable, siguiendo las especificaciones del sistema operativo \cite{Silberschatz2018Operating}. Cuando el usuario solicita la ejecución, el cargador (\emph{loader}) ubica el ejecutable en memoria, prepara el contexto inicial del proceso y transfiere el control a la primera instrucción, conforme a los mecanismos descritos por Stallings \cite{Stallings2021Computer}.
						
						Finalmente, el programa se ejecuta dentro del modelo de multitarea del sistema operativo, donde los planificadores asignan tiempo de CPU según algoritmos como Round Robin, prioridades o planificación multinivel \cite{Silberschatz2018Operating}. Este flujo garantiza portabilidad, seguridad y desempeño, objetivos centrales en ingeniería de software \cite{Pressman2019Software}.
						
					\subsubsection{Gestión de memoria y procesos}
						La gestión de memoria es una función crítica del sistema operativo y permite asignar, proteger y liberar espacio para programas en ejecución \cite{Silberschatz2018Operating}. Técnicas como segmentación, paginación y memoria virtual posibilitan que los programas utilicen más memoria de la disponible físicamente, simulando un espacio unificado mediante tablas de páginas y mecanismos de intercambio (\emph{paging}) \cite{Stallings2021Computer}. Estos métodos aseguran aislamiento entre procesos, propiedad fundamental para la seguridad del sistema \cite{Tanenbaum2021Structured}.
						
						Por otra parte, la gestión de procesos controla su creación, suspensión y finalización mediante estructuras como PCB (\emph{Process Control Block}), que almacenan estados de ejecución, registros, contadores de programa y descriptores de memoria \cite{Silberschatz2018Operating}. Este control permite que múltiples programas coexistan de manera eficiente mediante planificación distribuida, un principio documentado en sistemas multiprocesador \cite{Stallings2021Computer}.
						
						La sincronización entre procesos se implementa mediante semáforos, monitores o exclusión mutua, mecanismos ampliamente estudiados en los problemas clásicos de concurrencia \cite{Tanenbaum2021Structured}. Sin estas herramientas, los procesos podrían interferir entre sí, produciendo condiciones de carrera, interbloqueos o inconsistencias lógicas.
						
			\section{Representación de la información en la computadora}
			% Bit, byte, sistemas de numeración, representación de enteros, reales,caracteres y valores lógicos.
				La representación de la información en una computadora se basa en estructuras binarias gestionadas por el hardware, donde todo dato —números, caracteres, colores, sonidos o instrucciones— se codifica mediante patrones de bits que siguen reglas específicas para cada tipo de información \cite{Tanenbaum2021Structured,Stallings2021Computer}. Estos patrones binarios deben ser interpretados por la arquitectura del computador, que define tamaños de palabra, formatos de almacenamiento, esquemas de direccionamiento y mecanismos de manipulación, garantizando que la información pueda procesarse con precisión y eficiencia \cite{Sommerville2015Software,Pressman2019Software}.
				
				\subsection{Unidades de información}
					Las unidades fundamentales para representar información en un sistema digital son el bit, el byte y la palabra, cada una con funciones específicas dentro de la arquitectura del computador \cite{Tanenbaum2021Structured}. Un bit (\emph{binary digit}) es la unidad mínima de información, capaz de representar dos estados: 0 y 1, utilizados para modelar valores lógicos, señales electrónicas y condiciones booleanas \cite{Stallings2021Computer}. Los bits son la base para cualquier codificación, y su combinación permite expresar cantidades más complejas. Por ejemplo, el patrón binario \texttt{1011} representa el número decimal 11 \cite{Gaddis2022Starting}.
					
					El byte está compuesto por 8 bits y constituye la unidad estándar para representar caracteres, pequeñas cantidades de datos y direcciones básicas de memoria \cite{Stallings2021Computer}. Muchos sistemas contemporáneos consideran la palabra como una unidad compuesta por 16, 32 o 64 bits, dependiendo de la arquitectura, lo que determina la cantidad de datos que la CPU puede procesar en una única operación \cite{Tanenbaum2021Structured}. Por ejemplo, en arquitecturas de 64 bits, un entero con precisión estándar se almacena típicamente en una palabra de 64 bits, lo que permite representar un rango numérico significativamente mayor que en arquitecturas de 32 bits \cite{Pressman2019Software}.
					
					% Figura TikZ: representación visual de bit, byte y palabra
					\begin{figure}[hbt!]
						\centering
						\begin{tikzpicture}[
							font=\small,
							bit/.style={draw, minimum width=7mm, minimum height=7mm, fill=blue!10},
							byte/.style={draw, minimum width=7mm, minimum height=7mm, fill=green!10},
							word/.style={draw, minimum width=7mm, minimum height=7mm, fill=orange!15},
							node distance=2mm
							]
							
							% Bits
							\node at (0,0) {\textbf{Bit}};
							\foreach \i in {1}
							\node[bit] (bit\i) at (\i*1.0, -0.8) {0/1};
							
							% Byte
							\node at (6,0) {\textbf{Byte = 8 bits}};
							\foreach \i in {1,...,8}
							\node[byte] (b\i) at (3.5+\i*0.8, -0.8) {\tiny \i};
							
							% Word
							\node at (14,0) {\textbf{Palabra = 32/64 bits}};
							\foreach \i in {1,...,8}
							\node[word] (w\i) at (11+\i*0.8, -0.8) {};
						\end{tikzpicture}
						\caption{Representación de bit, byte y palabra en niveles crecientes de agrupación \cite{Tanenbaum2021Structured,Stallings2021Computer}.}
						\label{fig:bit-byte-palabra}
					\end{figure}
					
					\subsubsection{Bit, byte y palabra}
						El bit es la unidad más elemental de información digital y sirve como base para la representación de todos los datos en la computadora \cite{Stallings2021Computer}. Su estado puede modelar fenómenos físicos como presencia o ausencia de corriente, polaridad magnética o niveles de voltaje, dependiendo de la tecnología de hardware empleada \cite{Tanenbaum2021Structured}. Debido a su simplicidad y capacidad de combinación, los bits son elementos fundamentales para estructuras más complejas como registros, instrucciones y formatos multimedia \cite{Sommerville2015Software}.
						
						El byte, compuesto por 8 bits, permite representar 256 combinaciones distintas (de 0 a 255 en decimal), siendo suficiente para codificar caracteres según estándares como ASCII o para representar colores básicos en modelos RGB \cite{Gaddis2022Starting}. Por ejemplo, el carácter `'A'` corresponde al valor decimal 65, cuyo equivalente binario es \texttt{01000001} \cite{Stallings2021Computer}. El byte constituye una frontera natural para el direccionamiento de memoria en la mayoría de arquitecturas modernas \cite{Tanenbaum2021Structured}.
						
						La palabra, que puede ser de 16, 32 o 64 bits según la arquitectura, determina el ancho del bus de datos, el tamaño de los registros de la CPU y la cantidad de información que puede manipularse en una sola operación \cite{Stallings2021Computer}. Por ejemplo, una palabra de 32 bits permite representar enteros hasta aproximadamente \(2^{31}-1\), mientras que una palabra de 64 bits incrementa ese límite a \(2^{63}-1\) \cite{Tanenbaum2021Structured}. Esta diferencia tiene impacto directo en el rendimiento y en la capacidad de direccionamiento del sistema \cite{Pressman2019Software}.
						
					\subsubsection{Concepto de dirección de memoria}
						Una dirección de memoria es un identificador numérico que permite localizar un byte específico dentro del espacio de memoria del sistema \cite{Tanenbaum2021Structured}. Por ejemplo, si un arreglo comienza en la dirección \texttt{1000}, y cada elemento ocupa 4 bytes, entonces el quinto elemento se ubicará en la dirección \texttt{1000 + 4 * 4 = 1016} \cite{Stallings2021Computer}. Este mecanismo de direccionamiento secuencial es esencial para el acceso eficiente a estructuras de datos y para la implementación de punteros en lenguajes como C o C++ \cite{Pressman2019Software}.
						
						% Figura TikZ: memoria y direccionamiento
						\begin{figure}[hbt!]
							\centering
							\begin{tikzpicture}[
								font=\small,
								mem/.style={draw, minimum width=14mm, minimum height=7mm, fill=gray!10},
								node distance=1mm
								]
								
								\foreach \i/\addr in {0/1000,1/1004,2/1008,3/1012,4/1016} {
									\node[mem] (m\i) at (0, -\i*1.0) {\tiny Valor};
									\node[right=4mm of m\i] {\tiny Dir=\addr};
								}
							\end{tikzpicture}
							\caption{Direccionamiento secuencial en memoria para un arreglo de enteros de 4 bytes \cite{Tanenbaum2021Structured,Stallings2021Computer}.}
							\label{fig:direccionamiento}
						\end{figure}
						
				\subsection{Sistemas de numeración}
					Los sistemas de numeración permiten representar valores de forma simbólica según una base o radix que determina el número de dígitos disponibles \cite{Stallings2021Computer}. En informática, los sistemas más utilizados son el decimal (base 10), el binario (base 2) y el hexadecimal (base 16), siendo el binario el utilizado internamente por las computadoras debido a su compatibilidad con circuitos digitales basados en dos estados \cite{Tanenbaum2021Structured}. Comprender estos sistemas es fundamental para interpretar direcciones de memoria, códigos de instrucción y formatos internos de datos \cite{Sommerville2015Software}.
					
					La conversión entre sistemas numéricos constituye una habilidad esencial en programación y arquitectura de computadoras \cite{Gaddis2022Starting}. Por ejemplo, el número decimal 25 corresponde a \texttt{11001} en binario, y a \texttt{19} en hexadecimal \cite{Stallings2021Computer}. Estas conversiones permiten interpretar adecuadamente valores internos y depurar programas que manipulan niveles bajos de representación \cite{Tanenbaum2021Structured}.
					
					\subsubsection{Decimal}
						El sistema decimal, basado en diez símbolos (0–9), tiene sus raíces históricas en civilizaciones antiguas como los hindúes, quienes desarrollaron el concepto de valor posicional que luego sería difundido por los árabes hacia Occidente \cite{Stallings2021Computer}. Este sistema utiliza potencias de 10 para determinar el valor de cada dígito según su posición, propiedad que facilita la representación de cantidades grandes y la enseñanza matemática \cite{Tanenbaum2021Structured}. Su uso extendido en la vida cotidiana lo convierte en el sistema principal para la interacción humano–computadora \cite{Sommerville2015Software}.
						
						En programación, los valores numéricos suelen ingresarse y mostrarse en decimal para facilitar su comprensión, aunque internamente se almacenen en binario \cite{Gaddis2022Starting}. Por ejemplo, el número decimal 47 se interpreta como \(4\times 10^1 + 7\times 10^0\) \cite{Stallings2021Computer}. Esta interpretación posicional es la base para convertir números decimales a otras bases \cite{Tanenbaum2021Structured}.
						
						La literatura destaca que, aunque el decimal no se utilice internamente para cálculos en hardware, comprender su relación con el binario y el hexadecimal es esencial para interpretar conversiones, depurar programas y trabajar con formatos de datos multinivel \cite{Pressman2019Software}. Esta comprensión también es importante para representar cantidades en sistemas financieros, científicos y estadísticos \cite{Sommerville2015Software}.
						
					\subsubsection{Binario}
						El sistema binario utiliza dos dígitos (0 y 1), lo que lo hace ideal para representar estados físicos de circuitos digitales \cite{Stallings2021Computer}. Cada posición de un número binario representa una potencia de 2, de modo que el valor de un número binario se obtiene sumando las potencias correspondientes a los dígitos 1 presentes \cite{Tanenbaum2021Structured}. Por ejemplo, \texttt{10110} equivale a \(1\times16 + 0\times8 + 1\times4 + 1\times2 + 0\times1 = 22\) en decimal \cite{Gaddis2022Starting}.
						
						La conversión de decimal a binario puede hacerse mediante divisiones sucesivas entre 2, registrando los residuos, mientras que la conversión inversa se basa en expansiones posicionales \cite{Sommerville2015Software}. Por ejemplo, para convertir el decimal 13 a binario: 13/2=6 r1, 6/2=3 r0, 3/2=1 r1, 1/2=0 r1, obteniendo \texttt{1101} al leer los residuos en orden inverso \cite{Stallings2021Computer}. Este método permite comprender la relación entre valores y representaciones digitales \cite{Tanenbaum2021Structured}.
						
						El binario se utiliza ampliamente para representar contenido computacional como máscaras de bits, permisos, colores, direcciones de memoria y códigos máquina \cite{Pressman2019Software}. Asimismo, la representación de enteros con signo (complemento a dos), números reales (IEEE 754) y caracteres (ASCII, Unicode) utiliza internamente formatos binarios específicos \cite{Sommerville2015Software}. Por ello, el dominio del sistema binario es esencial para cualquier profesional de computación \cite{Stallings2021Computer}.
						
						% Figura TikZ: conversión de decimal a binario
						\begin{figure}[hbt!]
							\centering
							\begin{tikzpicture}[
								font=\small,
								box/.style={draw, rounded corners=3pt, thick, fill=blue!5, minimum width=18mm},
								arrow/.style={->, thick}
								]
								\node[box] (a) {13};
								\node[box, below=4mm of a] (b) {13 / 2 = 6 r 1};
								\node[box, below=4mm of b] (c) {6 / 2 = 3 r 0};
								\node[box, below=4mm of c] (d) {3 / 2 = 1 r 1};
								\node[box, below=4mm of d] (e) {1 / 2 = 0 r 1};
								\node[box, right=25mm of c] (result) {\textbf{1101}};
								\draw[arrow] (a) -- (b);
								\draw[arrow] (b) -- (c);
								\draw[arrow] (c) -- (d);
								\draw[arrow] (d) -- (e);
								\draw[arrow] (e) -- (result);
							\end{tikzpicture}
							\caption{Conversión de número decimal a binario mediante divisiones sucesivas \cite{Stallings2021Computer}.}
							\label{fig:conv-binario}
						\end{figure}
							
					\subsubsection{Hexadecimal}
						El sistema hexadecimal utiliza dieciséis símbolos (0–9 y A–F), lo que permite representar grandes valores en pocas posiciones y facilita la lectura de patrones binarios \cite{Stallings2021Computer}. Cada dígito hexadecimal equivale exactamente a 4 bits, lo que permite convertir entre hexadecimal y binario agrupando bits en conjuntos de cuatro \cite{Tanenbaum2021Structured}. Por ejemplo, \texttt{A3} equivale a \texttt{1010 0011} en binario \cite{Gaddis2022Starting}.
						
						La conversión de hexadecimal a decimal se basa en potencias de 16. Por ejemplo, \texttt{2F} equivale a \(2 \times 16^1 + 15 \times 16^0 = 47\) \cite{Stallings2021Computer}. De binario a hexadecimal, basta agrupar los bits en grupos de cuatro desde la derecha; por ejemplo, \texttt{11010111} se agrupa como \texttt{1101 0111}, que corresponde a \texttt{D7} \cite{Tanenbaum2021Structured}. Esta correspondencia directa simplifica tareas de depuración y análisis de memoria \cite{Sommerville2015Software}.
						
						La conversión de decimal a hexadecimal puede realizarse mediante divisiones sucesivas entre 16. Por ejemplo, para convertir 254: 254/16=15 r 14; así \(15=F\), \(14=E\), lo que produce \texttt{FE} \cite{Stallings2021Computer}. La representación hexadecimal se emplea ampliamente en direcciones de memoria, códigos de color, instrucciones máquina y formatos binarios \cite{Pressman2019Software}.
						
						% Figura TikZ: Conversión entre binario y hexadecimal
						\begin{figure}[hbt!]
							\centering
							\begin{tikzpicture}[
								font=\small,
								hex/.style={draw, rounded corners=3pt, thick, fill=green!15, minimum width=8mm},
								bin/.style={draw, thick, fill=blue!10, minimum width=8mm},
								arrow/.style={->, thick}
								]
								
								\node at (0,0) {\textbf{Hexadecimal}};
								\node[hex] (h1) at (0,-0.8) {A};
								\node[hex] (h2) at (1,-0.8) {3};
								
								\node at (0,-2.2) {\textbf{Binario}};
								\foreach \i/\v in {1/1010, 2/0011}{
									\node[bin] (b\i) at (\i*1.0 -1.0, -3.0) {\v};
								}
								
								\draw[arrow] (h1.south) -- (b1.north);
								\draw[arrow] (h2.south) -- (b2.north);
							\end{tikzpicture}
							\caption{Conversión directa entre hexadecimal y binario agrupando bits en conjuntos de 4 \cite{Tanenbaum2021Structured,Stallings2021Computer}.}
							\label{fig:conv-hex}
						\end{figure}
						
				\subsection{Representación de tipos básicos}
					Los tipos básicos de datos constituyen las unidades fundamentales para la representación y manipulación de información en los programas, y su codificación está estrechamente vinculada con la arquitectura del computador y los estándares internacionales de representación binaria \cite{Tanenbaum2021Structured}. Entre los tipos elementales se incluyen los enteros, los números reales, los caracteres y los valores lógicos, cada uno con reglas de codificación específicas que determinan su rango, precisión y comportamiento ante operaciones aritméticas y lógicas \cite{Stallings2021Computer}. Comprender estos formatos es esencial para evitar errores sutiles como desbordamientos, pérdidas de precisión o resultados inesperados en comparaciones \cite{Sommerville2015Software}.
					
					La representación interna de estos tipos se fundamenta en configuraciones binarias interpretadas bajo convenciones establecidas, como el complemento a dos para enteros con signo, el estándar IEEE 754 para números reales y los códigos ASCII o Unicode para caracteres \cite{Pressman2019Software}. Esta organización permite que las computadoras procesen información de forma uniforme, garantizando compatibilidad entre plataformas y lenguajes de programación \cite{Gaddis2022Starting}. El dominio de estas representaciones facilita el uso correcto de los tipos y promueve la escritura de programas más fiables y eficientes \cite{Sommerville2015Software}.
					
					\subsubsection{Enteros}
						Los enteros pueden representarse en formato sin signo o con signo, siendo este último manejado con frecuencia mediante el método de complemento a dos, que permite operar con valores negativos utilizando aritmética binaria estándar \cite{Stallings2021Computer}. En un entero de 8 bits con complemento a dos, el rango va de –128 a 127, y el bit más significativo actúa como bit de signo \cite{Tanenbaum2021Structured}. Por ejemplo, el valor decimal –5 se representa como \texttt{11111011} en complemento a dos \cite{Gaddis2022Starting}.
						
						El complemento a dos simplifica el hardware al permitir que la suma y la resta se realicen de la misma manera tanto para números positivos como negativos \cite{Stallings2021Computer}. Para obtener el complemento a dos de un número, se invierten sus bits y se suma uno. Así, el valor binario de 5 (\texttt{00000101}) se invierte (\texttt{11111010}) y se suma uno (\texttt{11111011}), obteniéndose la representación de –5 \cite{Tanenbaum2021Structured}. Este método evita las ambigüedades inherentes a otras formas de representar números negativos \cite{Sommerville2015Software}.
						
						Los enteros también pueden causar desbordamientos cuando el valor resultante de una operación supera la capacidad del tipo. Por ejemplo, sumar 1 al valor máximo en un entero de 8 bits (\texttt{01111111} = 127) produce un desbordamiento que genera \texttt{10000000}, interpretado como –128 en complemento a dos \cite{Stallings2021Computer}. Comprender estos comportamientos es esencial para escribir programas seguros y confiables \cite{Pressman2019Software}.
						
						% Figura TikZ: Enteros en complemento a dos
						\begin{figure}[hbt!]
							\centering
							\begin{tikzpicture}[
								font=\small,
								bit/.style={draw, minimum width=6mm, minimum height=6mm, fill=blue!10},
								labelstyle/.style={font=\scriptsize}
								]
								\node at (0,0.5) {\textbf{Representación de -5 en complemento a dos (8 bits)}};
								
								\foreach \i/\b in {1/1,2/1,3/1,4/1,5/1,6/0,7/1,8/1} {
									\node[bit] (b\i) at (\i*0.7,0) {\b};
								}
								
								\node[labelstyle, below=2mm of b4] {Bit de signo};
							\end{tikzpicture}
							\caption{Representación de enteros con signo mediante complemento a dos \cite{Tanenbaum2021Structured,Stallings2021Computer}.}
							\label{fig:comp2}
						\end{figure}
							
					\subsubsection{Reales y precisión}
						Los números reales se representan habitualmente mediante el estándar IEEE 754, que utiliza una estructura de punto flotante compuesta por tres campos: signo, exponente y mantisa \cite{Stallings2021Computer}. En precisión simple (32 bits), estos campos ocupan 1 bit, 8 bits y 23 bits respectivamente, lo que permite representar un amplio rango de valores con distintos niveles de precisión \cite{Tanenbaum2021Structured}. La normalización de la mantisa y el sesgo del exponente son aspectos clave en esta representación \cite{Sommerville2015Software}.
						
						La precisión limitada provoca que algunos números no puedan representarse exactamente. Por ejemplo, valores como 0.1 o 0.2 no tienen una representación binaria finita, lo que genera errores acumulativos cuando se realizan sumas sucesivas \cite{Pressman2019Software}. Esto explica por qué en algunos lenguajes una expresión como \texttt{0.1 + 0.2} produce resultados como \texttt{0.30000000000000004} en lugar de 0.3 \cite{Gaddis2022Starting}. La falta de precisión debe considerarse al trabajar con cálculos sensibles o financieros \cite{Sommerville2015Software}.
						
						Los números IEEE 754 también incluyen valores especiales como \texttt{NaN} (Not a Number), \(\infty\), \(-\infty\) y cero positivo o negativo, utilizados para representar desbordamientos, divisiones por cero o resultados indefinidos \cite{Stallings2021Computer}. Estos valores tienen patrones binarios específicos para distinguirlos de números normales y subnormales \cite{Tanenbaum2021Structured}. Comprender estas particularidades es fundamental para evitar errores de cálculo y comportamientos inesperados \cite{Pressman2019Software}.
						
						% Figura TikZ: Formato IEEE 754 de 32 bits
						\begin{figure}[hbt!]
							\centering
							\begin{tikzpicture}[
								font=\small,
								field/.style={draw, minimum height=10mm},
								sign/.style={field, fill=red!15, minimum width=10mm},
								exp/.style={field, fill=green!15, minimum width=25mm},
								mant/.style={field, fill=blue!15, minimum width=70mm}
								]
								\node at (0,1.2) {\textbf{IEEE 754 (32 bits)}};
								
								\node[sign] (s) at (0,0) {Signo (1)};
								\node[exp, right=0mm of s] (e) {Exponente (8)};
								\node[mant, right=0mm of e] (m) {Mantisa (23)};
							\end{tikzpicture}
							\caption{Distribución de campos en el formato IEEE 754 de precisión simple \cite{Stallings2021Computer,Tanenbaum2021Structured}.}
							\label{fig:ieee754}
						\end{figure}
							
					\subsubsection{Caracteres (ASCII y Unicode)}
						Los caracteres se representan mediante códigos numéricos que asocian cada símbolo con un valor entero \cite{Stallings2021Computer}. ASCII es uno de los estándares más antiguos, utilizando 7 bits para representar 128 caracteres, incluyendo letras mayúsculas y minúsculas, dígitos y signos de puntuación \cite{Tanenbaum2021Structured}. Por ejemplo, la letra `'A'` se codifica como 65 (\texttt{01000001}) y `'a'` como 97 (\texttt{01100001}) \cite{Gaddis2022Starting}. Aunque limitado, ASCII sigue siendo ampliamente utilizado por su simplicidad.
						
						Unicode surgió para superar las restricciones de ASCII y permitir la representación de caracteres de todos los idiomas, símbolos técnicos, emojis y más \cite{Sommerville2015Software}. El estándar Unicode asigna un punto de código único a cada carácter, que puede codificarse mediante formatos como UTF-8, UTF-16 o UTF-32 \cite{Stallings2021Computer}. Por ejemplo, el carácter `'ñ'` tiene punto de código U+00F1, que en UTF-8 se representa como \texttt{C3 B1} \cite{Tanenbaum2021Structured}.
						
						La coexistencia de ASCII y Unicode implica que algunos caracteres tienen equivalencias directas en ambas codificaciones, mientras que otros existen únicamente en Unicode \cite{Pressman2019Software}. Por ejemplo, el carácter `'A'` mantiene el mismo valor en ASCII y UTF-8, mientras que `'ñ'` y miles de otros caracteres no pueden representarse en ASCII \cite{Sommerville2015Software}. Esto hace que la elección del formato de codificación sea crucial en aplicaciones multilingües.
						
						% Figura TikZ: Comparación ASCII vs Unicode
						\begin{figure}[hbt!]
							\centering
							\begin{tikzpicture}[
								font=\small,
								codebox/.style={draw, rounded corners=3pt, fill=gray!10, minimum width=22mm, minimum height=8mm},
								arrow/.style={->, thick}
								]
								\node at (0,1) {\textbf{ASCII (7 bits)}};
								\node[codebox] (a1) at (0,0) {A = 65};
								
								\node at (5,1) {\textbf{Unicode / UTF-8}};
								\node[codebox] (u1) at (5,0) {A = 41};
								\node[codebox, below=5mm of u1] (u2) {ñ = C3 B1};
								
								\draw[arrow] (a1) -- (u1);
							\end{tikzpicture}
							\caption{Equivalencias entre ASCII y Unicode para caracteres comunes y extendidos \cite{Tanenbaum2021Structured,Stallings2021Computer}.}
							\label{fig:ascii-unicode}
						\end{figure}
						
					\subsubsection{Valores lógicos (booleanos)}
						Los valores lógicos representan estados booleanos verdaderos o falsos, fundamentales para el control del flujo de programas mediante estructuras como condicionales y bucles \cite{Gaddis2022Starting}. Internamente, suelen codificarse mediante un bit, utilizando 0 para falso y 1 para verdadero, aunque algunos lenguajes emplean representaciones más amplias por razones de alineación en memoria \cite{Stallings2021Computer}. Esta simplicidad permite implementar operadores lógicos de forma eficiente mediante compuertas digitales \cite{Tanenbaum2021Structured}.
						
						Los operadores lógicos como AND, OR y NOT se interpretan mediante reglas precisas definidas en la lógica booleana \cite{Stallings2021Computer}. Por ejemplo, la expresión \texttt{(x > 10) \&\& (y < 5)} sólo es verdadera cuando ambas condiciones se cumplen \cite{Gaddis2022Starting}. Los valores booleanos también se utilizan en máscaras de bits, activación de señales y condiciones de parada \cite{Sommerville2015Software}.
						
						Los booleanos pueden provocar errores cuando se confunden con enteros o cuando se aplican operaciones inadecuadas, como comparar directamente valores lógicos con números fuera del rango permitido \cite{Pressman2019Software}. Por ejemplo, en algunos lenguajes, cualquier valor distinto de cero se interpreta como verdadero, lo que puede generar confusión si no se utiliza una comparación explícita \cite{Sommerville2015Software}. Por ello, se recomienda utilizar variables booleanas específicas en lugar de valores numéricos en expresiones lógicas \cite{Stallings2021Computer}.
						
				\subsection{Implicaciones en programación}
					La forma en que se representan internamente los tipos básicos tiene implicaciones directas en el diseño, la corrección y el rendimiento de los programas \cite{Gaddis2022Starting}. El programador debe conocer los rangos de los tipos enteros, las limitaciones de precisión de los números en punto flotante, las codificaciones de caracteres y la semántica de los valores booleanos para evitar errores sutiles que no siempre son detectados por el compilador \cite{Tanenbaum2021Structured}. Una comprensión superficial de estos aspectos puede conducir a resultados incorrectos, desbordamientos silenciosos y comparaciones engañosas \cite{Stallings2021Computer}.
					
					Estas implicaciones se manifiestan especialmente en operaciones críticas como cálculos financieros, simulaciones científicas, algoritmos de control y evaluación de condiciones complejas \cite{Sommerville2015Software}. Por ejemplo, el uso inadecuado de un tipo de dato con rango insuficiente puede provocar fallos intermitentes que aparecen solo con determinados valores de entrada \cite{Pressman2019Software}. De manera análoga, la comparación directa de valores en punto flotante o la conversión implícita entre tipos puede introducir errores difíciles de depurar \cite{Stallings2021Computer}.
										
					\subsubsection{Desbordamientos}
						El desbordamiento ocurre cuando el resultado de una operación aritmética excede el rango que puede representar el tipo de dato utilizado \cite{Tanenbaum2021Structured}. En un entero con signo de 8 bits, el rango va de –128 a 127; si se intenta sumar 1 a 127, el resultado se desborda y se interpreta como –128 en complemento a dos \cite{Stallings2021Computer}. Este comportamiento es definido por la arquitectura y no suele generar errores de tiempo de ejecución, lo que complica su detección \cite{Gaddis2022Starting}.
						
						En muchos lenguajes de bajo nivel, como C o C++, el desbordamiento de enteros se considera comportamiento no definido o bien se produce sin advertencia, lo que puede dar lugar a vulnerabilidades de seguridad y resultados incorrectos \cite{Pressman2019Software}. Por ejemplo, contadores, índices de arreglos o acumuladores pueden sobrepasar su límite y producir accesos fuera de rango o datos incoherentes \cite{Sommerville2015Software}. En lenguajes de más alto nivel, algunas implementaciones generan excepciones o amplían dinámicamente la capacidad de representación, pero esto depende de la plataforma \cite{Stallings2021Computer}.
						
						Para mitigar el desbordamiento se recomienda validar los rangos antes de realizar operaciones críticas, utilizar tipos de mayor capacidad cuando se anticipan valores grandes y, en contextos de alto riesgo, recurrir a bibliotecas de aritmética de precisión arbitraria \cite{Pressman2019Software}. Asimismo, herramientas de análisis estático pueden detectar patrones de posible desbordamiento durante la fase de desarrollo \cite{Sommerville2015Software}. Estas estrategias contribuyen a la robustez y confiabilidad de los sistemas \cite{Stallings2021Computer}.
						
						% Figura TikZ: Ejemplo de desbordamiento en enteros de 8 bits
						\begin{figure}[hbt!]
							\centering
							\begin{tikzpicture}[
								font=\small,
								box/.style={draw, rounded corners=3pt, minimum width=24mm, minimum height=8mm, fill=gray!10},
								arrow/.style={->, thick}
								]
								\node[box] (max) {127 = 01111111};
								\node[box, right=20mm of max] (ovf) {-128 = 10000000};
								\node[below=2mm of max] {+ 1};
								
								\draw[arrow] (max) -- node[above]{suma} (ovf);
							\end{tikzpicture}
							\caption{Desbordamiento al sumar 1 al valor máximo en un entero con signo de 8 bits \cite{Tanenbaum2021Structured,Stallings2021Computer}.}
							\label{fig:overflow}
						\end{figure}
													
					\subsubsection{Errores de comparación}
						Los errores de comparación surgen cuando dos valores que deberían considerarse equivalentes no lo son desde el punto de vista de su representación interna, o cuando se emplean operadores relacionales de forma incorrecta \cite{Gaddis2022Starting}. Este fenómeno es especialmente frecuente con números en punto flotante, debido a los errores de redondeo introducidos por el estándar IEEE 754 \cite{Stallings2021Computer}. Por ejemplo, la expresión \texttt{0.1 + 0.2 == 0.3} puede evaluar a falso en muchos lenguajes, pese a la expectativa intuitiva de igualdad \cite{Tanenbaum2021Structured}.
						
						La literatura recomienda evitar las comparaciones directas de igualdad entre valores flotantes y, en su lugar, utilizar comparaciones con tolerancia, verificando si la diferencia absoluta entre dos valores es menor que un umbral pequeño (\(\epsilon\)) \cite{Sommerville2015Software}. Por ejemplo, resulta más seguro comprobar \texttt{|x - 0.3| < 1e-6} que utilizar \texttt{x == 0.3} \cite{Pressman2019Software}. Esta técnica reduce el impacto de los errores de representación y mejora la robustez de los programas numéricos \cite{Stallings2021Computer}.
						
						Los errores de comparación también pueden presentarse con cadenas de caracteres cuando existen diferencias invisibles, como espacios en blanco adicionales, mayúsculas y minúsculas o combinaciones Unicode equivalentes visualmente pero distintas internamente \cite{Stallings2021Computer}. Por ejemplo, la cadena `"café"` puede representarse de forma precompuesta o descompuesta en Unicode, lo que afecta el resultado de las comparaciones byte a byte \cite{Tanenbaum2021Structured}. Para mitigar estos problemas se recomienda normalizar cadenas y aplicar comparaciones que consideren reglas locales de mayúsculas y acentos \cite{Sommerville2015Software}.
						
						En lenguajes con punteros o referencias, otro error común es comparar direcciones de memoria en lugar del contenido al que apuntan \cite{Pressman2019Software}. Dos punteros pueden referirse a distintas ubicaciones que contengan valores iguales, pero la comparación de las direcciones devolverá falso \cite{Stallings2021Computer}. Por ello, se debe distinguir entre igualdad de referencias e igualdad de valores, utilizando las operaciones adecuadas según el lenguaje y el contexto \cite{Sommerville2015Software}.
						
						% Figura TikZ: Comparación flotante con y sin tolerancia
						\begin{figure}[hbt!]
							\centering
							\begin{tikzpicture}[
								font=\small,
								good/.style={draw, rounded corners=3pt, minimum width=40mm, minimum height=8mm, fill=green!15},
								bad/.style={draw, rounded corners=3pt, minimum width=40mm, minimum height=8mm, fill=red!15},
								arrow/.style={->, thick}
								]
								\node[bad] (eq) {\texttt{0.1 + 0.2 == 0.3}};
								\node[good, below=8mm of eq] (eps) {\texttt{fabs(x-0.3) < 1e-6}};
								
								\draw[arrow] (eq) -- node[right]{mejor práctica} (eps);
							\end{tikzpicture}
							\caption{Comparación directa vs. comparación con tolerancia en números en punto flotante \cite{Stallings2021Computer,Pressman2019Software}.}
							\label{fig:float-compare}
						\end{figure}
													
					\subsubsection{Pérdida de precisión}
						La pérdida de precisión ocurre cuando un valor no puede representarse exactamente con el número de bits disponible o cuando se convierte desde un tipo más preciso a otro menos preciso \cite{Stallings2021Computer}. Esto sucede con frecuencia al almacenar un número real con muchos decimales en un formato de precisión simple o al convertir un número de punto flotante a entero mediante truncamiento \cite{Tanenbaum2021Structured}. Por ejemplo, convertir 3.999 a entero puede producir 3 si se aplica truncamiento, aun cuando el valor esté muy próximo a 4 \cite{Gaddis2022Starting}.
						
						En cálculos acumulativos, pequeñas pérdidas de precisión pueden propagarse y amplificarse, afectando significativamente los resultados finales \cite{Sommerville2015Software}. Por este motivo, en aplicaciones científicas o financieras se recomienda utilizar tipos de mayor precisión, algoritmos numéricamente estables y, cuando sea necesario, bibliotecas de precisión arbitraria \cite{Pressman2019Software}. Además, debe prestarse especial atención al orden de las operaciones, ya que sumas de números muy grandes con números muy pequeños pueden provocar que estos últimos se pierdan en el redondeo \cite{Stallings2021Computer}.
						
						% Figura TikZ: Ejemplo de pérdida de precisión
						\begin{figure}[hbt!]
							\centering
							\begin{tikzpicture}[
								font=\small,
								box/.style={draw, rounded corners=3pt, minimum width=36mm, minimum height=8mm, fill=gray!10},
								arrow/.style={->, thick}
								]
								\node[box] (real) {Valor real: 3.999};
								\node[box, right=20mm of real] (ent) {Entero: 3};
								
								\draw[arrow] (real) -- node[above]{truncamiento} (ent);
							\end{tikzpicture}
							\caption{Pérdida de precisión al convertir de real a entero por truncamiento \cite{Gaddis2022Starting,Stallings2021Computer}.}
							\label{fig:precision-loss}
						\end{figure}
						
			\section{El problema computacional}
			% Problema real vs problema computacional,
			% entradas, salidas, restricciones, ejemplos en dominio SI.
				El problema computacional se define como la formulación precisa, en términos de entradas, salidas y restricciones, de una situación del mundo real que se desea resolver mediante un procedimiento ejecutable por una computadora \cite{Gaddis2022Starting,Pressman2019Software}. Esta formulación implica abstraer los detalles irrelevantes, identificar los datos disponibles y determinar el resultado esperado siguiendo criterios de corrección y eficiencia, tal como enfatizan los textos de ingeniería de software y algoritmia \cite{Sommerville2015Software,Tanenbaum2021Structured}. La calidad de esta definición condiciona directamente la posibilidad de diseñar algoritmos correctos y de implementar programas que respondan adecuadamente a las necesidades de usuarios y organizaciones \cite{Stallings2021Computer}.
				
				% Figura TikZ: modelo general de problema computacional
				\begin{figure}[hbt!]
					\centering
					\begin{tikzpicture}[
						font=\small,
						node distance=20mm,
						box/.style={draw, rounded corners=3pt, thick, minimum width=30mm, minimum height=10mm, align=center, fill=gray!5},
						arrow/.style={->, thick}
						]
						\node[box] (inputs) {Entradas\\(datos)};
						\node[box, right=of inputs] (process) {Proceso\\(algoritmo)};
						\node[box, right=of process] (outputs) {Salidas\\(resultados)};
						\node[box, above=12mm of process, fill=blue!5] (constraints) {Restricciones\\y condiciones};
						
						\draw[arrow] (inputs) -- (process);
						\draw[arrow] (process) -- (outputs);
						\draw[arrow] (constraints) -- (process);
						
					\end{tikzpicture}
					\caption{Esquema general de un problema computacional: entradas, proceso, salidas y restricciones \cite{Gaddis2022Starting,Pressman2019Software}.}
					\label{fig:problema-computacional}
				\end{figure}
				
				\subsection{Análisis del problema}
					El análisis del problema consiste en estudiar en detalle la situación que se desea resolver, identificando actores, objetivos, datos relevantes, reglas de negocio y restricciones operativas \cite{Pressman2019Software,Sommerville2015Software}. Esta etapa antecede al diseño algorítmico y al desarrollo del programa, y tiene como propósito comprender el dominio del problema para evitar interpretaciones ambiguas o incompletas \cite{Gaddis2022Starting}. La literatura de ingeniería de requisitos enfatiza que un análisis deficiente conduce a soluciones técnicamente correctas pero funcionalmente inadecuadas \cite{Pressman2019Software}.
					
					Durante el análisis se describen explícitamente las entradas, salidas y transformaciones esperadas, así como los escenarios típicos y excepcionales que el sistema deberá manejar \cite{Sommerville2015Software}. Se utilizan modelos informales (descripciones en lenguaje natural) y modelos formales (diagramas de flujo de datos, casos de uso, modelos de procesos) para estructurar la información y validar el entendimiento con los interesados \cite{Stallings2021Computer}. Este enfoque reduce la brecha de comunicación entre usuarios y desarrolladores, minimizando el riesgo de malentendidos \cite{Pressman2019Software}.
					
					Además, el análisis del problema permite evaluar la viabilidad técnica, económica y organizacional de la solución propuesta \cite{Sommerville2015Software}. En esta etapa se identifican dependencias con otros sistemas, requisitos de rendimiento, restricciones legales o normativas, y criterios de éxito medibles \cite{Tanenbaum2021Structured}. Esta información sirve de base para el diseño de algoritmos y para la planificación del desarrollo del software \cite{Pressman2019Software}.
					
					\subsubsection{Entradas}
						Las entradas de un problema computacional corresponden a los datos que el sistema requiere para ejecutar el procedimiento de solución \cite{Gaddis2022Starting}. Pueden provenir de usuarios (mediante formularios), de otros sistemas (mediante interfaces de software) o de dispositivos físicos (sensores, lectores de códigos de barras, etc.) \cite{Silberschatz2018Operating}. La identificación precisa de estas entradas es fundamental para garantizar que el algoritmo disponga de la información necesaria para producir resultados correctos \cite{Sommerville2015Software}.
						
						En el contexto de sistemas de información, las entradas suelen asociarse con entidades del negocio como clientes, productos, estudiantes, transacciones o documentos, que se describen mediante atributos específicos (nombre, fecha, monto, identificador, etc.) \cite{Pressman2019Software}. Por ejemplo, en un sistema de matrícula académica, las entradas típicas incluyen datos del estudiante, asignaturas seleccionadas, periodo académico y formas de pago \cite{Sommerville2015Software}. Cada uno de estos datos debe definirse con tipo, formato y dominio válidos \cite{Stallings2021Computer}.
						
						Asimismo, es necesario considerar la calidad de las entradas en términos de precisión, completitud y consistencia \cite{Gaddis2022Starting}. La literatura de sistemas de información señala que entradas incorrectas o incompletas pueden propagarse a lo largo del procesamiento, generando información final errónea y decisiones equivocadas \cite{Pressman2019Software}. Por ello, los algoritmos deben incorporar validaciones que verifiquen rangos, formatos y restricciones antes de procesar los datos \cite{Sommerville2015Software}.
						
					\subsubsection{Salidas}
						Las salidas representan los resultados que el sistema entrega tras procesar las entradas según el algoritmo definido \cite{Gaddis2022Starting}. Pueden adoptar la forma de informes, mensajes, gráficos, archivos generados o actualizaciones en bases de datos, dependiendo de los objetivos del problema computacional \cite{Pressman2019Software}. La definición clara de estas salidas permite evaluar si la solución propuesta satisface las necesidades de los usuarios y de la organización \cite{Sommerville2015Software}.
						
						En sistemas de información, las salidas deben diseñarse de forma que sean comprensibles, completas y oportunas para apoyar la toma de decisiones \cite{Stallings2021Computer}. Por ejemplo, en un sistema contable, las salidas incluyen balances, estados de resultados y reportes de flujo de caja; en un sistema académico, las salidas pueden ser actas de calificaciones, certificados o reportes de rendimiento \cite{Sommerville2015Software}. Cada salida se deriva de transformaciones lógicas y aritméticas aplicadas a las entradas y a los datos almacenados \cite{Pressman2019Software}.
						
						Además, la representación de las salidas debe considerar aspectos de formato, presentación y seguridad \cite{Silberschatz2018Operating}. La literatura de ingeniería de software recomienda diseñar las salidas de manera que resuman información relevante sin saturar al usuario, incorporando indicadores, alertas o visualizaciones cuando sea pertinente \cite{Pressman2019Software}. La forma en que se diseñan estas salidas influye directamente en la utilidad percibida del sistema \cite{Sommerville2015Software}.
						
					\subsubsection{Restricciones y condiciones}
						Las restricciones y condiciones definen los límites dentro de los cuales la solución computacional debe operar, incluyendo requisitos de tiempo, recursos, normativas legales, políticas internas y condiciones de entorno \cite{Pressman2019Software}. Estas restricciones pueden ser explícitas (por ejemplo, ``el reporte debe generarse en menos de cinco segundos'') o implícitas (capacidad máxima de almacenamiento, número de usuarios concurrentes, etc.) \cite{Sommerville2015Software}. Ignorar estas condiciones puede dar lugar a soluciones técnicamente correctas pero inviables en la práctica \cite{Stallings2021Computer}.
						
						En sistemas de información, las restricciones suelen abarcar reglas de negocio (por ejemplo, ``no se puede matricular una asignatura si el prerrequisito está reprobado''), políticas de seguridad (roles de acceso, confidencialidad de datos) y requisitos de integridad (consistencia entre módulos, transacciones atómicas) \cite{Silberschatz2018Operating}. Estas reglas condicionan tanto el diseño de algoritmos como la estructura de los datos y las interfaces de usuario \cite{Pressman2019Software}.
						
						Asimismo, la literatura enfatiza la importancia de documentar y validar las restricciones con los interesados antes de diseñar la solución \cite{Sommerville2015Software}. Esta validación asegura que las condiciones reflejen fielmente el contexto operativo y que puedan verificarse mediante pruebas y mecanismos de monitoreo \cite{Pressman2019Software}. De este modo, las restricciones se convierten en criterios objetivos para evaluar el correcto funcionamiento del sistema \cite{Stallings2021Computer}.
						
				\subsection{Ejemplos de problemas en sistemas de información}
					Los sistemas de información empresariales ofrecen numerosos ejemplos de problemas computacionales que pueden modelarse en términos de entradas, salidas, procesos y restricciones, tales como control de inventario, registro de estudiantes y procesamiento de ventas \cite{Pressman2019Software,Sommerville2015Software}. Cada uno de estos casos ilustra cómo los conceptos de datos, información y conocimiento se integran para apoyar la toma de decisiones y automatizar operaciones clave en organizaciones modernas \cite{Gaddis2022Starting}.
					
					\subsubsection{Control de inventario}
						En un problema de control de inventario, las entradas incluyen datos de productos, niveles de stock, movimientos de entrada y salida, pedidos de compra y ventas realizadas \cite{Pressman2019Software}. El sistema debe procesar esta información para calcular existencias actuales, identificar productos por debajo del nivel mínimo y generar alertas o pedidos automáticos a proveedores \cite{Sommerville2015Software}. Las salidas típicas son reportes de inventario, listados de productos críticos y proyecciones de demanda con base en históricos \cite{Stallings2021Computer}.
						
						Las restricciones pueden incluir capacidad máxima de almacenamiento, fechas de caducidad, políticas de reordenamiento y prioridades de productos \cite{Silberschatz2018Operating}. Un algoritmo bien diseñado debe considerar estos factores para evitar desabastecimientos o sobreinventario, fenómenos que tienen impacto directo en costos y niveles de servicio \cite{Pressman2019Software}. Este tipo de problema se modela frecuentemente mediante diagramas de flujo de datos y modelos de procesos de negocio en la literatura de sistemas de información \cite{Sommerville2015Software}.
						
					\subsubsection{Registro de estudiantes}
						En un sistema de registro de estudiantes, las entradas comprenden datos personales, información académica previa, asignaturas seleccionadas, horarios y opciones de pago \cite{Gaddis2022Starting}. El sistema debe validar la información de acuerdo con reglas de integridad (por ejemplo, formato de identificación, requisitos de edad) y reglas académicas (cumplimiento de prerrequisitos, límites de créditos, compatibilidad de horarios) \cite{Sommerville2015Software}. Las salidas incluyen comprobantes de matrícula, horarios personalizados y actualizaciones en el historial académico \cite{Pressman2019Software}.
						
						Las restricciones abarcan cupos por asignatura, calendarios académicos, límites de créditos por periodo y políticas internas de la institución \cite{Silberschatz2018Operating}. Un algoritmo de registro debe manejar condiciones especiales, como reservas de cupo, listas de espera o prioridades según tipo de estudiante, aspectos tratados en la literatura de sistemas de gestión académica \cite{Pressman2019Software}. Estas condiciones añaden complejidad al problema computacional y requieren un diseño cuidadoso de estructuras de datos y procesos \cite{Sommerville2015Software}.
						
						Además, el sistema debe garantizar confidencialidad y seguridad de los datos de los estudiantes, cumpliendo normativas legales y políticas institucionales \cite{Silberschatz2018Operating}. Esto implica implementar controles de acceso, cifrado y auditoría, elementos que conectan el problema computacional con la gestión de riesgos y la seguridad de la información \cite{Stallings2021Computer}.
						
					\subsubsection{Procesamiento de ventas}
						En el procesamiento de ventas, las entradas incluyen datos de clientes, productos, cantidades, precios, descuentos y métodos de pago \cite{Gaddis2022Starting}. El sistema debe calcular subtotales, impuestos y totales a pagar, actualizando simultáneamente el inventario y los registros contables \cite{Pressman2019Software}. Las salidas típicas son facturas, recibos electrónicos, reportes de ventas diarias y registros de transacciones para análisis posterior \cite{Sommerville2015Software}.
						
						Las restricciones incorporan políticas comerciales (descuentos máximos, promociones vigentes), límites de crédito, validación de medios de pago y cumplimiento de normativas fiscales \cite{Silberschatz2018Operating}. El algoritmo debe garantizar que cada transacción sea atómica, consistente, aislada y duradera (propiedades ACID), especialmente cuando se utilizan bases de datos transaccionales \cite{Stallings2021Computer}. Estos requisitos son ampliamente documentados en textos de sistemas de bases de datos y sistemas de información \cite{Pressman2019Software}.
						
						Finalmente, los datos de ventas se utilizan para generar conocimiento sobre patrones de consumo, productos más vendidos y periodos de mayor demanda \cite{Gaddis2022Starting}. Este conocimiento alimenta procesos de toma de decisiones estratégicas y de planificación, relacionando el problema computacional con la analítica de datos y la inteligencia de negocio \cite{Sommerville2015Software}.
						
						% Figura TikZ: ejemplo de flujo de información en procesamiento de ventas
						\begin{figure}[hbt!]
							\centering
							\begin{tikzpicture}[
								font=\small,
								node distance=14mm,
								box/.style={draw, rounded corners=3pt, thick, minimum width=28mm, minimum height=10mm, align=center, fill=gray!5},
								arrow/.style={->, thick}
								]
								\node[box] (cliente) {Datos del cliente};
								\node[box, right=of cliente] (venta) {Registro de venta};
								\node[box, right=of venta] (inventario) {Actualización\\de inventario};
								\node[box, below=of venta] (contab) {Registro\\contable};
								\node[box, above=of venta] (reporte) {Reporte\\de ventas};
								
								\draw[arrow] (cliente) -- (venta);
								\draw[arrow] (venta) -- (inventario);
								\draw[arrow] (venta) -- (contab);
								\draw[arrow] (venta) -- (reporte);
							\end{tikzpicture}
							\caption{Flujo simplificado de información en el procesamiento de ventas \cite{Pressman2019Software,Sommerville2015Software}.}
							\label{fig:flujo-ventas}
						\end{figure}
						
			\section{Proceso de resolución de problemas en programación}
			% Fases: análisis, modelado, algoritmo, codificación, pruebas, mantenimiento.
				El proceso de resolución de problemas en programación se estructura en una secuencia de fases que abarcan desde el análisis del problema hasta el mantenimiento y la mejora continua del software, integrando actividades de modelado, diseño algorítmico, codificación, pruebas y documentación \cite{Joyanes2007Fundamentos,Pressman2019Software,Sommerville2015Software}. Esta organización en etapas permite reducir la complejidad, mejorar la calidad de las soluciones y favorecer la comunicación entre los miembros del equipo de desarrollo y los usuarios finales \cite{Gaddis2022Starting}. La literatura de ingeniería de software y algoritmia insiste en que una solución computacional robusta no surge únicamente de escribir código, sino de seguir un proceso disciplinado que garantice corrección, eficiencia y mantenibilidad \cite{Joyanes2007Fundamentos,Tanenbaum2021Structured,Stallings2021Computer}.
				
				% Figura TikZ: Fases del proceso de resolución de problemas
				\begin{figure}[hbt!]
					\centering
					\begin{tikzpicture}[
						font=\small,
						node distance=10mm,
						box/.style={draw, rounded corners=3pt, thick, minimum width=28mm, minimum height=8mm, align=center, fill=gray!5},
						arrow/.style={->, thick}
						]
						\node[box] (analisis) {Análisis};
						\node[box, right=of analisis] (modelado) {Modelado};
						\node[box, right=of modelado] (diseno) {Diseño\\algorítmico};
						\node[box, right=of diseno] (cod) {Codificación};
						\node[box, right=of cod] (pruebas) {Pruebas};
						\node[box, right=of pruebas] (doc) {Documentación};
						
						\draw[arrow] (analisis) -- (modelado);
						\draw[arrow] (modelado) -- (diseno);
						\draw[arrow] (diseno) -- (cod);
						\draw[arrow] (cod) -- (pruebas);
						\draw[arrow] (pruebas) -- (doc);
					\end{tikzpicture}
					\caption{Fases generales del proceso de resolución de problemas en programación \cite{Joyanes2007Fundamentos,Pressman2019Software,Sommerville2015Software}.}
					\label{fig:fases-proceso-programacion}
				\end{figure}
				
				\subsection{Etapas formales}
					Las etapas formales en la resolución de problemas incluyen análisis, modelado, diseño de algoritmos, codificación, pruebas y documentación, cada una con objetivos y productos claramente definidos \cite{Joyanes2007Fundamentos,Pressman2019Software}. Esta estructura se alinea con los ciclos de desarrollo de software descritos en modelos de proceso clásicos, donde se enfatiza que el avance entre etapas debe basarse en resultados verificables y no solo en la intuición del desarrollador \cite{Sommerville2015Software}. Al formalizar estas fases, se facilita la planificación, la asignación de recursos y la evaluación de la calidad en cada punto del proceso \cite{Joyanes2007Fundamentos,Stallings2021Computer}.
					
					Además, las etapas formales permiten establecer mecanismos de retroalimentación, de modo que los errores detectados en fases posteriores puedan corregirse en fases anteriores del proceso \cite{Joyanes2007Fundamentos,Pressman2019Software}. Por ejemplo, defectos encontrados en pruebas pueden revelar problemas de diseño o de análisis de requisitos, lo que impulsa ajustes en los modelos conceptuales o en los algoritmos \cite{Joyanes2007Fundamentos,Sommerville2015Software}. Este enfoque iterativo es fundamental para construir soluciones robustas en entornos reales, donde los requisitos pueden evolucionar con el tiempo \cite{Gaddis2022Starting}.
					
					\subsubsection{Análisis}
						La fase de análisis se centra en comprender el problema desde la perspectiva del dominio, identificando qué se quiere lograr, quiénes son los usuarios involucrados y qué restricciones condicionan la solución \cite{Pressman2019Software}. En esta etapa se recogen requisitos funcionales (servicios que debe prestar el sistema) y no funcionales (rendimiento, seguridad, usabilidad), utilizando técnicas de elicitación como entrevistas, cuestionarios y análisis de documentos \cite{Sommerville2015Software}. Una comprensión incompleta del problema en esta fase suele conducir a soluciones inadecuadas o a costosas correcciones posteriores \cite{Joyanes2007Fundamentos,Stallings2021Computer}.
						
						Durante el análisis se formulan descripciones en lenguaje natural, tablas de entradas y salidas, y escenarios de uso que ilustran cómo interactuarán los usuarios con el futuro sistema \cite{Gaddis2022Starting}. Por ejemplo, en un sistema de matrícula, se describen casos como ``registrar estudiante'', ``agregar asignatura'' o ``generar comprobante'', detallando datos requeridos y resultados esperados \cite{Joyanes2007Fundamentos,Pressman2019Software}. Estos escenarios ayudan a validar el entendimiento del problema con los interesados y a detectar omisiones o ambigüedades \cite{Sommerville2015Software}.
						
						Asimismo, el análisis incluye la identificación de riesgos, dependencias y supuestos que podrían afectar el desarrollo o la operación del sistema \cite{Pressman2019Software}. Documentar estos elementos permite priorizar requisitos, negociar alcances y planificar estrategias de mitigación \cite{Sommerville2015Software}. La fase de análisis, por tanto, constituye la base conceptual sobre la cual se edificarán las etapas posteriores del proceso de programación \cite{Joyanes2007Fundamentos,Stallings2021Computer}.
						
					\subsubsection{Modelado}
						El modelado traduce los resultados del análisis en representaciones más estructuradas, utilizando diagramas, notaciones formales y herramientas gráficas que simplifican la comprensión del sistema \cite{Pressman2019Software}. Entre estas representaciones se incluyen diagramas de flujo de datos, diagramas de casos de uso, diagramas de clases o modelos de procesos, según las metodologías sugeridas en la literatura de ingeniería de software \cite{Sommerville2015Software}. El objetivo es reducir la complejidad del problema mediante abstracciones que permitan ver el sistema como un conjunto de componentes y relaciones \cite{Joyanes2007Fundamentos,Stallings2021Computer}.
						
						Por ejemplo, un diagrama de flujo de datos puede mostrar cómo la información se desplaza entre procesos de negocio, bases de datos y entidades externas, clarificando entradas, salidas y transformaciones intermedias \cite{Pressman2019Software}. Esta visualización facilita la detección de redundancias, inconsistencias o pasos innecesarios en los procesos \cite{Sommerville2015Software}. Asimismo, los modelos se convierten en referencia para el diseño algorítmico y la posterior implementación \cite{Gaddis2022Starting}.
						
						Los modelos también sirven como documentos de comunicación entre analistas, desarrolladores y usuarios, ya que ofrecen una representación intermedia entre el lenguaje natural y el código fuente \cite{Pressman2019Software}. Esta función comunicativa es esencial para alinear expectativas y para validar que el sistema refleje fielmente el dominio del problema \cite{Sommerville2015Software}. En consecuencia, el modelado contribuye directamente a la calidad global del software \cite{Joyanes2007Fundamentos,Stallings2021Computer}.
						
					\subsubsection{Diseño algorítmico}
						El diseño algorítmico consiste en definir, a partir de los modelos, una secuencia precisa de pasos que permita transformar las entradas en salidas de acuerdo con las restricciones y objetivos del problema \cite{Gaddis2022Starting}. Esta etapa utiliza pseudocódigo, diagramas de flujo, diagramas de N-S u otras notaciones que describen la lógica de la solución sin depender aún de un lenguaje de programación específico \cite{Joyanes2007Fundamentos,Pressman2019Software}. El propósito es centrarse en la corrección y claridad de la estrategia antes de abordar detalles sintácticos \cite{Sommerville2015Software}.
						
						La literatura de algoritmia y estructuras de datos enfatiza que un buen diseño algorítmico debe considerar eficiencia temporal y espacial, simplicidad y modularidad \cite{Stallings2021Computer}. Por ejemplo, se evalúa si un problema de búsqueda requiere una solución lineal o si puede beneficiarse de algoritmos más eficientes como búsqueda binaria, dependiendo de la estructura de los datos \cite{Tanenbaum2021Structured}. Estas decisiones tienen impacto directo en el rendimiento del sistema \cite{Pressman2019Software}.
						
						Una vez definido el algoritmo, se realizan verificaciones informales o formales para comprobar su corrección, revisando casos típicos, casos límite y situaciones excepcionales \cite{Joyanes2007Fundamentos,Sommerville2015Software}. Esta revisión temprana permite detectar errores lógicos y mejorar la estructura antes de la codificación \cite{Gaddis2022Starting}. De este modo, el diseño algorítmico actúa como puente entre los modelos conceptuales y el código ejecutable \cite{Pressman2019Software}.
						
					\subsubsection{Codificación}
						La codificación consiste en traducir el algoritmo a un lenguaje de programación concreto, respetando su sintaxis, semántica y convenciones de estilo \cite{Gaddis2022Starting}. En esta fase se seleccionan estructuras de control (secuencias, decisiones, bucles), tipos de datos y bibliotecas estándar o especializadas que faciliten la implementación de la lógica diseñada \cite{Sommerville2015Software}. La calidad del código se mide en términos de legibilidad, modularidad, reusabilidad y ausencia de errores \cite{Joyanes2007Fundamentos,Pressman2019Software}.
						
						Los manuales de programación recomiendan aplicar buenas prácticas como nombrar adecuadamente variables y funciones, utilizar comentarios claros, evitar duplicación innecesaria de código y seguir guías de estilo específicas del lenguaje \cite{Gaddis2022Starting}. Estas prácticas simplifican el mantenimiento, la revisión por pares y la evolución del sistema \cite{Joyanes2007Fundamentos,Pressman2019Software}. Asimismo, la codificación se apoya en herramientas como editores, entornos de desarrollo integrado (IDE) y sistemas de control de versiones \cite{Sommerville2015Software}.
						
						Durante la codificación también se introducen pruebas unitarias básicas que verifican el comportamiento de funciones o módulos individuales \cite{Pressman2019Software}. Este enfoque, asociado con metodologías como desarrollo guiado por pruebas (TDD), ayuda a detectar errores tempranamente y garantiza que el código cumpla con las especificaciones algorítmicas \cite{Joyanes2007Fundamentos,Sommerville2015Software}. La estrecha relación entre codificación y pruebas contribuye a la construcción incremental y confiable de sistemas complejos \cite{Stallings2021Computer}.
						
					\subsubsection{Pruebas}
						La fase de pruebas tiene como objetivo detectar defectos y verificar que el software cumple con los requisitos funcionales y no funcionales establecidos durante el análisis \cite{Pressman2019Software}. Se distinguen diferentes niveles de prueba: unitarias, de integración, de sistema y de aceptación, cada una enfocada en un nivel de agregación distinto \cite{Sommerville2015Software}. Las pruebas se diseñan a partir de casos específicos que cubren condiciones normales, límites y situaciones de error \cite{Joyanes2007Fundamentos,Stallings2021Computer}.
						
						En el contexto de programación básica, las pruebas unitarias y de integración resultan especialmente relevantes, pues permiten comprobar que funciones, procedimientos y módulos colaboran de manera correcta \cite{Gaddis2022Starting}. Los resultados de las pruebas se documentan y analizan para determinar la causa raíz de los errores, lo cual conduce a correcciones en el código o incluso a revisiones en el diseño algorítmico \cite{Pressman2019Software}. Este ciclo de prueba–corrección es esencial para alcanzar una calidad aceptable antes de desplegar el software \cite{Sommerville2015Software}.
						
						Además, las pruebas pueden automatizarse mediante marcos especializados que ejecutan casos de prueba de forma repetible y registran resultados de manera sistemática \cite{Pressman2019Software}. Esta automatización es fundamental para proyectos que evolucionan continuamente, donde pequeñas modificaciones al código pueden reintroducir errores previos \cite{Sommerville2015Software}. La literatura destaca la importancia de considerar las pruebas como parte integral del proceso de desarrollo y no como una fase aislada al final \cite{Stallings2021Computer}.
						
					\subsubsection{Documentación}
						La documentación reúne los artefactos que describen el sistema desde distintas perspectivas: requisitos, diseño, código, manuales de usuario y guías de operación \cite{Pressman2019Software}. Su propósito es facilitar la comprensión, el mantenimiento y la evolución del software a lo largo del tiempo, permitiendo que otros desarrolladores y usuarios puedan interpretarlo y utilizarlo adecuadamente \cite{Sommerville2015Software}. En proyectos académicos y profesionales, la documentación bien estructurada es un indicador clave de calidad \cite{Joyanes2007Fundamentos,Stallings2021Computer}.
						
						Entre los documentos más relevantes se encuentran las especificaciones de requisitos, los diagramas de diseño, los comentarios en el código, los manuales de instalación y los manuales de usuario \cite{Pressman2019Software}. Cada uno cumple una función específica: los requisitos describen qué debe hacer el sistema; los diagramas muestran cómo está organizado; los comentarios aclaran decisiones técnicas; y los manuales explican cómo utilizarlo y administrarlo \cite{Sommerville2015Software}. Esta diversidad de documentos contribuye a que el sistema sea comprensible en diferentes niveles de detalle \cite{Gaddis2022Starting}.
						
						La literatura enfatiza que la documentación debe mantenerse actualizada y coherente con el código fuente \cite{Pressman2019Software}. Documentos obsoletos generan confusión y pueden inducir a errores durante el mantenimiento o la ampliación del sistema \cite{Sommerville2015Software}. Por ello, se recomienda incluir la actualización de la documentación como parte explícita del proceso de desarrollo y de las políticas de control de versiones \cite{Stallings2021Computer}.
						
				\subsection{Importancia del pensamiento algorítmico}
					El pensamiento algorítmico se define como la capacidad de descomponer un problema en pasos ordenados, finitos y efectivos que conduzcan a una solución \cite{Gaddis2022Starting}. Esta forma de razonamiento permite abstraer detalles irrelevantes, identificar patrones de solución y diseñar procedimientos generales aplicables a múltiples casos \cite{Pressman2019Software}. En el contexto de la programación, el pensamiento algorítmico constituye una competencia fundamental que diferencia el simple uso de herramientas del verdadero diseño de soluciones computacionales \cite{Sommerville2015Software}.
					
					Asimismo, el pensamiento algorítmico promueve la claridad y precisión en la formulación de instrucciones, lo que reduce la ambigüedad y facilita la verificación de la corrección de los programas \cite{Stallings2021Computer}. La literatura sobre enseñanza de la programación resalta que desarrollar esta competencia es un objetivo central en los cursos introductorios, pues prepara a los estudiantes para abordar problemas complejos en etapas posteriores de su formación \cite{Gaddis2022Starting}. Este enfoque contribuye a una comprensión más profunda de la relación entre problema, algoritmo y programa \cite{Pressman2019Software}.
					
					\subsubsection{Abstracción}
						La abstracción es la habilidad para identificar los aspectos esenciales de un problema y omitir detalles irrelevantes, construyendo modelos simplificados que facilitan su análisis y solución \cite{Sommerville2015Software}. En programación, abstraer implica concentrarse en qué debe hacer un módulo o función sin preocuparse inicialmente por cómo se implementará internamente \cite{Pressman2019Software}. Esta separación de responsabilidades mejora la claridad y permite dividir el trabajo entre distintos miembros del equipo \cite{Stallings2021Computer}.
						
						Por ejemplo, al diseñar un módulo de \emph{gestión de estudiantes}, se abstrae el concepto de estudiante como una entidad con atributos (nombre, identificación, asignaturas) y operaciones (matricular, dar de baja, generar reporte), sin especificar todavía estructuras de datos o detalles de almacenamiento \cite{Gaddis2022Starting}. Esta abstracción posibilita que diferentes implementaciones cumplan la misma interfaz, lo que facilita la reutilización y el mantenimiento \cite{Pressman2019Software}. 
						
						La abstracción se aplica también a nivel de datos y procesos, permitiendo definir tipos de datos abstractos, clases, interfaces y servicios que encapsulan detalles internos \cite{Sommerville2015Software}. Esta técnica, ampliamente documentada en la literatura de diseño de software, favorece la construcción de sistemas modulares y extensibles \cite{Stallings2021Computer}.
						
					\subsubsection{Decomposición}
						La decomposición consiste en dividir un problema complejo en subproblemas más pequeños y manejables, permitiendo abordar cada parte de forma independiente \cite{Sommerville2015Software}. Esta técnica se fundamenta en el principio de ``divide y vencerás'', ampliamente utilizado en ingeniería de software y en el diseño de algoritmos \cite{Pressman2019Software}. La decomposición reduce la complejidad cognitiva y facilita la verificación de cada componente, contribuyendo a la calidad global del sistema \cite{Stallings2021Computer}.
						
						Por ejemplo, un sistema de gestión académica puede dividirse en módulos como gestión de estudiantes, manejo de asignaturas, registro de matrículas, generación de reportes y administración de usuarios \cite{Gaddis2022Starting}. Cada módulo tiene responsabilidades claras y puede implementarse de manera independiente, siempre que respete las interfaces definidas durante el diseño \cite{Sommerville2015Software}. Esto permite desarrollar, probar y mantener cada parte sin afectar el funcionamiento general del sistema \cite{Pressman2019Software}.
						
						La decomposición también favorece la reutilización de componentes, ya que subproblemas comunes pueden resolverse mediante funciones o módulos reaprovechables en distintos contextos \cite{Stallings2021Computer}. Además, facilita la asignación de tareas en equipos de desarrollo, mejorando la organización del proyecto y la eficiencia del trabajo colaborativo \cite{Sommerville2015Software}. Por estas razones, la decomposición es considerada una habilidad esencial en el pensamiento algorítmico y en la formación de programadores \cite{Gaddis2022Starting}.
						
						% Figura TikZ: ejemplo de decomposición modular
						\begin{figure}[hbt!]
							\centering
							\begin{tikzpicture}[
								font=\small,
								node distance=10mm,
								module/.style={draw, rounded corners=3pt, thick, minimum width=32mm, minimum height=10mm, align=center, fill=gray!10},
								arrow/.style={->, thick}
								]
								\node[module] (main) {Sistema principal};
								\node[module, below left=12mm and 18mm of main] (mod1) {Módulo A};
								\node[module, below=12mm of main] (mod2) {Módulo B};
								\node[module, below right=12mm and 18mm of main] (mod3) {Módulo C};
								\draw[arrow] (main) -- (mod1);
								\draw[arrow] (main) -- (mod2);
								\draw[arrow] (main) -- (mod3);
							\end{tikzpicture}
							\caption{Ejemplo de decomposición modular \cite{Pressman2019Software,Sommerville2015Software}.}
							\label{fig:decomposicion}
						\end{figure}
						
					\subsubsection{Patrones de solución}
						Los patrones de solución representan estrategias recurrentes para resolver problemas que comparten características estructurales, permitiendo reutilizar conocimiento y enfoques probados \cite{Pressman2019Software}. En el ámbito del diseño de algoritmos, estos patrones incluyen técnicas como búsqueda, ordenamiento, recursión, divide y vencerás, programación dinámica y algoritmos codiciosos \cite{Stallings2021Computer}. Su estudio proporciona un marco conceptual que ayuda a seleccionar el enfoque más adecuado para cada tipo de problema \cite{Sommerville2015Software}.
						
						Por ejemplo, cuando el problema implica encontrar un elemento en una lista ordenada, la búsqueda binaria constituye un patrón eficiente que reduce la complejidad temporal de \(O(n)\) a \(O(\log n)\) \cite{Tanenbaum2021Structured}. Asimismo, problemas como generación de reportes, análisis de datos o manejo de estructuras compuestas se benefician de patrones como iteración controlada, filtrado, transformación y reducción \cite{Gaddis2022Starting}. Estos patrones permiten construir soluciones más claras y predecibles, facilitando el aprendizaje y la implementación \cite{Pressman2019Software}.
						
						Los patrones de solución no solo mejoran la eficiencia y claridad del código, sino que también contribuyen a la mantenibilidad y escalabilidad del software \cite{Sommerville2015Software}. La literatura enfatiza que los desarrolladores deben reconocer cuándo un patrón aplica y cuándo no, evitando el uso inapropiado de técnicas que podrían generar complejidad innecesaria \cite{Stallings2021Computer}. De esta manera, los patrones constituyen un puente entre el pensamiento algorítmico y el diseño de software robusto \cite{Pressman2019Software}.
						
			\section{Algoritmos: concepto y propiedades esenciales}
			% Definición formal, finitud, determinismo, efectividad, correctitud, eficiencia.
				Un algoritmo es un conjunto finito y ordenado de pasos que describen cómo transformar entradas en salidas, cumpliendo condiciones de precisión, efectividad, finitud y determinismo \cite{Gaddis2022Starting,Pressman2019Software}. La definición formal de algoritmo, estudiada ampliamente en teoría computacional y programación, establece que cada instrucción debe ser clara e inequívoca, y que el procedimiento debe garantizar resultados correctos en un número finito de pasos \cite{Sommerville2015Software,Tanenbaum2021Structured}. Los algoritmos constituyen la base de toda solución computacional, ya que definen la lógica que ejecutarán los programas \cite{Stallings2021Computer}.
				
				% Figura TikZ: estructura general de un algoritmo
				\begin{figure}[hbt!]
					\centering
					\begin{tikzpicture}[
						font=\small,
						node distance=6mm, % si quieres un poco menos de espacio vertical
						algostep/.style={draw, rounded corners=3pt, thick,
							minimum width=38mm, minimum height=10mm,
							align=center, fill=gray!10},
						arrow/.style={->, thick}
						]
						\node[algostep] (start) {Inicio};
						\node[algostep, below=of start] (input) {Leer entradas};
						\node[algostep, below=of input] (process) {Procesar datos};
						\node[algostep, below=of process] (output) {Generar salidas};
						\node[algostep, below=of output] (end) {Fin};
						
						\draw[arrow] (start) -- (input);
						\draw[arrow] (input) -- (process);
						\draw[arrow] (process) -- (output);
						\draw[arrow] (output) -- (end);
					\end{tikzpicture}
					\caption{Estructura básica de un algoritmo \cite{Gaddis2022Starting,Stallings2021Computer}.}
					\label{fig:estructura-algoritmo}
				\end{figure}
				
				\subsection{Definición formal}
					En su definición formal, un algoritmo debe especificar pasos precisos, ejecutables y no ambiguos, siguiendo la teoría desarrollada en la literatura clásica de programación y sistemas \cite{Tanenbaum2021Structured}. Cada paso debe representar una instrucción que pueda ser interpretada por un agente computacional, ya sea humano o máquina, garantizando claridad en su ejecución \cite{Pressman2019Software}. Este principio de precisión evita interpretaciones múltiples y asegura consistencia en resultados \cite{Sommerville2015Software}.
					
					Además, un algoritmo debe ser finito, es decir, debe concluir su ejecución en un número limitado de pasos \cite{Gaddis2022Starting}. La finitud distingue los algoritmos de procesos indefinidos o recursiones infinitas y permite que las soluciones computacionales sean verificables y medibles \cite{Stallings2021Computer}. La literatura técnica enfatiza que la ausencia de finitud puede provocar bloqueos, ciclos infinitos o fallas en sistemas críticos \cite{Pressman2019Software}.
					
					Finalmente, la efectividad del algoritmo implica que cada operación especificada debe ser realizable mediante recursos computacionales disponibles y debe producir el efecto esperado sobre los datos \cite{Tanenbaum2021Structured}. Esta propiedad garantiza que los algoritmos puedan implementarse en hardware real y se ejecuten dentro de tiempos razonables, conforme a los parámetros de eficiencia establecidos en ingeniería de software \cite{Sommerville2015Software}.
					
				\subsection{Propiedades esenciales}
					Los algoritmos poseen propiedades esenciales que permiten evaluarlos: finitud, determinismo, efectividad y correctitud \cite{Pressman2019Software}. La finitud garantiza que el procedimiento terminará; el determinismo asegura que cada paso es claro y no admite ambigüedades; y la efectividad indica que cada operación es realizable mediante computación real \cite{Sommerville2015Software}. Estas propiedades definen la naturaleza formal de los algoritmos y distinguen procedimientos correctos de descripciones vagas o indefinidas \cite{Stallings2021Computer}.
					
					El determinismo implica que un algoritmo, dado un conjunto de entradas, debe producir siempre las mismas salidas siguiendo los mismos pasos, sin depender de factores externos o aleatoriedad \cite{Tanenbaum2021Structured}. Esta propiedad es fundamental en sistemas críticos, donde decisiones automáticas deben ser reproducibles y auditables \cite{Pressman2019Software}. Los modelos de evaluación de algoritmos analizan esta característica mediante pruebas de caja negra y caja blanca \cite{Sommerville2015Software}.
					
					La efectividad está asociada a que cada instrucción del algoritmo corresponda a operaciones simples, realizables y comprensibles, evitando acciones abstractas imposibles de implementar en hardware o software \cite{Gaddis2022Starting}. Esta propiedad asegura la aplicabilidad del algoritmo en sistemas reales y guía el diseño de soluciones computacionales eficientes \cite{Stallings2021Computer}. 
					
					\subsubsection{Finitud}
						La finitud indica que un algoritmo debe tener un número limitado de pasos y que su ejecución debe terminar necesariamente \cite{Pressman2019Software}. Este principio permite garantizar que los programas no queden atrapados en ciclos infinitos ni consuman recursos indefinidamente, problema recurrente en sistemas mal diseñados \cite{Sommerville2015Software}. La literatura de algoritmia enfatiza que cualquier algoritmo que no garantice finitud no es computacionalmente válido \cite{Stallings2021Computer}.
						
						Ejemplos clásicos incluyen algoritmos iterativos que usan condiciones de parada explícitas y algoritmos recursivos que definen casos base que permiten terminar la ejecución \cite{Tanenbaum2021Structured}. Por ejemplo, el cálculo del factorial de un número natural finaliza cuando se alcanza el caso base \(0! = 1\), garantizando finitud y correctitud \cite{Gaddis2022Starting}. Esta propiedad debe verificarse durante el diseño para evitar comportamientos anómalos en ejecución \cite{Pressman2019Software}.
						
						El análisis de finitud también se aplica en validaciones formales mediante métodos matemáticos que permiten demostrar que el algoritmo no continuará indefinidamente, práctica documentada en estudios de verificación y análisis de programas \cite{Sommerville2015Software}. Esta verificación es crucial en sistemas críticos, como control industrial o aeronáutica \cite{Stallings2021Computer}.
						
					\subsubsection{Determinismo}
						El determinismo establece que cada paso de un algoritmo debe definir una acción única y claramente especificada, de modo que no exista ambigüedad en su interpretación o ejecución \cite{Pressman2019Software}. Esta propiedad garantiza que, para un mismo conjunto de entradas, el algoritmo producirá siempre las mismas salidas siguiendo el mismo camino de ejecución, característica fundamental en sistemas predecibles y auditablemente correctos \cite{Sommerville2015Software}. La ausencia de determinismo puede introducir incertidumbre en el comportamiento del sistema, generando riesgos en aplicaciones críticas como sistemas bancarios, médicos o aeronáuticos \cite{Stallings2021Computer}.
						
						En la práctica, el determinismo implica que las operaciones deben estar definidas con precisión, evitando expresiones ambiguas como “ordenar adecuadamente” o “seleccionar un elemento adecuado”, que no especifican una acción concreta \cite{Tanenbaum2021Structured}. Los lenguajes de programación refuerzan este principio mediante reglas estrictas de sintaxis y semántica que permiten traducir instrucciones a operaciones de máquina sin interpretaciones inconsistentes \cite{Gaddis2022Starting}. La claridad fomentada por el determinismo mejora la mantenibilidad y facilita la verificación del software \cite{Pressman2019Software}.
						
						Asimismo, el determinismo posibilita la reproducibilidad, condición necesaria para validar algoritmos mediante pruebas y análisis formal \cite{Sommerville2015Software}. Si un algoritmo no es determinista, los resultados podrían variar entre ejecuciones incluso bajo condiciones idénticas, dificultando su verificación y su uso en contextos que requieren alta confiabilidad \cite{Stallings2021Computer}. Por estas razones, el determinismo constituye un pilar en la teoría clásica de algoritmos.
						
					\subsubsection{Efectividad}
						La efectividad se refiere a que cada operación descrita en un algoritmo debe ser realizable mediante un conjunto elemental de acciones ejecutables por un agente computacional \cite{Pressman2019Software}. Esto implica que las instrucciones deben ser suficientemente simples como para ser implementadas en hardware o software real, y deben garantizar que la acción especificada produzca el efecto esperado sobre los datos \cite{Sommerville2015Software}. La efectividad evita la presencia de pasos vagos o imposibles de ejecutar, lo cual fortalecería la inconsistencia del algoritmo \cite{Stallings2021Computer}.
						
						Los algoritmos efectivos se basan en operaciones elementales tales como asignación, comparación, aritmética básica, lectura y escritura, todas ellas compatibles con la arquitectura del computador descrita por modelos como la arquitectura de Von Neumann \cite{Tanenbaum2021Structured}. Por ejemplo, un algoritmo que requiera “adivinar el resultado adecuado” no sería efectivo porque no define una operación mecanizable; en cambio, un algoritmo que busque un elemento realizando comparaciones secuenciales sí lo es \cite{Gaddis2022Starting}. La efectividad garantiza que un algoritmo pueda ser concretado en un programa real.
						
						Además, la efectividad contribuye al tiempo de ejecución razonable del algoritmo, dado que las operaciones elementales permiten prever el costo computacional de cada paso \cite{Pressman2019Software}. Esta característica se vincula estrechamente con el análisis de eficiencia, pues los algoritmos efectivos pueden evaluarse más fácilmente utilizando modelos formales de complejidad temporal y espacial \cite{Stallings2021Computer}. En consecuencia, la efectividad es indispensable para asegurar que el algoritmo sea útil en la práctica.
						
				\subsection{Correctitud y eficiencia}
					La correctitud de un algoritmo implica que produce salidas válidas para todas las entradas válidas y que cumple con la especificación formal del problema \cite{Pressman2019Software}. Esta propiedad se fundamenta en la verificación de que cada paso contribuye exactamente al resultado esperado y de que las condiciones previas y posteriores a cada operación son coherentes con los requisitos del sistema \cite{Sommerville2015Software}. La correctitud es un prerrequisito esencial, especialmente en sistemas donde los errores pueden provocar fallas graves o pérdidas económicas significativas \cite{Stallings2021Computer}.
					
					La eficiencia, por su parte, se relaciona con el uso óptimo de recursos computacionales, principalmente tiempo de ejecución y memoria \cite{Tanenbaum2021Structured}. Algoritmos que realizan la misma tarea pueden diferir radicalmente en eficiencia; por ejemplo, ordenar una lista mediante selección tiene complejidad \(O(n^2)\), mientras que algoritmos como Quicksort o Mergesort logran \(O(n \log n)\) \cite{Pressman2019Software}. La eficiencia determina la escalabilidad de una solución y su aplicabilidad en escenarios de grandes volúmenes de datos \cite{Sommerville2015Software}.
					
					La combinación de correctitud y eficiencia constituye el fundamento de la calidad algorítmica. Un algoritmo correcto pero ineficiente podría ser impracticable, mientras que uno eficiente pero incorrecto es inútil o peligroso \cite{Stallings2021Computer}. Por ello, el diseño de algoritmos exige equilibrar claridad, precisión y rendimiento desde las etapas iniciales del proceso de programación \cite{Pressman2019Software}.
					
					\subsubsection{Corrección parcial y total}
						La corrección parcial establece que, si el algoritmo termina, entonces su resultado es correcto de acuerdo con la especificación formal \cite{Sommerville2015Software}. Este tipo de corrección verifica la validez del resultado, pero no garantiza que el algoritmo siempre concluya su ejecución \cite{Pressman2019Software}. Un algoritmo con corrección parcial podría presentar ciclos infinitos bajo ciertas condiciones, lo que hace necesario evaluar adicionalmente su finitud \cite{Stallings2021Computer}.
						
						La corrección total combina la corrección parcial con la finitud, exigiendo que el algoritmo siempre termine y que lo haga produciendo el resultado correcto \cite{Tanenbaum2021Structured}. Esta propiedad es más estricta y se considera el estándar de calidad en sistemas donde la terminación es crítica, como en control industrial, sistemas bancarios y aplicaciones embebidas \cite{Sommerville2015Software}. La literatura enfatiza que demostrar corrección total requiere analizar tanto la validez lógica de los pasos como las condiciones de terminación \cite{Pressman2019Software}.
						
						La verificación formal de algoritmos mediante métodos matemáticos, invariantes de bucles y pruebas estructuradas permite establecer corrección parcial y total con rigor científico \cite{Stallings2021Computer}. Esta verificación es esencial en contextos de alta confiabilidad y se apoya en herramientas computacionales que automatizan parte del proceso \cite{Sommerville2015Software}. Al aplicar estas técnicas, se garantiza que un algoritmo sea fiable, predecible y adecuado para sistemas complejos \cite{Pressman2019Software}.
						
					\subsubsection{Eficiencia intuitiva}
						La eficiencia intuitiva se refiere a la capacidad del programador para estimar el rendimiento de un algoritmo basándose en su estructura, sin necesidad inmediata de análisis formal \cite{Pressman2019Software}. Esta intuición permite identificar rápidamente soluciones potencialmente ineficientes, como bucles anidados innecesarios o recorridos repetitivos de estructuras de datos \cite{Sommerville2015Software}. Aunque no reemplaza el análisis riguroso, la intuición sobre eficiencia guía la selección preliminar de técnicas algorítmicas \cite{Stallings2021Computer}.
						
						Por ejemplo, un programador reconoce intuitivamente que ordenar una lista dos veces es menos eficiente que ordenar una sola vez, o que una búsqueda lineal es menos eficiente que una búsqueda binaria en listas ordenadas \cite{Tanenbaum2021Structured}. Este conocimiento se adquiere mediante experiencia, práctica y estudio de patrones de solución comunes \cite{Gaddis2022Starting}. La eficiencia intuitiva permite mejorar el rendimiento desde etapas tempranas de diseño antes de confirmar mediante análisis formal \cite{Pressman2019Software}.
						
						Finalmente, la eficiencia intuitiva promueve la toma de decisiones informadas sobre estructuras de datos y técnicas de programación, contribuyendo al desarrollo de algoritmos más robustos y escalables \cite{Sommerville2015Software}. La literatura enfatiza que los programadores deben combinar intuición con herramientas formales como notación Big-O y análisis empírico para lograr soluciones equilibradas y eficientes \cite{Stallings2021Computer}.
						
			\section{Lenguajes formales y lenguajes de programación}
			% Sintaxis vs semántica, errores sintácticos y lógicos.
				Los lenguajes formales proporcionan reglas sintácticas y semánticas que definen cómo deben estructurarse las expresiones y cómo debe interpretarse su significado, constituyendo la base teórica de los lenguajes de programación \cite{Tanenbaum2021Structured}. Estos lenguajes permiten especificar algoritmos de manera precisa y verificable mediante gramáticas, alfabetos, producciones y modelos matemáticos, como autómatas y máquinas de Turing \cite{Sommerville2015Software}. Su estudio es fundamental para comprender cómo los programas son analizados y traducidos por compiladores e intérpretes \cite{Stallings2021Computer}.
				
				Los lenguajes de programación, construidos sobre los principios de los lenguajes formales, permiten implementar algoritmos en una forma que pueda ejecutarse en una computadora \cite{Gaddis2022Starting}. Cada lenguaje incorpora reglas sintácticas estrictas y modelos semánticos que describen cómo deben ejecutarse las instrucciones, asegurando predictibilidad y consistencia en los resultados \cite{Pressman2019Software}. La elección de un lenguaje depende de factores como el dominio del problema, la eficiencia requerida, la portabilidad y la facilidad de mantenimiento \cite{Sommerville2015Software}.
				
				\subsection{Sintaxis}
					La sintaxis describe la estructura válida de instrucciones, expresiones y programas dentro de un lenguaje de programación, definiendo cómo deben organizarse los símbolos para formar construcciones correctas \cite{Tanenbaum2021Structured}. Los compiladores realizan análisis sintáctico para verificar que el código cumpla con estas reglas antes de traducirlo a instrucciones ejecutables, proceso ampliamente documentado en textos de construcción de compiladores \cite{Stallings2021Computer}. La sintaxis evita ambigüedades y garantiza que el código sea comprensible por la máquina y por otros programadores \cite{Gaddis2022Starting}.
					
					Errores sintácticos como falta de paréntesis, comas incorrectas o instrucciones mal formadas son detectados en esta etapa, permitiendo corregirlos antes de la ejecución \cite{Pressman2019Software}. La claridad sintáctica contribuye a la mantenibilidad y legibilidad del código, y es un componente esencial en la calidad del software \cite{Sommerville2015Software}. Por ello, los lenguajes modernos incorporan reglas explícitas y herramientas que ayudan a detectar errores sintácticos de forma temprana \cite{Stallings2021Computer}.
					
					\subsubsection{Reglas gramaticales}
						Las reglas gramaticales de un lenguaje de programación describen, mediante una gramática formal, cómo pueden combinarse los símbolos del lenguaje (palabras clave, identificadores, operadores, delimitadores) para formar construcciones válidas como sentencias, bloques y programas completos \cite{Tanenbaum2021Structured}. Estas gramáticas suelen especificarse en notaciones como BNF (Backus–Naur Form) o EBNF (Extended BNF), las cuales permiten expresar producciones del tipo \texttt{sentencia} ::= \texttt{if} \texttt{expresion} \texttt{then} \texttt{sentencia} \cite{Stallings2021Computer}. El uso de gramáticas formales facilita el análisis automático del código por parte de compiladores e intérpretes \cite{Sommerville2015Software}.
						
						Los analizadores sintácticos (\emph{parsers}) utilizan estas reglas gramaticales para construir árboles de derivación o árboles sintácticos que representan la estructura jerárquica del programa \cite{Pressman2019Software}. Por ejemplo, una expresión aritmética como \texttt{a + b * c} puede representarse como un árbol donde la multiplicación tiene mayor precedencia que la suma, lo cual refleja las reglas gramaticales del lenguaje \cite{Tanenbaum2021Structured}. La correcta definición de estas reglas evita ambigüedades y garantiza interpretaciones consistentes del código \cite{Stallings2021Computer}.
						
						En la literatura se enfatiza que las gramáticas de los lenguajes modernos se diseñan para ser no ambiguas o, al menos, para que la ambigüedad se resuelva mediante reglas adicionales de precedencia y asociatividad \cite{Sommerville2015Software}. Esto permite que el mismo programa sea interpretado de igual manera por diferentes compiladores conformes al estándar del lenguaje \cite{Pressman2019Software}. La precisión gramatical es por tanto un requisito para la portabilidad y la confiabilidad del software \cite{Stallings2021Computer}.
						
						% Figura TikZ: ejemplo de árbol sintáctico simple
						\begin{figure}[hbt!]
							\centering
							\begin{tikzpicture}[
								font=\small,
								level distance=12mm,
								every node/.style={inner sep=2pt},
								nonterm/.style={draw, rounded corners=3pt, thick, fill=blue!5, align=center},
								term/.style={draw, rounded corners=3pt, thick, fill=green!5, align=center},
								edge from parent/.style={->, thick}
								]
								\node[nonterm] {Expresión}
								child { node[nonterm] {Expresión}
									child { node[term] {a} }
								}
								child { node[term] {+} }
								child { node[nonterm] {Expresión}
									child { node[nonterm] {Término}
										child { node[term] {b} }
									}
									child { node[term] {*} }
									child { node[nonterm] {Término}
										child { node[term] {c} }
									}
								};
							\end{tikzpicture}
							\caption{Árbol sintáctico para la expresión \texttt{a + b * c} \cite{Tanenbaum2021Structured,Stallings2021Computer}.}
							\label{fig:arbol-sintactico}
						\end{figure}
							
					\subsubsection{Formación de expresiones}
						La formación de expresiones en un lenguaje de programación se rige por reglas que especifican cómo combinar operandos y operadores para producir valores \cite{Gaddis2022Starting}. Estas reglas definen qué operadores son válidos para cada tipo de dato, cuál es su precedencia y cómo se asocian en ausencia de paréntesis explícitos \cite{Tanenbaum2021Structured}. Por ejemplo, en la mayoría de lenguajes, la multiplicación tiene mayor precedencia que la suma, y operadores binarios como \texttt{+} o \texttt{-} suelen ser asociativos por la izquierda \cite{Stallings2021Computer}.
						
						Las expresiones no se limitan a operaciones aritméticas; incluyen también expresiones lógicas, relacionales y de concatenación de cadenas, cada una con semánticas específicas \cite{Sommerville2015Software}. Así, una expresión como \texttt{(edad > 18) \&\& (pais == "ECUADOR")} combina operadores relacionales y lógicos para producir un valor booleano que controla el flujo de ejecución \cite{Gaddis2022Starting}. La correcta comprensión de estas reglas es esencial para evitar errores sutiles en condiciones y decisiones \cite{Pressman2019Software}.
						
						Además, muchos lenguajes permiten sobrecarga de operadores, lo cual significa que el mismo símbolo puede tener significados distintos según los tipos de sus operandos (por ejemplo, \texttt{+} como suma numérica o concatenación de cadenas) \cite{Tanenbaum2021Structured}. Esta característica, aunque poderosa, puede introducir confusión si no se documenta y utiliza adecuadamente \cite{Sommerville2015Software}. La literatura recomienda emplear la sobrecarga con moderación y claridad para preservar la legibilidad \cite{Pressman2019Software}.
						
						Las expresiones también interactúan con conversiones implícitas y explícitas de tipos (``casting''), por lo que una formación incorrecta puede producir pérdida de información o resultados inesperados \cite{Stallings2021Computer}. Por ejemplo, dividir dos enteros puede generar un resultado entero truncado, mientras que dividir números de punto flotante conserva los decimales \cite{Gaddis2022Starting}. Estas diferencias deben considerarse cuidadosamente al diseñar algoritmos y escribir código \cite{Pressman2019Software}.
						
				\subsection{Semántica}
					La semántica de un lenguaje de programación describe el significado de las construcciones sintácticamente válidas, indicando qué efecto tienen sobre el estado del programa y del sistema al ejecutarse \cite{Tanenbaum2021Structured}. Mientras la sintaxis responde a la pregunta ``¿está bien formada esta instrucción?'', la semántica responde ``¿qué hace esta instrucción?'', tal como se discute en la literatura de lenguajes formales y compiladores \cite{Stallings2021Computer}. La semántica puede describirse de manera informal (texto natural), operacional (mediante máquinas abstractas) o denotacional (mediante funciones matemáticas) \cite{Sommerville2015Software}.
					
					Comprender la semántica es fundamental para razonar sobre la corrección y el comportamiento del programa, especialmente en presencia de estructuras de control, llamadas a funciones, recursión y manejo de memoria \cite{Pressman2019Software}. Por ejemplo, dos fragmentos de código pueden ser sintácticamente válidos pero semánticamente diferentes si modifican variables de formas distintas o si manejan errores de manera divergente \cite{Gaddis2022Starting}. La semántica precisa permite predecir el efecto de las instrucciones y verificar la adherencia a los requisitos del sistema \cite{Sommerville2015Software}.
					
					\subsubsection{Significado operativo}
						El significado operativo describe la semántica de un programa en términos de los pasos que realiza una máquina abstracta al ejecutar sus instrucciones \cite{Tanenbaum2021Structured}. Esta perspectiva se formaliza mediante la definición de estados del programa (valores de variables, posición en el código, contenido de memoria) y reglas de transición que indican cómo cada instrucción transforma dicho estado \cite{Stallings2021Computer}. De este modo, es posible modelar la ejecución como una secuencia de estados que evoluciona siguiendo la lógica del programa \cite{Sommerville2015Software}.
						
						Por ejemplo, una sentencia de asignación \texttt{x = x + 1;} puede interpretarse como una transición desde un estado en el que \texttt{x = n} a otro en el que \texttt{x = n + 1}, manteniendo constantes el resto de variables \cite{Pressman2019Software}. De manera similar, una instrucción condicional define bifurcaciones en el espacio de estados según el valor de la condición evaluada \cite{Tanenbaum2021Structured}. Esta visión facilita el análisis de flujos de control, la detección de caminos no alcanzables y la verificación de propiedades como invariantes de bucle \cite{Stallings2021Computer}.
						
						El significado operativo se utiliza tanto en la especificación formal de lenguajes como en herramientas de verificación y depuración, donde se simulan estados y transiciones para detectar errores \cite{Sommerville2015Software}. La comprensión de esta semántica permite a los programadores anticipar cómo se comportará el código en diferentes escenarios de ejecución, contribuyendo a un diseño más robusto y seguro \cite{Pressman2019Software}.
						
					\subsubsection{Errores semánticos}
						Los errores semánticos ocurren cuando el programa es sintácticamente correcto pero su comportamiento no coincide con la intención del programador o con la especificación del problema \cite{Gaddis2022Starting}. Por ejemplo, utilizar el operador de asignación en lugar del operador de comparación dentro de una condición, o aplicar la fórmula errónea para un cálculo, produce resultados incorrectos sin que el compilador detecte necesariamente un fallo \cite{Pressman2019Software}. Estos errores son especialmente peligrosos porque pueden pasar inadvertidos hasta que se observan resultados inconsistentes en producción \cite{Sommerville2015Software}.
						
						La detección de errores semánticos requiere análisis cuidadoso, pruebas exhaustivas y, en algunos casos, revisión por pares \cite{Stallings2021Computer}. Las técnicas de pruebas de caja negra y caja blanca, combinadas con revisiones de código y análisis estático, ayudan a identificar discrepancias entre el comportamiento observado y el comportamiento esperado \cite{Pressman2019Software}. La comprensión profunda de la semántica del lenguaje y del dominio del problema es un factor clave para prevenir y corregir estos errores \cite{Sommerville2015Software}.
						
				\subsection{Errores comunes en principiantes}
					Los estudiantes que se inician en la programación suelen cometer errores recurrentes derivados de dificultades para comprender la sintaxis, la semántica y la lógica de los programas \cite{Gaddis2022Starting}. Entre los más frecuentes se encuentran omitir delimitadores, confundir operadores, utilizar tipos de datos inadecuados, diseñar condiciones incorrectas y olvidar casos especiales en estructuras de control \cite{Sommerville2015Software}. La literatura sobre enseñanza de la programación resalta la importancia de abordar explícitamente estos errores para favorecer el desarrollo de competencias sólidas \cite{Pressman2019Software}.
					
					Además, muchos principiantes tienden a centrarse en ``hacer que el programa funcione'' sin analizar si la solución es correcta, eficiente o mantenible \cite{Gaddis2022Starting}. Esta actitud puede conducir a código difícil de entender, duplicación de lógica y errores que reaparecen al introducir cambios \cite{Sommerville2015Software}. Por ello, se recomienda enfatizar buenas prácticas desde los primeros cursos, incluyendo trazado de código, diseño previo, pruebas sistemáticas y reflexión sobre la solución \cite{Pressman2019Software}.
					
					\subsubsection{Errores sintácticos}
						Los errores sintácticos se producen cuando el código viola las reglas de formación del lenguaje, como falta de paréntesis, llaves desbalanceadas, palabras clave mal escritas o uso incorrecto de signos de puntuación \cite{Gaddis2022Starting}. Estos errores impiden que el compilador o intérprete genere código ejecutable y suelen acompañarse de mensajes de error que indican la ubicación aproximada del problema \cite{Stallings2021Computer}. En general, los errores sintácticos se detectan en fases tempranas del proceso de compilación \cite{Tanenbaum2021Structured}.
						
						Los principiantes a menudo encuentran dificultades para interpretar los mensajes de error del compilador, que pueden referirse a la línea detectada aunque el problema se origine en líneas previas \cite{Gaddis2022Starting}. La literatura didáctica recomienda desarrollar el hábito de revisar cuidadosamente el código cercano a la posición indicada, buscando patrones comunes como delimitadores faltantes o mal ubicados \cite{Sommerville2015Software}. Comprender la relación entre gramática del lenguaje y mensajes de error facilita la corrección \cite{Pressman2019Software}.
						
						Para reducir errores sintácticos, se aconseja utilizar entornos de desarrollo que proporcionen resaltado de sintaxis, autocompletado y verificación incremental del código \cite{Stallings2021Computer}. Estas herramientas ayudan a detectar problemas mientras se escribe el programa, evitando acumulación de errores y mejorando la productividad \cite{Pressman2019Software}. No obstante, la responsabilidad última de comprender la sintaxis recae en el programador \cite{Gaddis2022Starting}.
						
					\subsubsection{Errores lógicos}
						Los errores lógicos ocurren cuando el programa se ejecuta sin generar errores sintácticos o de tiempo de ejecución, pero produce resultados incorrectos debido a fallos en el razonamiento o en el diseño de la solución \cite{Gaddis2022Starting}. Estos errores pueden surgir por condiciones mal formuladas, bucles que no cubren todos los casos, cálculos erróneos o uso inadecuado de variables \cite{Pressman2019Software}. A diferencia de los errores sintácticos, los errores lógicos no son detectados directamente por el compilador \cite{Sommerville2015Software}.
						
						Un ejemplo típico de error lógico es utilizar un operador relacional equivocado en una condición, como \texttt{>} en lugar de \texttt{>=}, lo que excluye un caso límite importante \cite{Gaddis2022Starting}. Otro caso frecuente es inicializar mal una variable de acumulación o contador, lo que afecta el resultado final de un cálculo iterativo \cite{Sommerville2015Software}. Estos errores pueden permanecer ocultos si las pruebas no cubren adecuadamente los casos de frontera \cite{Pressman2019Software}.
						
						La literatura sobre buenas prácticas recomienda utilizar técnicas de trazado de código (\emph{dry run}), depuración paso a paso y registro de valores intermedios para identificar el punto exacto en el que la lógica se desvía de lo esperado \cite{Gaddis2022Starting}. Estas estrategias permiten comparar el comportamiento real del programa con el comportamiento previsto en el diseño algorítmico \cite{Pressman2019Software}. En entornos educativos, el trazado manual es una herramienta clave para desarrollar comprensión profunda de la ejecución \cite{Sommerville2015Software}.
						
						Además, el uso de pruebas sistemáticas, incluyendo casos típicos, extremos y casos erróneos, es esencial para detectar errores lógicos \cite{Pressman2019Software}. Las pruebas de caja negra se centran en la relación entrada–salida, mientras que las pruebas de caja blanca analizan rutas internas del código \cite{Sommerville2015Software}. La combinación de ambas perspectivas incrementa la probabilidad de descubrir errores lógicos antes del despliegue \cite{Stallings2021Computer}.
						
						Finalmente, la prevención de errores lógicos se apoya en un buen diseño algorítmico, en la claridad del código y en la revisión por pares \cite{Pressman2019Software}. Documentar decisiones, añadir comentarios significativos y mantener un estilo coherente facilitan la detección temprana de inconsistencias \cite{Sommerville2015Software}. De este modo, la formación en pensamiento crítico y en metodologías de prueba resulta tan importante como el aprendizaje de la sintaxis del lenguaje \cite{Gaddis2022Starting}.
						
			\section{Buenas prácticas para aprender programación}
			% Estrategias de estudio, rol del error, trabajo individual y colaborativo.
				Aprender programación requiere no solo dominar la sintaxis de un lenguaje, sino también adoptar estrategias de estudio y prácticas sistemáticas que favorezcan el desarrollo del pensamiento algorítmico, la comprensión profunda del código y la capacidad de resolver problemas de forma estructurada \cite{Gaddis2022Starting}. La literatura en educación en computación destaca que los estudiantes que aplican métodos activos como trazado manual, depuración reflexiva y análisis de errores alcanzan niveles superiores de entendimiento y retención \cite{Sommerville2015Software}. Asimismo, el aprendizaje colaborativo, el uso de herramientas de apoyo y la aceptación del error como parte natural del proceso son aspectos fundamentales para consolidar la competencia programadora \cite{Pressman2019Software,Stallings2021Computer}.
				
				\subsection{Métodos de estudio}
					Los métodos de estudio en programación deben orientarse hacia la comprensión de los conceptos fundamentales que subyacen al código, evitando la memorización superficial que conduce a errores y dificultades para resolver problemas novedosos \cite{Gaddis2022Starting}. La investigación educativa sugiere que las estrategias efectivas incluyen leer y analizar código antes de ejecutarlo, trazar el estado de las variables, realizar ejercicios progresivos y reflexionar sobre los resultados \cite{Sommerville2015Software}. Estas prácticas fomentan el razonamiento lógico y la interpretación de algoritmos, elementos centrales en la formación de programadores \cite{Pressman2019Software}.
					
					Asimismo, se recomienda alternar entre estudio teórico y práctica deliberada, resolviendo ejercicios de complejidad creciente y comparando distintas aproximaciones a un mismo problema \cite{Stallings2021Computer}. Esta combinación permite integrar conocimientos y desarrollar intuición algorítmica, habilidades que fortalecen la autonomía del estudiante y su capacidad para enfrentar desafíos más avanzados \cite{Sommerville2015Software}. El uso de técnicas reflexivas, como explicar en voz alta el funcionamiento de un programa, ha mostrado efectos positivos en la retención y comprensión \cite{Gaddis2022Starting}.
					
					\subsubsection{Trazar código}
						Trazar código consiste en simular mental o manualmente la ejecución de un programa, registrando los cambios en las variables y el flujo de control paso a paso \cite{Gaddis2022Starting}. Esta técnica es fundamental para detectar errores lógicos, comprender estructuras de control y verificar la coherencia entre el algoritmo y su implementación \cite{Sommerville2015Software}. La literatura destaca que el trazado permite visualizar la dinámica del programa, facilitando la anticipación de comportamientos imprevistos \cite{Pressman2019Software}.
						
						El uso sistemático del trazado ayuda a comprender cómo se modifican los valores, cómo se recorren estructuras de datos y cómo se activan y desactivan diferentes ramas de ejecución \cite{Stallings2021Computer}. Por ejemplo, en un bucle que calcula la suma de los primeros \(n\) números, trazar el estado de las variables \texttt{i} y \texttt{suma} permite verificar si las actualizaciones se realizan correctamente en cada iteración \cite{Gaddis2022Starting}. Este análisis detallado contribuye a desarrollar habilidades de depuración y razonamiento algorítmico \cite{Sommerville2015Software}.
						
						El trazado también es útil para comparar la ejecución real del programa con la esperada según el diseño algorítmico \cite{Pressman2019Software}. Esta comparación revela discrepancias entre implementación e intención, lo que facilita corregir errores y mejorar la calidad del código \cite{Stallings2021Computer}. Por ello, se considera una de las prácticas centrales en los cursos iniciales de programación \cite{Gaddis2022Starting}.
						
						% Figura TikZ: Ejemplo de trazado simple
						\begin{figure}[hbt!]
							\centering
							\begin{tikzpicture}[
								font=\small,
								table/.style={draw, thick, fill=gray!10, minimum width=45mm, minimum height=6mm, align=center},
								arrow/.style={->, thick},
								node distance=5mm
								]
								\node[table] (h1) {i=1,\ suma=0};
								\node[table, below=of h1] (h2) {i=2,\ suma=1};
								\node[table, below=of h2] (h3) {i=3,\ suma=3};
								\node[table, below=of h3] (h4) {i=4,\ suma=6};
								\draw[arrow] (h1) -- (h2);
								\draw[arrow] (h2) -- (h3);
								\draw[arrow] (h3) -- (h4);
							\end{tikzpicture}
							\caption{Trazado de un algoritmo que suma los primeros \(n\) números naturales \cite{Gaddis2022Starting,Sommerville2015Software}.}
							\label{fig:trazado}
						\end{figure}
						
					\subsubsection{Escribir antes que ejecutar}
						La práctica de escribir el algoritmo o el pseudocódigo antes de ejecutar el programa fomenta claridad conceptual y reduce errores comunes asociados a improvisación o dependencia excesiva del entorno de ejecución \cite{Pressman2019Software}. La literatura subraya que esta estrategia permite a los estudiantes organizar sus ideas, prever la estructura del programa y anticipar la interacción entre variables y estructuras de control \cite{Sommerville2015Software}. De este modo, escribir antes de ejecutar fortalece la planificación lógica previa a la codificación \cite{Stallings2021Computer}.
						
						Cuando los principiantes ejecutan el código sin un diseño previo, tienden a introducir cambios impulsivos que complican la detección de errores y deterioran la estructura del programa \cite{Gaddis2022Starting}. Al escribir primero, se puede analizar la solución con calma, aplicar principios de diseño modular y simplificar pasos innecesarios \cite{Pressman2019Software}. Este enfoque incrementa la calidad del código desde sus primeras versiones, disminuyendo la cantidad de errores arrastrados a etapas posteriores \cite{Sommerville2015Software}.
						
						Además, escribir antes de ejecutar promueve la reflexión sobre alternativas algorítmicas, permitiendo comparar diferentes formas de resolver un mismo problema \cite{Stallings2021Computer}. Por ejemplo, antes de implementar una búsqueda, el estudiante puede evaluar si utilizará búsqueda lineal o binaria, dependiendo del tamaño y la estructura de los datos \cite{Tanenbaum2021Structured}. Esta reflexión previa contribuye al aprendizaje de patrones de solución y a la mejora de la eficiencia \cite{Pressman2019Software}.
						
						Finalmente, esta práctica facilita la comunicación y la revisión por pares, ya que el pseudocódigo es más accesible y menos dependiente de detalles del lenguaje que el código fuente completo \cite{Sommerville2015Software}. Las revisiones tempranas basadas en pseudocódigo permiten detectar errores conceptuales sin el ruido adicional de la sintaxis \cite{Gaddis2022Starting}. Por estas razones, escribir antes de ejecutar es considerada una buena práctica tanto en contextos educativos como profesionales \cite{Pressman2019Software}.
						
				\subsection{La importancia del error}
					El error desempeña un papel fundamental en el aprendizaje de la programación, ya que permite identificar malentendidos, explorar límites conceptuales y desarrollar habilidades de depuración \cite{Gaddis2022Starting}. La literatura educativa establece que los estudiantes que interpretan el error como una oportunidad de aprendizaje, y no como un fracaso, adquieren competencias más sólidas y persistentes en pensamiento computacional \cite{Sommerville2015Software}. Las técnicas de depuración, análisis y revisión de código se apoyan directamente en esta disposición positiva frente al error \cite{Pressman2019Software}.
					
					Además, el error proporciona retroalimentación valiosa que guía la reestructuración de conceptos y corrige modelos mentales incorrectos \cite{Stallings2021Computer}. Al equivocarse, el estudiante debe revisar su razonamiento, contrastarlo con el comportamiento real del programa y ajustar su comprensión de la lógica computacional \cite{Pressman2019Software}. Este ciclo de autoevaluación y mejora continua es esencial tanto en entornos académicos como en el desarrollo profesional de software \cite{Sommerville2015Software}.
					
				\subsection{Trabajo colaborativo}
					El trabajo colaborativo favorece la construcción conjunta de conocimiento y mejora la capacidad de resolver problemas mediante discusión, análisis compartido y revisión mutua \cite{Sommerville2015Software}. En programación, la colaboración permite que los estudiantes contrasten sus soluciones, detecten errores que individualmente pasarían desapercibidos y aprendan diferentes estilos y estrategias de razonamiento computacional \cite{Pressman2019Software}. Las metodologías ágiles y el desarrollo en pareja (\emph{pair programming}) se apoyan en estos principios colaborativos \cite{Stallings2021Computer}.
					
					Asimismo, la colaboración desarrolla competencias transversales como comunicación efectiva, negociación de ideas, organización de tareas y gestión conjunta del tiempo \cite{Sommerville2015Software}. Estas habilidades resultan esenciales en entornos profesionales de desarrollo de software, donde la construcción de sistemas complejos requiere coordinación entre múltiples roles y equipos \cite{Pressman2019Software}. La literatura señala que el trabajo colaborativo incrementa significativamente la calidad del código y la motivación de los estudiantes \cite{Gaddis2022Starting}.
					
				\subsection{Herramientas de apoyo}
					Las herramientas de apoyo facilitan el aprendizaje de la programación mediante asistencia sintáctica, ejecución controlada, visualización de estructuras y automatización de pruebas \cite{Gaddis2022Starting}. Entre las más utilizadas se encuentran los entornos de desarrollo integrado (IDE), que ofrecen resaltado de sintaxis, autocompletado, depuración paso a paso y monitoreo del estado de variables \cite{Pressman2019Software}. Estas funcionalidades permiten detectar errores más rápidamente y comprender el flujo de ejecución del programa \cite{Sommerville2015Software}.
					
					Además, herramientas especializadas como simuladores de memoria, visualizadores de algoritmos y plataformas de aprendizaje interactivo ayudan a los estudiantes a desarrollar una comprensión más profunda de conceptos internos como pilas, colas, memoria dinámica o recursión \cite{Stallings2021Computer}. Estas herramientas permiten observar visualmente lo que ocurre durante la ejecución, facilitando la relación entre teoría y práctica \cite{Gaddis2022Starting}. La literatura destaca que las visualizaciones incrementan la retención y la comprensión conceptual \cite{Sommerville2015Software}.
					
					Los sistemas de control de versiones, como Git, también constituyen herramientas esenciales que permiten gestionar cambios, colaborar en proyectos, explorar alternativas y revertir errores \cite{Pressman2019Software}. Su uso temprano en la formación ayuda a fomentar disciplina técnica, trazabilidad y orden en el desarrollo \cite{Sommerville2015Software}. De este modo, las herramientas de apoyo complementan el aprendizaje teórico y fortalecen las competencias prácticas en programación \cite{Stallings2021Computer}.
					
		%-----------------------------------------
		\chapter{Algoritmos y Representación Estructurada}
		%-----------------------------------------
			Los algoritmos constituyen la base operativa de todo sistema computacional, pues describen de forma precisa y finita la secuencia de pasos necesaria para transformar datos de entrada en resultados válidos. Su estudio permite comprender cómo los sistemas realizan procesos de decisión, cálculo y control, integrándose con los fundamentos conceptuales presentados en el capítulo anterior, donde se estableció el papel central de la información y su procesamiento en los sistemas computacionales \cite{Sommerville2015Software,Pressman2019Software,Silberschatz2018Operating}. La formalización algorítmica, además, posibilita la automatización fiable de tareas y asegura que las soluciones obtenidas sean reproducibles, verificables y coherentes bajo distintos escenarios de ejecución \cite{Tanenbaum2021Structured,spivak2011}.
			
			\section{Terminología básica de algoritmos}
			% Instancia del problema, estado, instrucción, operación básica, traza.
				El análisis formal de algoritmos requiere un conjunto de conceptos fundamentales que permiten describir, con precisión, los elementos que intervienen en la resolución automática de problemas. Estas nociones son compartidas en la literatura moderna de ingeniería de software, ciencias de la computación y diseño de sistemas, donde la claridad terminológica es esencial para garantizar la consistencia y verificabilidad de los procesos \cite{Sommerville2015Software,Pressman2019Software}. A través de esta sección se definen los componentes básicos que sustentan la representación estructurada de algoritmos y que habilitan su implementación posterior en lenguajes de programación.
				
				En un nivel conceptual, los algoritmos se consideran mecanismos de transformación que actúan sobre representaciones simbólicas de datos, siguiendo reglas bien definidas y ordenadas de forma explícita \cite{Silberschatz2018Operating,Tanenbaum2021Structured}. Este enfoque coincide con los principios de formalización empleados en teoría de autómatas, modelos computacionales y metodologías de diseño, donde se enfatiza la importancia de describir cada paso como una operación elemental e inequívoca. La existencia de una terminología estandarizada permite establecer equivalencias entre descripciones informales, pseudocódigo y lenguajes estructurados.
				
				Finalmente, estos conceptos fundamentales se conectan con la estructura lógica que compone todo algoritmo, la cual se desarrolla en secciones posteriores. Dicha estructura—secuencia, selección e iteración—ha sido ampliamente discutida en la literatura y constituye el fundamento de los lenguajes imperativos modernos \cite{Pressman2019Software,abid2020}. Con ello se establece un marco conceptual coherente para interpretar, analizar y diseñar algoritmos robustos, eficientes y verificables.
				
				\subsection{Instancia del problema}
					Una \textit{instancia del problema} se define como un conjunto específico de valores de entrada para los cuales se debe ejecutar un algoritmo con el fin de producir un resultado concreto. Mientras que el problema describe la tarea de forma general, la instancia delimita un caso particular, permitiendo evaluar el comportamiento del algoritmo bajo condiciones específicas \cite{Sommerville2015Software}. Esta distinción es esencial para analizar la corrección y el rendimiento, ya que un mismo algoritmo puede comportarse de manera distinta dependiendo de los datos sobre los que opera.
					
					La noción de instancia es ampliamente utilizada en complejidad algorítmica, donde se estudia cómo varía el tiempo de ejecución o el uso de memoria conforme se modifican los tamaños de entrada \cite{Tanenbaum2021Structured}. También es fundamental en pruebas de software, pues permite seleccionar casos representativos —incluyendo valores normales, extremos y fronteras— para validar que el algoritmo se comporte de forma consistente y segura \cite{Pressman2019Software}. En este sentido, una instancia no es solo un conjunto de datos, sino un elemento esencial del proceso de verificación.
					
					\textbf{Ejemplo 1:} Consideremos el algoritmo que determina si una persona puede acceder a un recinto según su edad. El problema general es «verificar si la edad cumple el requisito mínimo». Una instancia concreta sería: \textit{edad = 17 años}. El algoritmo evaluará esta entrada y producirá como salida «acceso denegado». El algoritmo formal puede ser como el que se muestra en el listado de código \ref{alg:accesoEdad}
					
					\begin{lstlisting}[caption={Algoritmo para determinar si una persona puede acceder al recinto}, label={alg:accesoEdad}]
	Algoritmo VerificarAcceso
	Entrada: edad
	Salida: mensaje de acceso
	
	1. Si edad >= 18 entonces
	2.     mensaje <- "Acceso permitido"
	3. SiNo
	4.     mensaje <- "Acceso denegado"
	5. FinSi
	6. Devolver mensaje
	FinAlgoritmo \end{lstlisting}
					
					\textbf{Ejemplo 2:} Para el problema general «calcular el máximo común divisor entre dos enteros», una instancia sería el par de valores \((84, 36)\). El algoritmo lista para ser implementado en el lenguaje de programación de la preferencia del lector se muestra en el listado de código \ref{alg:mcdEuclides}. Al ejecutar el algoritmo de Euclides sobre esta instancia, el resultado obtenido será \(12\).
					
					\begin{lstlisting}[caption={Cálculo del máximo común divisor entre dos números}, label={alg:mcdEuclides}]
	Algoritmo CalcularMCD
	Entrada: a, b
	Salida: mcd
	
	1. Mientras b != 0 hacer
	2.     r <- a mod b
	3.     a <- b
	4.     b <- r
	5. FinMientras
	6. mcd <- a
	7. Devolver mcd
	FinAlgoritmo \end{lstlisting}
					
					\textbf{Ejemplo 3:} En el problema de «determinar si un usuario puede autenticar en un sistema», una instancia concreta se compone del usuario \texttt{juan.perez} y la contraseña ingresada. El algoritmo de autenticación procesará estos datos y decidirá si conceder o no el acceso(ver listado de código \ref{alg:autenticacion}), siguiendo reglas formales definidas \cite{Silberschatz2018Operating}.
					
					\begin{lstlisting}[caption={Algoritmo simplificado de autenticación de usuario}, label={alg:autenticacion}]
	Algoritmo AutenticarUsuario
	Entrada: usuarioIngresado, contraseniaIngresada
	Salida: resultado
	
	1. Recuperar contraseniaReal del sistema para usuarioIngresado
	2. Si usuarioIngresado no existe entonces
	3.     resultado <- "Usuario no encontrado"
	4.     Devolver resultado
	5. FinSi
	6. Si contraseniaIngresada = contraseniaReal entonces
	7.     resultado <- "Acceso concedido"
	8. SiNo
	9.     resultado <- "Acceso denegado"
	10. FinSi
	11. Devolver resultado
	FinAlgoritmo \end{lstlisting}
					
				\subsection{Estado y transición}
					El \textit{estado} de un algoritmo se define como la configuración actual de todas las variables, estructuras de datos y parámetros relevantes en un momento determinado de su ejecución. Esta noción permite modelar el comportamiento computacional como una evolución ordenada, donde cada paso modifica el estado anterior produciendo uno nuevo, siguiendo reglas bien definidas \cite{Sommerville2015Software}. La representación explícita del estado facilita el análisis de corrección, especialmente en problemas donde intervienen condiciones, ciclos o estructuras de control complejas.
					
					Una \textit{transición} describe el cambio de un estado a otro como consecuencia de ejecutar una operación elemental del algoritmo. Estas transiciones, que constituyen la dinámica interna del proceso computacional, deben ser determinísticas y reproducibles para asegurar que el algoritmo produzca siempre los mismos resultados ante la misma instancia del problema \cite{Pressman2019Software}. La teoría de sistemas y los modelos de autómatas formales utilizan el concepto de transición para caracterizar comportamientos verificables, lo que resulta fundamental para garantizar consistencia en el diseño de software.
					
					En el contexto de los sistemas computacionales, el seguimiento del estado permite comprender cómo los datos fluyen y se transforman a lo largo del algoritmo, lo cual coincide con los principios de representación y manipulación del conocimiento señalados por Silberschatz et al. \cite{Silberschatz2018Operating} y por Spivak y Kent \cite{spivak2011}. Esta visión es especialmente útil en la depuración, ya que los errores suelen manifestarse como estados inesperados o inconsistentes que no cumplen las condiciones definidas.
					
					\textbf{Ejemplo 1:} Para un algoritmo que califica el desempeño de un estudiante según su nota, el estado inicial consiste en el valor ingresado para la nota. Tras evaluar si la nota es mayor o igual que 90, el estado cambia para reflejar la asignación de la categoría “Excelente”, tal como se muestra en el listado de código \ref{alg:desempeno}. Cada comparación y asignación representa una transición entre estados.
					\begin{lstlisting}[caption={Algoritmo para clasificar el desempeño de un estudiante}, label={alg:desempeno}]
	Algoritmo ClasificarDesempeno
	Entrada: nota
	Salida: categoria
	
	1. Si nota >= 90 entonces
	2.     categoria <- "Excelente"
	3. SiNo
	4.     Si nota >= 80 entonces
	5.         categoria <- "Muy bueno"
	6.     SiNo
	7.         Si nota >= 70 entonces
	8.             categoria <- "Bueno"
	9.         SiNo
	10.            categoria <- "Insuficiente"
	11.        FinSi
	12.    FinSi
	13. FinSi
	
	14. Devolver categoria
	FinAlgoritmo \end{lstlisting}
					
					\textbf{Ejemplo 2:} En el cálculo iterativo del factorial de un número, el estado está compuesto por la variable acumuladora y la variable de control del ciclo. Cada iteración produce una transición al multiplicar el acumulador por el valor actual del contador, reflejando la evolución ordenada del cálculo.
					
					\begin{lstlisting}[caption={Algoritmo iterativo para calcular el factorial}, label={alg:factorialIterativo}]
	Algoritmo CalcularFactorial
	Entrada: n
	Salida: resultado
	
	1. resultado <- 1
	2. contador <- 1
	
	3. Mientras contador <= n hacer
	4.     resultado <- resultado * contador
	5.     contador <- contador + 1
	6. FinMientras
	
	7. Devolver resultado
	FinAlgoritmo \end{lstlisting}
					
					\textbf{Ejemplo 3:} En un proceso de autenticación, el estado inicial contiene las credenciales ingresadas. Tras consultar la base de datos, se genera un nuevo estado que indica si el usuario existe. Posteriormente, otra transición determina si la contraseña coincide, produciendo un estado final que representa “Acceso concedido” o “Acceso denegado” \cite{Silberschatz2018Operating}. En el listado de código \ref{alg:autenticacionEstados} se muestra una de las opciones de un algoritmo formal para este problema.
					
					\begin{lstlisting}[caption={Algoritmo de autenticación basado en cambios de estado}, label={alg:autenticacionEstados}]
	Algoritmo Autenticar
	Entrada: usuarioIngresado, contraseniaIngresada
	Salida: estadoFinal
	
	1. estado <- "Credenciales recibidas"
	
	2. Si usuarioIngresado no existe en la base de datos entonces
	3.     estado <- "Usuario no encontrado"
	4.     Devolver estado
	5. FinSi
	
	6. estado <- "Usuario encontrado"
	7. Recuperar contraseniaReal del sistema
	
	8. Si contraseniaIngresada = contraseniaReal entonces
	9.     estado <- "Acceso concedido"
	10. SiNo
	11.    estado <- "Acceso denegado"
	12. FinSi
	
	13. Devolver estado
	FinAlgoritmo \end{lstlisting}
					
				\subsection{Operaciones básicas}
					Las operaciones básicas constituyen las unidades mínimas de acción de un algoritmo y representan los pasos elementales que modifican el estado del sistema de forma controlada y verificable. La literatura clásica en sistemas operativos y organización computacional describe estas operaciones como acciones atómicas que deben poder ejecutarse de manera determinista y sin ambigüedad \cite{Silberschatz2018Operating,Tanenbaum2021Structured}. Entre ellas se encuentran la asignación, la comparación, el acceso a memoria, la lectura de entrada y la escritura de salida, todas fundamentales para la construcción de procesos más complejos.
					
					En ingeniería de software, estas operaciones permiten descomponer algoritmos en pasos que pueden analizarse individualmente en términos de corrección, complejidad y efectos sobre las estructuras de datos \cite{Pressman2019Software}. Esta descomposición facilita el razonamiento estructurado y la verificación formal, ya que cada operación puede considerarse como una transición entre estados claramente definidos. Además, conocer el conjunto de operaciones básicas resulta esencial para identificar cuellos de botella y optimizaciones potenciales.
					
					Desde la perspectiva del diseño algorítmico, la correcta identificación de las operaciones elementales permite modelar el comportamiento computacional de manera uniforme, manteniendo coherencia entre pseudocódigo, implementación y pruebas \cite{Sommerville2015Software}. En particular, muchas técnicas de análisis —como el conteo de operaciones en complejidad temporal— dependen de reconocer qué acciones se consideran básicas y cuántas veces se ejecutan para una instancia del problema.
					
					Estas operaciones también cumplen un rol fundamental en la interacción con el entorno, pues mediante la entrada y salida se establece la comunicación entre los datos iniciales y los resultados obtenidos. La claridad en su especificación previene inconsistencias y asegura que el algoritmo responda adecuadamente a diferentes tipos de entrada, incluidas aquellas consideradas casos límite o valores no previstos \cite{Silberschatz2018Operating}. Este enfoque robusto contribuye al diseño de soluciones confiables que puedan integrarse en sistemas mayores.
					
					Finalmente, las operaciones básicas permiten establecer analogías entre algoritmos de distintos dominios, dado que comparten una estructura común basada en manipular estados y producir transiciones ordenadas. Esto facilita la enseñanza, el análisis comparativo y la reutilización conceptual en distintas áreas de la computación, reforzando la universalidad y aplicabilidad de los principios algorítmicos \cite{Pressman2019Software}.
					
					\subsubsection{Asignación simple}
						La asignación simple es la operación mediante la cual se establece un valor específico a una variable, representando una transición directa del estado del algoritmo. Esta operación es fundamental porque constituye el mecanismo primario de almacenamiento y actualización de información durante la ejecución \cite{Sommerville2015Software,Pressman2019Software}. En términos computacionales, la asignación simple se considera una instrucción elemental que suele ejecutarse en tiempo constante, razón por la cual desempeña un rol clave en el razonamiento algorítmico \cite{Tanenbaum2021Structured,Stallings2021Computer}. Para principiantes, comprender esta operación implica reconocer que el símbolo de asignación no representa igualdad matemática, sino transferencia de valor, lo que establece una diferencia conceptual necesaria en lenguajes de programación.
						
						\textbf{Ejemplo:} Si una variable \texttt{precio} almacena el costo de un producto, entonces la instrucción \texttt{precio <- 12.50} establece el estado inicial del sistema respecto al valor monetario. Posteriormente, todas las operaciones que utilicen \texttt{precio} dependerán de esta asignación.
						
						\textbf{Ejercicio:} Escriba un algoritmo que defina las variables \texttt{nombre}, \texttt{edad} y \texttt{ciudad}, asignando a cada una un valor inicial. El algoritmo debe imprimir los valores asignados.
						
						\begin{lstlisting}[caption={Algoritmo que define variables y muestra sus valores iniciales}, label={alg:variablesIniciales}]
	Algoritmo DefinirVariables
	Entrada: nombre, edad, ciudad
	Salida: impresión de los valores
	
	1. nombre <- "Juan"
	2. edad <- 25
	3. ciudad <- "Quito"
	
	4. Escribir "Nombre: ", nombre
	5. Escribir "Edad: ", edad
	6. Escribir "Ciudad: ", ciudad
	
	FinAlgoritmo \end{lstlisting}
						
					\subsubsection{Asignación compuesta}
						La asignación compuesta combina una operación aritmética con la actualización de una variable. Esta forma de asignación es relevante porque reduce la complejidad sintáctica y permite expresar de manera directa transformaciones del estado interno del algoritmo \cite{Pressman2019Software}. Silberschatz et al. \cite{Silberschatz2018Operating} destacan que estas operaciones encapsulan el patrón general de leer, operar y escribir sobre la misma ubicación de memoria, facilitando la comprensión del flujo de cómputo. Para estudiantes principiantes, su uso permite familiarizarse con la noción de actualización incremental o acumulativa, frecuente en algoritmos iterativos.
						
						\textbf{Ejemplo 1:} La instrucción \texttt{promedio <- suma / n} le asigna a la variable promedio se le asigna (almacena) el valor resultado de la división del valor almacenado en la variable \texttt{suma} para el valor almacenado en la variable \texttt{n}. Esta operación es común en algoritmos estadísticos como es cálculo del promedio. Para ello, se debió calcular la \texttt{suma} de los \texttt{n} valores que intervienen en este proceso.
						
						\textbf{Ejemplo 2:} La instrucción \texttt{total <- total + 5} incrementa el valor almacenado en \texttt{total}, siendo equivalente a recuperar su valor previo, sumarle 5 y almacenar el resultado. Esta operación es común en cálculos financieros y en algoritmos de conteo.
						
						\textbf{Ejercicio:} Diseñe un algoritmo que reciba un valor inicial \texttt{x} y lo incremente sucesivamente mediante asignaciones compuestas para representar el crecimiento acumulado de un ahorro.
						
						\begin{lstlisting}[caption={Algoritmo que incrementa un valor x mediante asignaciones compuestas para modelar ahorro acumulado}, label={alg:ahorroCompuesto}]
	Algoritmo AhorroAcumulado
	Entrada: x, incremento, periodos
	Salida: valor final del ahorro
	
	1. Escribir "Ingrese el valor inicial del ahorro (x):"
	2. Leer x
	
	3. Escribir "Ingrese el valor del incremento periódico:"
	4. Leer incremento
	
	5. Escribir "Ingrese el número de periodos:"
	6. Leer periodos
	
	7. contador <- 1
	
	8. Mientras contador <= periodos hacer
	9.     x = x + incremento        // Asignación compuesta
	10.    Escribir "Periodo ", contador, ": ", x
	11.    contador <- contador + 1
	12. FinMientras
	
	13. Escribir "El valor final del ahorro es: ", x
	
	FinAlgoritmo \end{lstlisting}
												
					\subsubsection{Asignación en cascada}
						La asignación en cascada consiste en efectuar múltiples asignaciones dentro de una misma instrucción, permitiendo que varios identificadores reciban el mismo valor. Aunque su sintaxis depende del lenguaje, su comprensión conceptual favorece la construcción de estados iniciales consistentes \cite{Sommerville2015Software}. Desde la perspectiva de eficiencia, Stallings \cite{Stallings2021Computer} explica que esta operación puede optimizar el número de instrucciones ejecutadas, aunque su uso debe acompañarse de claridad semántica para evitar ambigüedades.
						
						\textbf{Ejemplo:} Si se desea inicializar tres variables con el mismo valor, una instrucción como \texttt{a <- b <- c <- 0} establece un estado uniforme para todas ellas (cuando el lenguaje lo permite), lo cual es útil en algoritmos que requieren sincronización inicial.
						
						\textbf{Ejercicio 1:} Construya un algoritmo que inicialice tres variables \texttt{nota1}, \texttt{nota2} y \texttt{notaFinal} en cero utilizando asignación en cascada.
						
						\begin{lstlisting}[caption={Algoritmo que inicializa variables usando asignación en cascada}, label={alg:asignacionCascada}]
	Algoritmo InicializarNotas
	Entrada: nota1, nota2, notaFinal
	Salida: variables inicializadas
	
	1. nota1 <- nota2 <- notaFinal <- 0
	
	2. Escribir "Valores inicializados:"
	3. Escribir "nota1 = ", nota1
	4. Escribir "nota2 = ", nota2
	5. Escribir "notaFinal = ", notaFinal
	
	FinAlgoritmo \end{lstlisting}
						
						\textbf{Ejercicio 2:} Diseñe un algoritmo que solicite al usuario una temperatura expresada en grados Celsius mediante una operación de entrada. El valor ingresado deberá asignarse en cascada a varias variables con el propósito de preservar intacto el dato original y, simultáneamente, disponer de copias que permitan calcular su equivalente en otras escalas de temperatura. A partir de dicho valor inicial, el algoritmo deberá obtener las conversiones correspondientes en grados Fahrenheit, Kelvin y Rankine, y finalmente mostrar en pantalla todas las temperaturas calculadas, manteniendo siempre el valor original como referencia.
						
						\begin{lstlisting}[caption={Asignación en cascada aplicada a la conversión de temperaturas}, label={alg:cascadaConversion}]
	Algoritmo ConversionTemperaturas
	Entrada: celsiusOriginal, fahrenheit, kelvin, rankine
	Salida: conversiones
	
	1. Escribir "Ingrese la temperatura en grados Celsius:"
	2. Leer tempC
	
	// Asignación en cascada: todas las variables reciben el valor inicial leído
	3. celsiusOriginal <- fahrenheit <- kelvin <- rankine <- tempC
	
	// Uso posterior del valor original
	4. fahrenheit <- (fahrenheit * 9/5) + 32
	5. kelvin <- kelvin + 273.15
	6. rankine <- (rankie + 273.15) * 9/5
	
	7. Escribir "Temperatura original en Celsius: ", celsiusOriginal
	8. Escribir "En Fahrenheit: ", fahrenheit
	9. Escribir "En Kelvin: ", kelvin
	10. Escribir "En Rankine: ", rankine
	
	FinAlgoritmo \end{lstlisting}
						
					\subsubsection{Asignación con actualización}
						Las operaciones de actualización, como incrementos y decrementos, constituyen patrones esenciales en construcción de ciclos, acumuladores y contadores. Estas operaciones expresan de manera compacta la modificación recurrente de un valor, lo cual es particularmente importante para algoritmos iterativos \cite{Pressman2019Software}. Tanenbaum y Austin \cite{Tanenbaum2021Structured} resaltan que estas operaciones representan instrucciones eficientes a nivel de hardware y reflejan la estrecha relación entre los modelos lógicos y los modelos físicos de ejecución. Para principiantes, dominar estas operaciones permite comprender el comportamiento evolutivo del estado en ciclos \texttt{Mientras} y \texttt{Para}.
						
						\textbf{Ejemplo:} La instrucción \texttt{i <- i + 1} incrementa el valor del contador \texttt{i}, lo cual habilita el avance de iteraciones en algoritmos de recorrido.
						
						\textbf{Ejercicio:} Escriba un algoritmo que, dado un número natural \texttt{n}, utilice una variable contadora que se incremente desde 1 hasta \texttt{n}, imprimiendo cada valor.
						
						\begin{lstlisting}[caption={Algoritmo que imprime valores desde 1 hasta n utilizando un contador}, label={alg:contador1AN}]
	Algoritmo ContadorHastaN
	Entrada: n
	Salida: impresión de valores desde 1 hasta n
	
	1. Escribir "Ingrese un número natural n:"
	2. Leer n
	
	3. contador <- 1
	
	4. Mientras contador <= n hacer
	5.     Escribir contador
	6.     contador <- contador + 1
	7. FinMientras
	
	FinAlgoritmo \end{lstlisting}
						
					\subsubsection{Comparación por igualdad}
						La comparación por igualdad permite verificar si dos valores representan el mismo estado o condición, constituyendo la base de numerosas estructuras de control en algoritmos. Esta operación es esencial para la toma de decisiones, así como para validar entradas y detectar inconsistencias \cite{Sommerville2015Software,Pressman2019Software}. En términos de diseño algorítmico, su correcta interpretación evita errores comunes al diferenciar asignación de comparación, una confusión típica entre estudiantes principiantes.
						
						\textbf{Ejercicio.} Diseñe un algoritmo que determine si dos números ingresados por el usuario son iguales.
						
						\begin{lstlisting}[caption={Algoritmo que determina si dos números ingresados son iguales}, label={alg:numerosIguales}]
	Algoritmo DeterminarIgualdad
	Entrada: num1, num2
	Salida: mensaje
	
	1. Escribir "Ingrese el primer número:"
	2. Leer num1
	
	3. Escribir "Ingrese el segundo número:"
	4. Leer num2
	
	5. Si num1 = num2 entonces
	6.     mensaje <- "Los números son iguales"
	7. SiNo
	8.     mensaje <- "Los números son diferentes"
	9. FinSi
	
	10. Escribir mensaje
	
	FinAlgoritmo \end{lstlisting}
						
						El algoritmo que muestra el listado de código \ref{alg:numerosIguales} permite ilustrar la operación de comparación por igualdad, que es una de las operaciones lógicas más utilizadas en programación. Tras solicitar dos valores numéricos al usuario, el algoritmo compara ambos mediante el operador = y genera un mensaje que indica si representan o no el mismo valor. Es un ejercicio fundamental para comprender el funcionamiento de las estructuras condicionales.
						
						\begin{lstlisting}[caption={Algoritmo que determina si dos números son divisibles el uno para el otro}, label={alg:divisibilidad}]
	Algoritmo DivisibilidadMutua
	Entrada: num1, num2
	Salida: mensaje
	
	1. Escribir "Ingrese el primer número:"
	2. Leer num1
	
	3. Escribir "Ingrese el segundo número:"
	4. Leer num2
	
	// Determinar divisibilidad en ambos sentidos
	5. Si (num2 <> 0) AND (num1 mod num2 = 0) entonces
	6.     mensaje <- "num1 es divisible para num2."
	7. SiNo
	8.     Si (num1 <> 0) AND (num2 mod num1 = 0) entonces
	9.         mensaje <- "num2 es divisible para num1."
	10.    SiNo
	11.        mensaje <- "No existe divisibilidad entre ellos."
	12.    FinSi
	13. FinSi
	
	14. Escribir mensaje
	
	FinAlgoritmo \end{lstlisting}
						
						El algoritmo que se muestra en el listado de código \ref{alg:divisibilidad} evalúa la divisibilidad en ambos sentidos, ya que para dos números cualesquiera:
						\begin{enumerate}
							\item num1 es divisible para num2
							\item num2 es divisible para num1
							\item No existe divisibilidad entre ellos.
						\end{enumerate}
						
						La comprobación se realiza mediante el operador módulo (\texttt{mod}), donde si \texttt{a mod b = 0}, entonces \texttt{b} divide para \texttt{a} sin residuo. Además, el algoritmo incluye una verificación simple para evitar división entre cero.
						
					\subsubsection{Comparación por desigualdad}
						La comparación por desigualdad evalúa si dos valores difieren, habilitando decisiones relevantes cuando el algoritmo debe reaccionar ante cambios o discrepancias \cite{Pressman2019Software}. Esta operación es particularmente utilizada en validación de contraseñas, identificación de errores o detección de casos especiales en algoritmos matemáticos.
						
						\textbf{Ejercicio.} Construya un algoritmo que reciba un número y verifique si es distinto de cero. Uno de los conjuntos de pasos que dan solución a este problema se muestra en el listado de código \ref{alg:distintoDeCero}.
						
						\begin{lstlisting}[caption={Algoritmo que verifica si un número es distinto de cero}, label={alg:distintoDeCero}]
	Algoritmo VerificarDistintoDeCero
	Entrada: numero
	Salida: mensaje
	
	1. Escribir "Ingrese un número:"
	2. Leer numero
	
	3. Si numero <> 0 entonces
	4.     mensaje <- "El número es distinto de cero"
	5. SiNo
	6.     mensaje <- "El número es igual a cero"
	7. FinSi
	
	8. Escribir mensaje
	
	FinAlgoritmo \end{lstlisting}
						
					\subsubsection{Comparaciones relacionales}
						Las comparaciones relacionales permiten analizar magnitudes entre valores, lo cual es fundamental en algoritmos que requieren ordenamiento, selección o evaluación de límites \cite{Joyanes2007Fundamentos,Stallings2021Computer}. Estas operaciones dan soporte a decisiones complejas y habilitan mecanismos de control adaptativos, especialmente en estructuras como ciclos y búsqueda lineal.
						
						\textbf{Ejercicio.} Escriba un algoritmo que determine si un número ingresado está dentro del rango [10, 50].
						
						\begin{lstlisting}[caption={Algoritmo para determinar si un número está en el rango [10, 50]}, label={alg:rango10-50}]
	Algoritmo VerificarRango
	Entrada: numero
	Salida: mensaje
	
	1. Si numero >= 10 Y numero <= 50 entonces
	2.     mensaje <- "El número está dentro del rango [10, 50]"
	3. SiNo
	4.     mensaje <- "El número está fuera del rango [10, 50]"
	5. FinSi
	
	6. Devolver mensaje
	FinAlgoritmo \end{lstlisting}
				
					\subsubsection{Operación de entrada}
						La operación de entrada permite que el algoritmo adquiera información desde el entorno, ya sea proporcionada por un usuario o por un dispositivo externo. Silberschatz et al. \cite{Silberschatz2018Operating} destacan que la entrada constituye un punto crítico de interacción, ya que condiciona la validez de las operaciones posteriores. Desde la ingeniería del software, Pressman y Maxim \cite{Pressman2019Software} señalan la importancia de validar las entradas para prevenir inconsistencias o errores derivados de datos inesperados o mal formados.
						
						Además, Sommerville \cite{Sommerville2015Software} subraya la necesidad de diseñar mecanismos de entrada robustos y claros, especialmente en sistemas de información donde los datos constituyen el recurso principal. Para estudiantes principiantes, comprender esta operación implica reconocer que no se modifica el estado interno hasta que el valor ingresado se asigna a una variable, reforzando la separación entre adquisición y procesamiento.
						
						\textbf{Ejercicio:} Diseñe un algoritmo que solicite al usuario su nombre y edad, verificando que la edad sea mayor a cero.
						
						\begin{lstlisting}[caption={Algoritmo para solicitar nombre y edad, verificando que la edad sea mayor a cero}, label={alg:validarEdad}]
		Algoritmo SolicitarNombreEdad
		Entrada: nombre, edad
		Salida: mensaje
		
		1. Escribir "Ingrese su nombre:"
		2. Leer nombre
		
		3. Escribir "Ingrese su edad:"
		4. Leer edad
		
		5. Si edad > 0 entonces
		6.     mensaje <- "Datos válidos: " + nombre + ", " + edad + " años"
		7. SiNo
		8.     mensaje <- "Error: la edad debe ser mayor que cero"
		9. FinSi
		
		10. Devolver mensaje
		FinAlgoritmo \end{lstlisting}
						
					\subsubsection{Operación de salida}
						La operación de salida permite comunicar resultados al usuario o enviar información a otro proceso, cumpliendo la función esencial de presentar el efecto computacional de las transformaciones realizadas. Silberschatz et al. \cite{Silberschatz2018Operating} explican que las salidas deben ser comprensibles, oportunas y adecuadas al contexto, especialmente en sistemas interactivos. Pressman y Maxim \cite{Pressman2019Software} destacan que una salida mal diseñada puede inducir a errores de interpretación, incluso si el algoritmo interno es correcto.
						
						Sommerville \cite{Sommerville2015Software} recalca que la salida es un componente crítico en la experiencia del usuario, formando parte de los requisitos de usabilidad en ingeniería del software. Para estudiantes, esta operación ayuda a visualizar el efecto de cada instrucción en el algoritmo, facilitando la depuración y el análisis del flujo.
						
						\textbf{Ejercicio:} Escriba un algoritmo que reciba dos números y muestre su suma, diferencia y producto.
						
						\begin{lstlisting}[caption={Algoritmo que calcula suma, diferencia y producto de dos números}, label={alg:operacionesBasicas}]
	Algoritmo OperacionesBasicas
	Entrada: num1, num2
	Salida: suma, diferencia, producto
	
	1. Escribir "Ingrese el primer número:"
	2. Leer num1
	
	3. Escribir "Ingrese el segundo número:"
	4. Leer num2
	
	5. suma <- num1 + num2
	6. diferencia <- num1 - num2
	7. producto <- num1 * num2
	
	8. Escribir "La suma es: ", suma
	9. Escribir "La diferencia es: ", diferencia
	10. Escribir "El producto es: ", producto
	
	FinAlgoritmo \end{lstlisting}
						
					\subsubsection{Operación de suma}
						La suma es una de las operaciones aritméticas fundamentales y se utiliza ampliamente para acumulación de valores, cálculos financieros, contadores y algoritmos iterativos. Según Stallings \cite{Stallings2021Computer}, la suma constituye una instrucción muy eficiente a nivel de hardware. Desde la perspectiva de ingeniería de software, se considera un mecanismo de transformación de estado ampliamente utilizado \cite{Pressman2019Software}.
						
						La suma es útil para representar cantidades crecientes, totales acumulados y progresiones matemáticas. Sommerville \cite{Sommerville2015Software} destaca su importancia en el modelado de procesos que implican crecimiento incremental.
						
						\textbf{Ejemplo.} \texttt{total <- total + precio}
						
						\textbf{Ejercicio.} Diseñe un algoritmo que sume los primeros \texttt{n} números naturales.
						
						\begin{lstlisting}[caption={Algoritmo para sumar los primeros n números naturales}, label={alg:sumaNNaturales}]
	Algoritmo SumarPrimerosN
	Entrada: n
	Salida: suma
	
	1. Escribir "Ingrese un número natural n:"
	2. Leer n
	
	3. suma <- 0
	4. contador <- 1
	
	5. Mientras contador <= n hacer
	6.     suma <- suma + contador
	7.     contador <- contador + 1
	8. FinMientras
	
	9. Escribir "La suma de los primeros ", n, " números naturales es: ", suma
	
	FinAlgoritmo \end{lstlisting}
						
						La suma de los primeros $n$ números naturales puede realizarse de forma iterativa, tal como se presenta en el algoritmo anterior; sin embargo, este enfoque tiene un costo temporal proporcional a $n$, lo que implica ejecutar un ciclo completo para producir el resultado. Una optimización clásica consiste en emplear la fórmula cerrada $S = \frac{n(n+1)}{2}$, atribuida históricamente a Gauss, la cual permite calcular la sumatoria en tiempo constante $O(1)$ sin utilizar estructuras repetitivas. Tal como señalan Pressman y Maxim \cite{Pressman2019Software}, el uso de expresiones matemáticas directas reduce la complejidad algorítmica y mejora la eficiencia computacional, especialmente cuando el valor de $n$ es grande. De forma complementaria, Sommerville \cite{Sommerville2015Software} destaca que la sustitución de bucles por expresiones determinísticas contribuye a la simplicidad y mantenibilidad del código, beneficiando tanto la verificación como las pruebas del algoritmo. Esta optimización representa un ejemplo claro de cómo el análisis matemático y la ingeniería de software convergen para producir soluciones más eficientes y elegantes.
						
					\subsubsection{Operación de resta}
						La resta permite modelar decrementos, diferencias y reducciones de cantidades, siendo esencial en algoritmos que gestionan inventarios, distancias o diferencias temporales. Silberschatz et al. \cite{Silberschatz2018Operating} explican que esta operación se utiliza frecuentemente para controlar condiciones de agotamiento o para evaluar progresos inversos.
						
						Desde la perspectiva educativa, la resta ayuda a comprender el flujo descendente de un algoritmo, preparando al estudiante para ciclos decrecientes y estructuras de control más complejas.
						
						\textbf{Ejemplo.} \texttt{stock <- stock - 1}
						
						\textbf{Ejercicio.} Construya un algoritmo que reste 1 unidad a un inventario hasta llegar a cero.
						
						\begin{lstlisting}[caption={Algoritmo para decrementar el inventario de un producto hasta llegar a cero}, label={alg:inventarioDecremento}]
	Algoritmo DecrementarInventario
	Entrada: producto, inventario
	Salida: inventario final
	
	1. Escribir "Ingrese el nombre del producto:"
	2. Leer producto
	
	3. Escribir "Ingrese la cantidad inicial de inventario:"
	4. Leer inventario
	
	5. Mientras inventario > 0 hacer
	6.     inventario <- inventario - 1
	7.     Escribir "Inventario de ", producto, ": ", inventario
	8. FinMientras
	
	9. Escribir "El inventario de ", producto, " ha llegado a cero."
	
	FinAlgoritmo \end{lstlisting}
						
					\subsubsection{Operación de multiplicación}
						La multiplicación permite modelar escalamiento, crecimiento proporcional y cálculos más complejos que requieren multiplicar constantes o variables. Stallings \cite{Stallings2021Computer} señala que esta operación, aunque más costosa que la suma, sigue siendo altamente optimizada en arquitecturas modernas.
						
						Desde un punto de vista algorítmico, la multiplicación se utiliza para cálculos de áreas, volúmenes, conversiones de unidades y cualquier transformación que dependa de un factor constante.
						
						\textbf{Ejemplo:} \texttt{area <- base * altura}
						
						\textbf{Ejercicio:} Diseñe un algoritmo que calcule el área de un rectángulo.
						
						\begin{lstlisting}[caption={Algoritmo para calcular el área de un rectángulo}, label={alg:areaRectangulo}]
	Algoritmo CalcularAreaRectangulo
	Entrada: base, altura
	Salida: area
	
	1. Escribir "Ingrese la base del rectángulo:"
	2. Leer base
	
	3. Escribir "Ingrese la altura del rectángulo:"
	4. Leer altura
	
	5. area <- base * altura
	
	6. Escribir "El área del rectángulo es: ", area
	
	FinAlgoritmo \end{lstlisting}
						
					\subsubsection{Operación de división}
						La división permite representar particiones equitativas, tasas, promedios y proporciones. Silberschatz et al. \cite{Silberschatz2018Operating} destacan que esta operación requiere validación adicional para evitar divisiones por cero, un error común entre principiantes. En ingeniería del software, su tratamiento adecuado forma parte de las buenas prácticas de gestión de errores \cite{Pressman2019Software}.
						
						La división también se emplea para distribuir recursos, calcular promedios y evaluar rendimientos o eficiencias.
						
						\textbf{Ejemplo.} \texttt{promedio <- sumaTotal / cantidad}
						
						\textbf{Ejercicio 1:} Escriba un algoritmo que calcule el promedio de tres notas.
						
						\begin{lstlisting}[caption={Algoritmo para calcular el promedio de tres notas}, label={alg:promedio3Notas}]
	Algoritmo PromedioTresNotas
	Entrada: nota1, nota2, nota3
	Salida: promedio
	
	1. Escribir "Ingrese la primera nota:"
	2. Leer nota1
	
	3. Escribir "Ingrese la segunda nota:"
	4. Leer nota2
	
	5. Escribir "Ingrese la tercera nota:"
	6. Leer nota3
	
	7. promedio <- (nota1 + nota2 + nota3) / 3
	
	8. Escribir "El promedio de las tres notas es: ", promedio
	
	FinAlgoritmo \end{lstlisting}
						
						\textbf{Ejercicio 2:} Escriba un algoritmo que calcule el promedio de n notas, n debe ser ingresado mediante una operación de entrada.
						
						\begin{lstlisting}[caption={Algoritmo para calcular el promedio de n notas}, label={alg:promedioNNotas}]
	Algoritmo PromedioNNotas
	Entrada: n, nota, suma, promedio
	Salida: promedio
	
	1. Escribir "Ingrese la cantidad de notas:"
	2. Leer n
	
	3. suma <- 0
	4. contador <- 1
	
	5. Mientras contador <= n hacer
	6.     Escribir "Ingrese la nota ", contador, ":"
	7.     Leer nota
	8.     suma <- suma + nota
	9.     contador <- contador + 1
	10. FinMientras
	
	11. promedio <- suma / n
	
	12. Escribir "El promedio de las ", n, " notas es: ", promedio
	
	FinAlgoritmo \end{lstlisting}
						
					\subsubsection{Operación de módulo}
						El módulo (\texttt{mod}) devuelve el residuo de una división (ver listado de código \ref{alg:divisibilidad}), siendo fundamental para algoritmos relacionados con divisibilidad, ciclos periódicos y reconocimiento de patrones. Sommerville \cite{Sommerville2015Software} destaca su importancia en validación de entradas, calendarios, control de repeticiones y detección de valores pares o impares.
						
						Desde el análisis algorítmico, el módulo permite construir condiciones eficientes y expresar comportamientos cíclicos, como verificar cada cierto número de iteraciones.
						
						\textbf{Ejemplo:} Si se requiere verificar que un número \texttt{n} es par, entonces: \texttt{si (n mod 2 = 0) entonces imprimir ``\texttt{par}''}
						
						\textbf{Ejercicio:} Diseñe un algoritmo que determine si un número es múltiplo de 5.
						
						Un número entero $a$ se considera múltiplo de otro número entero $b$ cuando existe un entero $k$ tal que se cumple la igualdad $a = b \cdot k$. Esta relación implica que $a$ contiene exactamente $k$ veces a $b$, sin dejar residuo alguno al efectuar la división entre ellos. Desde la teoría de números, esta propiedad es fundamental para caracterizar divisibilidad, diseñar algoritmos aritméticos y establecer patrones cíclicos en procesos computacionales \cite{Rosen2018Discrete}. En el ámbito algorítmico y educativo, identificar múltiplos permite construir condiciones lógicas eficientes basadas en la operación módulo, ampliamente utilizada en algoritmos de clasificación, verificación y recorridos periódicos \cite{Cormen2022Introduction}. La comprensión de esta noción facilita el razonamiento sobre estructuras recurrentes y operaciones matemáticas comunes en programación básica y estructuras de control.
						
						\begin{lstlisting}[caption={Algoritmo para determinar si un número es múltiplo de 5}, label={alg:multiplode5}]
	Algoritmo EsMultiploDe5
	Entrada: numero
	Salida: mensaje
	
	1. Escribir "Ingrese un número:"
	2. Leer numero
	
	3. Si numero mod 5 = 0 entonces
	4.     mensaje <- "El número es múltiplo de 5"
	5. SiNo
	6.     mensaje <- "El número no es múltiplo de 5"
	7. FinSi
	
	8. Escribir mensaje
	
	FinAlgoritmo \end{lstlisting}
						
					\subsubsection{Operación lógica AND}
						La operación lógica AND produce verdadero solo cuando todas las condiciones evaluadas son verdaderas. Esta operación permite construir decisiones compuestas que integran múltiples restricciones simultáneas, tal como destaca Sommerville \cite{Sommerville2015Software}. En sistemas de información, AND es ampliamente utilizada para validar formularios, políticas de acceso y reglas de negocio, donde deben cumplirse varias condiciones al mismo tiempo \cite{Pressman2019Software}.
						
						Desde el punto de vista educativo, AND ayuda a los principiantes a comprender cómo se combinan condiciones lógicas para tomar decisiones más precisas. Además, Tanenbaum y Austin \cite{Tanenbaum2021Structured} mencionan que esta operación tiene un correlato directo en la lógica de circuitos, reforzando su importancia fundamental.
						
						\textbf{Ejemplo.} \texttt{si edad >= 18 AND documento = true entonces permitirAcceso}
						
						\textbf{Ejercicio.} Diseñe un algoritmo que verifique si un estudiante aprueba cuando \texttt{nota >= 70 AND asistencia >= 80}. Una de sus soluciones se muestra en el listado de código \ref{aprobacionEstudiante}
						
						\begin{lstlisting}[caption={Algoritmo para verificar si un estudiante aprueba según nota y asistencia}, label={alg:aprobacionEstudiante}]
	Algoritmo VerificarAprobacion
	Entrada: nota, asistencia
	Salida: mensaje
	
	1. Escribir "Ingrese la nota del estudiante:"
	2. Leer nota
	
	3. Escribir "Ingrese el porcentaje de asistencia:"
	4. Leer asistencia
	
	5. Si nota >= 70 AND asistencia >= 80 entonces
	6.     mensaje <- "El estudiante aprueba"
	7. SiNo
	8.     mensaje <- "El estudiante no aprueba"
	9. FinSi
	
	10. Escribir mensaje
	
	FinAlgoritmo \end{lstlisting}
						
					\subsubsection{Operación lógica OR}
						La operación lógica OR devuelve verdadero cuando al menos una de las condiciones se cumple. Es esencial cuando el algoritmo debe habilitar caminos alternativos o comportamientos flexibles \cite{Sommerville2015Software}. En sistemas de información se usa para validar opciones múltiples, permisos condicionales y flujos con tolerancia a incompletitud \cite{Pressman2019Software}.
						
						Para estudiantes, OR ofrece una comprensión más amplia de los mecanismos de decisión, mostrando cómo distintos criterios pueden habilitar una misma acción. En hardware, OR corresponde a un componente fundamental en puertas digitales, lo que explica su eficiencia y universalidad \cite{Stallings2021Computer}.
						
						\textbf{Ejemplo:} \texttt{si rol = ``admin'' OR rol = ``supervisor'' entonces accesoEspecial}
						
						\textbf{Ejercicio:} Construya un algoritmo que permita acceder a un sistema si el usuario es estudiante \textbf{OR} profesor. Una posible solución es la que se muestra en el listado de código \ref{alg:accesOr}
						
						\begin{lstlisting}[caption={Algoritmo para permitir acceso si el usuario es estudiante OR profesor}, label={alg:accesOr}]
	Algoritmo VerificarAcceso
	Entrada: rol
	Salida: mensaje
	
	1. Escribir "Ingrese el rol del usuario (estudiante/profesor):"
	2. Leer rol
	
	3. Si rol = "estudiante" OR rol = "profesor" entonces
	4.     mensaje <- "Acceso permitido"
	5. SiNo
	6.     mensaje <- "Acceso denegado"
	7. FinSi
	
	8. Escribir mensaje
	
	FinAlgoritmo \end{lstlisting}
						
					\subsubsection{Operación lógica NOT}
						La operación lógica NOT invierte el valor lógico de una condición, transformando verdadero en falso y viceversa. Silberschatz et al. \cite{Silberschatz2018Operating} señalan que esta operación es crucial para detectar excepciones, valores nulos o estados ausentes en sistemas de información. Desde la ingeniería del software, el uso adecuado de NOT permite crear condiciones de control que advierten sobre comportamientos anómalos \cite{Pressman2019Software}.
						
						Para principiantes, comprender NOT implica adquirir la capacidad de construir condiciones negativas o exclusiones explícitas, lo cual es indispensable para validar entradas y evitar estados no deseados.
						
						\textbf{Ejemplo.} \texttt{si NOT (usuarioRegistrado) entonces solicitarRegistro}
						
						\textbf{Ejercicio.} Existen aplicaciones que no pueden continuar si se dio algún error, por lo tanto verificar si existe un error previo es necesario para que la aplicación continúe con algún proceso, o simplemente continúe en funcionamiento. Diseñe un algoritmo que permita continuar solo si NO existe un error previo. Aunque en una aplicación real, no se daría el ingreso de la condición, una solución se muestra en el listado de código \ref{alg:notError}. 
						
						\begin{lstlisting}[caption={Algoritmo que permite continuar solo si NO existe un error previo}, label={alg:notError}]
	Algoritmo ContinuarSiNoError
	Entrada: errorPrevio   // valor booleano: true o false
	Salida: mensaje
	
	1. Escribir "¿Existe un error previo? (true/false):"
	2. Leer errorPrevio
	
	3. Si NOT errorPrevio entonces
	4.     mensaje <- "Puede continuar el proceso"
	5. SiNo
	6.     mensaje <- "No puede continuar: existe un error previo"
	7. FinSi
	
	8. Escribir mensaje
	
	FinAlgoritmo \end{lstlisting}
						
					\subsubsection{Lectura de memoria}
						La lectura consiste en recuperar el valor almacenado en una variable o posición de memoria. Esta operación se considera fundamental en todos los algoritmos, ya que permite acceder al estado actual del sistema para realizar transformaciones posteriores \cite{Silberschatz2018Operating}. Sommerville \cite{Sommerville2015Software} enfatiza que comprender la lectura es esencial para razonar sobre estados, dependencias y comportamiento algorítmico.
						
						Durante la ejecución de un algoritmo, las lecturas permiten obtener valores intermedios que condicionan decisiones o cálculos. Stallings \cite{Stallings2021Computer} explica que, aunque la lectura puede parecer transparente, su eficiencia depende de la jerarquía de memoria del sistema. Para estudiantes, visualizar la lectura como un paso explícito mejora su capacidad para depurar programas.
						
						La lectura también se relaciona con problemas comunes como el uso de variables no inicializadas, lo cual es una fuente frecuente de errores en programación inicial \cite{Pressman2019Software}.
						
						\textbf{Ejercicio.} Diseñe un algoritmo que muestre en pantalla el valor de varias variables previamente almacenadas.
						
						\begin{lstlisting}[caption={Algoritmo para mostrar el valor de variables previamente almacenadas}, label={alg:mostrarVariables}]
	Algoritmo MostrarVariables
	Entrada: a, b, c    // Variables ya almacenadas en memoria
	Salida: mensaje en pantalla
	
	1. Escribir "Los valores almacenados son:"
	2. Escribir "Variable a: ", a
	3. Escribir "Variable b: ", b
	4. Escribir "Variable c: ", c
	
	FinAlgoritmo \end{lstlisting}
						
						Este algoritmo ilustra la operación de \textit{lectura de memoria:} el programa accede a los valores actuales de las variables sin modificarlos y los muestra en pantalla. Es una operación fundamental en programación porque permite al estudiante visualizar el estado interno del algoritmo, reforzando el modelo mental de cómo se almacenan y recuperan datos.
												
					\subsubsection{Escritura en memoria}
						La escritura consiste en almacenar un valor en una variable, modificando el estado del algoritmo. Silberschatz et al. \cite{Silberschatz2018Operating} indican que la escritura es una operación crítica porque implica persistencia temporal del valor, lo cual condiciona la ejecución futura. Desde la ingeniería de software, Pressman y Maxim \cite{Pressman2019Software} subrayan que escribir correctamente contribuye a la claridad estructural del algoritmo.
						
						Stallings \cite{Stallings2021Computer} menciona que la escritura puede requerir más recursos computacionales que la lectura, especialmente en niveles bajos de memoria. Para estudiantes principiantes, comprender la escritura como una acción explícita ayuda a visualizar cómo se transforma el estado del programa.
						
						La escritura también está asociada a la consistencia interna del algoritmo, pues valores incorrectos pueden producir fallas lógicas o comportamientos no deseados \cite{Sommerville2015Software}.
						
						\textbf{Ejercicio.} Escriba un algoritmo que almacene en variables los datos ingresados en un formulario (nombre, edad, correo).
						
						\begin{lstlisting}[caption={Algoritmo para almacenar en variables los datos ingresados en un formulario}, label={alg:almacenarFormulario}]
	Algoritmo AlmacenarDatosFormulario
	Entrada: nombre, edad, correo
	Salida: mensaje
	
	1. Escribir "Ingrese su nombre:"
	2. Leer nombre
	
	3. Escribir "Ingrese su edad:"
	4. Leer edad
	
	5. Escribir "Ingrese su correo electrónico:"
	6. Leer correo
	
	7. Escribir "Los datos almacenados son:"
	8. Escribir "Nombre: ", nombre
	9. Escribir "Edad: ", edad
	10. Escribir "Correo: ", correo
	
	FinAlgoritmo \end{lstlisting}
						
					\subsubsection{Actualización de memoria}
						La actualización combina lectura, operación y escritura, constituyendo una secuencia completa de transformación del estado interno del algoritmo \cite{Stallings2021Computer}. Este patrón es esencial en ciclos, acumuladores, contadores y estructuras iterativas. Desde la teoría de sistemas, la actualización representa un mecanismo evolutivo del estado, permitiendo que el algoritmo progrese \cite{Sommerville2015Software}.
						
						Silberschatz et al. \cite{Silberschatz2018Operating} destacan que las actualizaciones deben diseñarse con claridad para evitar sobreescrituras involuntarias o pérdida de información. En enseñanza inicial de programación, esta operación ayuda a desarrollar un modelo mental adecuado del estado interno del programa.
						
						El manejo adecuado de actualizaciones mejora la capacidad de depuración y evita errores como la modificación incorrecta de contadores o índices.
						
						\textbf{Ejercicio.} Construya un algoritmo que incremente un contador hasta un valor dado y muestre los resultados.
						
						\begin{lstlisting}[caption={Algoritmo que incrementa un contador hasta un valor dado y muestra los resultados}, label={alg:contadorIncremental}]
	Algoritmo IncrementarContador
	Entrada: limite, contador
	Salida: valores del contador
	
	1. Escribir "Ingrese el valor límite:"
	2. Leer limite
	
	3. contador <- 1
	
	4. Mientras contador <= limite hacer
	5.     Escribir "Contador: ", contador
	6.     contador <- contador + 1
	7. FinMientras
	
	8. Escribir "El contador ha alcanzado el valor límite."
	
	FinAlgoritmo \end{lstlisting}
						
					\subsubsection{Direcciones conceptuales}
						Las direcciones conceptuales representan una abstracción de cómo los sistemas organizan y localizan datos en memoria. Stallings \cite{Stallings2021Computer} explica que, aunque los lenguajes de alto nivel abstraen estos detalles, su comprensión mejora la capacidad de interpretar modelos computacionales. Sommerville \cite{Sommerville2015Software} menciona que esta abstracción contribuye a comprender cómo los datos se relacionan entre sí.
						
						Desde la perspectiva educativa, enseñar direcciones conceptuales prepara al estudiante para temas avanzados como estructuras de datos, punteros y paso por referencia.
						
						\textbf{Ejercicio.} Modele mediante un diagrama conceptual cómo se almacenan tres variables consecutivas en memoria.
						
						\begin{figure}[H]
							\centering
							\begin{tikzpicture}[
								font=\small,
								mem/.style={
									draw,
									rounded corners,
									minimum width=3cm,
									minimum height=1cm,
									align=center
								}
								]
								
								% Título del esquema
								\node[font=\bfseries] (titulo) at (0,1.2) {Modelo conceptual de memoria};
								
								% Bloques de memoria (variables consecutivas)
								\node[mem] (varA) at (-4,0) {Variable \texttt{a}\\Valor almacenado};
								\node[mem, right=1cm of varA] (varB) {Variable \texttt{b}\\Valor almacenado};
								\node[mem, right=1cm of varB] (varC) {Variable \texttt{c}\\Valor almacenado};
								
								% Direcciones de memoria
								\node[below=0.4cm of varA] {\texttt{Dir X}};
								\node[below=0.4cm of varB] {\texttt{Dir X + 1}};
								\node[below=0.4cm of varC] {\texttt{Dir X + 2}};
								
							\end{tikzpicture}
							\caption{Representación conceptual de tres variables consecutivas en memoria.}
						\end{figure}
						
					\subsubsection{Variables vs. constantes}
						Las variables representan espacios de memoria cuyo contenido puede cambiar, mientras que las constantes almacenan valores fijos. Pressman \cite{Pressman2019Software} señala que distinguir ambas es clave para garantizar claridad semántica en los algoritmos. Silberschatz et al. \cite{Silberschatz2018Operating} indican que el uso adecuado de constantes evita errores relacionados con modificaciones no deseadas.
						
						Desde un enfoque pedagógico, esta distinción ayuda a estructurar algoritmos más robustos y coherentes.
						
						\textbf{Ejercicio.} Diseñe un algoritmo que utilice una constante para almacenar la tasa de interés y una variable para calcular montos futuros. El algoritmo que se muestra en el listado de código \ref{alg:montoFuturoConstante} representan los pasos que se deben implementar en un programa de computadora para obtener los cálculos que soluciona el requisito.
						
						\begin{lstlisting}[caption={Algoritmo que utiliza una constante de interés para calcular montos futuros}, label={alg:montoFuturoConstante}]
	Algoritmo CalcularMontoFuturo
	Constante TASA_INTERES <- 0.05   // 5% de interés anual
	Entrada: capital, montoFuturo
	Salida: montoFuturo
	
	1. Escribir "Ingrese el capital inicial:"
	2. Leer capital
	
	3. montoFuturo <- capital + (capital * TASA_INTERES)
	
	4. Escribir "La tasa de interés aplicada es: ", TASA_INTERES
	5. Escribir "El monto futuro es: ", montoFuturo
	
	FinAlgoritmo \end{lstlisting}
						
					\subsubsection{Representación conceptual del estado}
						La representación conceptual del estado consiste en visualizar las variables del algoritmo y sus valores en un instante específico. Sommerville \cite{Sommerville2015Software} destaca que esta representación es esencial para depurar y verificar la lógica del algoritmo. Spivak y Kent \cite{spivak2011} indican que un modelo claro del estado permite razonar formalmente sobre la transición entre estados.
						
						Desde una perspectiva formativa, esta representación facilita al estudiante comprender cómo las operaciones afectan el sistema.
						
						\textbf{Ejercicio:} Dibuje una tabla que represente el estado de un algoritmo antes y después de ejecutar una operación de actualización.
						
						\begin{table}[H]
							\centering
							\caption{Estado de una variable antes y después de una operación de actualización}
							\begin{tabular}{|c|c|c|c|}
								\hline
								\textbf{Variable} & \textbf{Estado Antes} & \textbf{Actualización} & \textbf{Estado Después} \\ \hline
								contador          & 1                     & contador <- contador + 1 & 2 \\ \hline
								acumulador          & 1                     & acumulador <- acumulador + contador & 3 \\ \hline
							\end{tabular}
						\end{table}
						
						La Figura~\ref{fig:memoriaBytes} muestra una representación conceptual de cómo dos variables enteras, \texttt{contador} y \texttt{acumulador}, se almacenan en memoria principal. Cada entero ocupa cuatro bytes consecutivos; en este ejemplo, \texttt{contador} reside desde la dirección hexadecimal 0x1200 hasta 0x1203, mientras que \texttt{acumulador} se ubica desde 0x1204 hasta 0x1207. La columna de la derecha ilustra de forma didáctica el bloque de cuatro bytes reservado para cada variable, representado por un rectángulo con el valor lógico almacenado en su interior. Este modelo ayuda a los estudiantes a visualizar que una variable de alto nivel no corresponde a una única posición física, sino a un conjunto de direcciones contiguas, y constituye la base para comprender cómo las operaciones de actualización actúan sobre el estado almacenado en memoria.
						
						\begin{figure}[H]
							\centering
							\renewcommand{\arraystretch}{1.4}
							\begin{tabular}{|c|c|c|}
								\hline
								\textbf{Variable} & \textbf{Dirección} & \textbf{Espacio de memoria (4 bytes)} \\ \hline
								
								\multirow{4}{*}{\texttt{contador}} 
								& 0x1200 & \multirow{4}{*}{\begin{tikzpicture}[baseline=-0.5ex]
										\draw[rounded corners, thick] (0,0) rectangle (1.5,0.7);
										\node at (0.75,0.35) {1};
								\end{tikzpicture}} \\ \cline{2-2}
								& 0x1201 & \\ \cline{2-2}
								& 0x1202 & \\ \cline{2-2}
								& 0x1203 & \\ \hline
								
								\multirow{4}{*}{\texttt{acumulador}}
								& 0x1204 & \multirow{4}{*}{\begin{tikzpicture}[baseline=-0.5ex]
										\draw[rounded corners, thick] (0,0) rectangle (1.5,0.7);
										\node at (0.75,0.35) {1};
								\end{tikzpicture}} \\ \cline{2-2}
								& 0x1205 & \\ \cline{2-2}
								& 0x1206 & \\ \cline{2-2}
								& 0x1207 & \\ \hline
								
							\end{tabular}
							\caption{Representación conceptual del espacio de memoria ocupado por dos variables enteras consecutivas.}
							\label{fig:memoriaBytes}
						\end{figure}
						
						La Figura~\ref{fig:actualizacionVariables} complementa la representación de memoria presentada anteriormente al mostrar explícitamente cómo se modifica el estado lógico de las variables durante un proceso de actualización. En este ejemplo, \texttt{contador} incrementa su valor de 1 a 2 mediante la operación \texttt{contador <- contador + 1}, mientras que \texttt{acumulador} pasa de 1 a 3 a través de la instrucción \texttt{acumulador <- acumulador + 2}. Estas transformaciones ilustran que el estado de una variable constituye un elemento dinámico dentro del algoritmo: cada actualización produce un nuevo valor que sustituye al anterior, generando una transición de estado que será utilizada en operaciones posteriores. El diagrama enfatiza visualmente cómo las variables cambian y cómo dichas modificaciones responden a instrucciones específicas dentro del flujo del algoritmo.
						
						\begin{figure}[H]
							\centering
							\begin{tikzpicture}[font=\small, node distance=0.3cm]
								
								% =====================
								%  BLOQUE ANTES
								% =====================
								\node[align=center, font=\bfseries] (beforeLabel) at (0,2.8)
								{Estado \textit{antes} de la actualización};
								
								% Contador antes
								\node[draw, rounded corners, minimum width=3cm, minimum height=1cm] (contBefore)
								at (0,1.5) {\shortstack{contador\\Valor: 1}};
								
								% Acumulador antes
								\node[draw, rounded corners, minimum width=3cm, minimum height=1cm,
								below=1.0cm of contBefore] (acumBefore)
								{\shortstack{acumulador\\Valor: 1}};
								
								% =====================
								%  BLOQUE DESPUÉS
								% =====================
								
								\node[align=center, font=\bfseries] (afterLabel) at (8.75,2.8)
								{Estado \textit{después} de la actualización};
								
								% Contador después
								\node[draw, rounded corners, minimum width=3cm, minimum height=1cm] (contAfter)
								at (8.75,1.5) {\shortstack{contador\\Valor: 2}};
								
								% Acumulador después
								\node[draw, rounded corners, minimum width=3cm, minimum height=1cm,
								below=1.0cm of contAfter] (acumAfter)
								{\shortstack{acumulador\\Valor: 3}};
								
								% =====================
								% FLECHAS
								% =====================
								
								\draw[->, thick] (contBefore.east) -- node[above]{\texttt{contador <- contador + 1}} (contAfter.west);
								\draw[->, thick] (acumBefore.east) -- node[above]{\texttt{acumulador <- acumulador + 2}} (acumAfter.west);
								
							\end{tikzpicture}
							
							\caption{Actualización explícita del estado de variables: el contador pasa de 1 a 2, mientras que el acumulador pasa de 1 a 3.}
							\label{fig:actualizacionVariables}
						\end{figure}
						
						
			\section{Estructura lógica de un algoritmo}
			\label{sec:estructuraAlgoritmo}
			% Secuencia, selección, iteración, EPS (Entrada–Proceso–Salida).
				La estructura lógica de un algoritmo constituye el fundamento esencial para comprender cómo se organiza la ejecución de un proceso computacional. Un algoritmo es, en términos formales, una secuencia finita y ordenada de instrucciones que transforman un estado inicial en un estado final mediante operaciones definidas y no ambiguas. La claridad en la organización de estas instrucciones permite que el algoritmo sea comprensible, verificable y ejecutable tanto por humanos como por máquinas \cite{Cormen2022Introduction, Joyanes2007Fundamentos}. Desde la teoría de la computación, esta estructura representa un modelo abstracto que describe el comportamiento del sistema en función de sus transiciones de estado.
				
				Diversos autores coinciden en que la lógica algorítmica se compone de tres patrones fundamentales: la secuencia, la selección y la iteración \cite{Joyanes2007Fundamentos, Rosen2018Discrete}. Estos patrones describen las formas esenciales mediante las cuales se controla el flujo de ejecución y permiten expresar la mayoría de los procesos computacionales. El uso adecuado de estas estructuras contribuye a la creación de algoritmos correctos, eficientes y fáciles de mantener, constituyendo una base indispensable para desarrollos más complejos como el diseño modular, la programación orientada a objetos y la construcción de sistemas de información.
				
				La estructuración lógica también permite definir las condiciones en las que un algoritmo interactúa con su entorno. Este intercambio se expresa mediante el modelo Entrada–Proceso–Salida (EPS), ampliamente aceptado en la literatura de ingeniería del software como un mecanismo formal para describir cómo un sistema recibe datos, los transforma y devuelve resultados \cite{Sommerville2015Software, Pressman2019Software}. Dicho modelo facilita la comprensión del flujo de información y establece un marco conceptual que sirve de guía para el análisis, diseño y posterior implementación en un lenguaje de programación.
				
				Finalmente, comprender la estructura lógica de un algoritmo fortalece la capacidad de abstracción del estudiante y desarrolla habilidades para descomponer problemas en pasos claros y manejables. Este proceso de razonamiento algorítmico resulta esencial en la formación en ingeniería, pues permite construir soluciones reproducibles, formalmente correctas y adaptables a distintos dominios \cite{Booch2007Object}. El dominio de estas estructuras no solo facilita el aprendizaje de la programación, sino que constituye un paso fundamental para el desarrollo de competencias relacionadas con la resolución sistemática de problemas.
				
				\subsection{Secuencia}
					La estructura secuencial constituye la forma más elemental de control del flujo en un algoritmo y se caracteriza por la ejecución ordenada de instrucciones, una tras otra, sin bifurcaciones ni repeticiones. Este modelo refleja el principio fundamental de que todo algoritmo debe especificar una serie de pasos inequívocos que transformen un estado de entrada en un estado de salida, siguiendo una lógica lineal y predecible. La literatura clásica en ciencias de la computación enfatiza que la secuencialidad es la base sobre la cual se construyen las estructuras más complejas, al proveer un mecanismo de ordenamiento rígido y determinista \cite{Aho2007Compilers}.
					
					Autores como Knuth destacan que la secuencia es indispensable para garantizar la trazabilidad y la corrección de un algoritmo, ya que permite que cada instrucción dependa del resultado de la anterior, construyendo así un flujo de información coherente y verificable \cite{Knuth1997Art}. La claridad en la secuencia evita ambigüedades y facilita el análisis formal del algoritmo, así como su implementación en lenguajes de programación, donde la ejecución secuencial constituye el comportamiento por defecto de la mayoría de las instrucciones.
					
					En el ámbito pedagógico, la secuencia es el primer patrón de control que los estudiantes deben dominar, pues proporciona un modelo intuitivo para comprender cómo se ejecutan los programas y cómo fluye la información a través de las variables. De acuerdo con Joyanes Aguilar, la estructura secuencial permite introducir conceptos esenciales como operaciones de asignación, entrada y salida, preparando al estudiante para estructuras de mayor complejidad \cite{Joyanes2007Fundamentos}. Su simplicidad la convierte en un recurso didáctico primordial para explicar la lógica algorítmica de forma gradual y progresiva.
					
					\textbf{Ejemplo 1:}  
					Para preparar una taza de té se siguen pasos estrictamente secuenciales: (1) hervir agua, (2) colocar la bolsa de té en la taza, (3) verter el agua caliente, y (4) esperar a que infusione. Cada paso debe completarse antes de continuar con el siguiente.
					
					\textbf{Ejemplo 2:}  
					Para calcular el área de un triángulo: (1) leer la base, (2) leer la altura, (3) multiplicar base por altura, y (4) dividir el resultado entre dos.
					
					\textbf{Ejercicio 1:} Diseñe un algoritmo secuencial para cepillarse los dientes. Este ejercicio refuerza cómo tareas cotidianas pueden modelarse mediante secuencias estrictas sin decisiones ni ciclos.
					
					\begin{lstlisting}[caption={Algoritmo secuencial para cepillarse los dientes}, label={alg:secuencia1}]
	Algoritmo CepilladoDientes
	1. Tomar el cepillo.
	2. Aplicar pasta dental al cepillo.
	3. Cepillar los dientes durante 2 minutos.
	4. Enjuagar la boca.
	5. Lavar el cepillo.
	FinAlgoritmo \end{lstlisting}
					
					La secuencia de pasos de un algoritmo se ejecuta exactamente en el orden especificado (ver listado de código \ref{alg:secuencia1}); cambiar el orden comprometería la efectividad o coherencia de la tarea.
					
					\textbf{Ejercicio 2:} Elabore un algoritmo secuencial para enviar un correo electrónico. Este ejercicio (ver listado de código \ref{alg:secuencia2}) muestra cómo un proceso cotidiano digital también sigue una estructura secuencial.
					
					\begin{lstlisting}[caption={Algoritmo secuencial para enviar un correo electrónico}]
	Algoritmo EnviarCorreo
	1. Abrir el programa de correo.
	2. Crear un nuevo mensaje.
	3. Escribir destinatario, asunto y contenido.
	4. Adjuntar archivos si es necesario.
	5. Presionar enviar.
	FinAlgoritmo \end{lstlisting}
					
					Cada paso depende del anterior; no se puede enviar un mensaje sin haberlo escrito, ni escribir sin haber creado el mensaje antes.
					
					\textbf{Ejercicio 3:} Diseñe un algoritmo secuencial que calcule el doble y el triple de un número ingresado. La solución (ver el algoritmo listado de código \ref{alg:secuencial3}) introduce operaciones matemáticas elementales siguiendo el flujo secuencial.
					
					\begin{lstlisting}[caption={Cálculo del doble y triple de un número}, label={alg:secuencial3}]
	Algoritmo DobleTriple
	1. Escribir "Ingrese un número:"
	2. Leer n
	3. doble <- 2 * n
	4. triple <- 3 * n
	5. Escribir doble, triple
	FinAlgoritmo \end{lstlisting}
					
					El valor de doble y triple depende directamente del valor leído en el paso 2.
					
					\textbf{Ejercicio 4:} Construya un algoritmo que convierta metros a centímetros y milímetros. Su solución (ver listado de código \ref{alg:conversionLongitud}) requiere de una secuencia estricta de pasos: primero se lee el valor, luego se realizan las conversiones y finalmente se muestran los resultados.
					
					\begin{lstlisting}[caption={Conversión de metros a cm y mm}, label={alg:conversionLongitud}]
	Algoritmo ConversionLongitud
	1. Leer metros
	2. centimetros <- metros * 100
	3. milimetros <- metros * 1000
	4. Escribir centimetros, milimetros
	FinAlgoritmo \end{lstlisting}
					
					\textbf{Ejercicio 5: }Diseñe un algoritmo secuencial que solicite un nombre y una edad, y los imprima en pantalla. La estructura secuencial que requiere el algoritmo solución (ver listado de código \ref{alg:datosUsuario})permite recibir primero los datos y luego mostrarlos; invertir el orden haría que el algoritmo falle conceptualmente.
					
					\begin{lstlisting}[caption={Impresión secuencial de datos}, label={alg:datosUsuario}]
	Algoritmo DatosUsuario
	1. Leer nombre
	2. Leer edad
	3. Escribir "Nombre:", nombre
	4. Escribir "Edad:", edad
	FinAlgoritmo \end{lstlisting}
					
					
				\subsection{Selección}
					La estructura de selección permite que un algoritmo tome decisiones en función de condiciones lógicas que determinan qué camino de ejecución seguir. A diferencia de la secuencia, que ejecuta instrucciones de manera lineal, la selección introduce bifurcaciones controladas, haciendo posible que el algoritmo responda de forma diferente ante distintos datos de entrada o situaciones del problema. La literatura clásica de algoritmia establece que la selección es un mecanismo fundamental en la resolución de problemas debido a su capacidad para modelar comportamientos condicionales esenciales en los procesos computacionales \cite{Cormen2022Introduction}.
					
					Existen dos formas principales de selección: la selección simple y la selección doble, complementadas por estructuras más complejas como la selección múltiple. La selección simple ejecuta un bloque de instrucciones únicamente si la condición especificada se cumple; la selección doble agrega un bloque alternativo que se ejecuta cuando la condición no se satisface. En cambio, la selección múltiple permite evaluar múltiples alternativas, ofreciendo mayor flexibilidad para modelar situaciones con más de dos resultados posibles. Este conjunto de estructuras constituye la base del control condicional en la mayoría de los lenguajes de programación modernos \cite{Sebesta2018Concepts}.
					
					Desde el punto de vista conceptual, la selección exige que las expresiones utilizadas en la condición sean precisas y evaluables, evitando ambigüedades que puedan conducir a resultados incorrectos. La teoría de los predicados, ampliamente utilizada en matemáticas y ciencias de la computación, aporta el marco formal para definir las condiciones lógicas que permiten decidir entre diferentes caminos de ejecución \cite{Rosen2018Discrete}. Los predicados permiten representar afirmaciones que pueden ser verdaderas o falsas, lo cual constituye el fundamento lógico de las estructuras condicionales.
					
					La selección también se relaciona con el diseño de algoritmos eficientes. Al utilizar condiciones adecuadas, es posible reducir la cantidad de operaciones necesarias para llegar a una solución, lo que incrementa la eficiencia temporal y espacial del algoritmo. Por ejemplo, una selección bien construida puede evitar cálculos innecesarios o podar caminos de ejecución que no contribuyen al resultado final. Knuth señala que el control condicional, cuando se emplea de manera correcta, contribuye directamente al diseño de algoritmos óptimos \cite{Knuth1997Art}.
					
					Por lo tanto, la estructura de selección posee un alto valor pedagógico porque facilita que el estudiante comprenda cómo los algoritmos “toman decisiones”. Tal como explican Joyanes Aguilar y otros autores, el uso didáctico de estructuras condicionales permite vincular problemas cotidianos con soluciones computacionales formales, favoreciendo la adquisición progresiva del pensamiento algorítmico \cite{Joyanes2007Fundamentos}. La capacidad de modelar decisiones en un algoritmo constituye uno de los pilares fundamentales de la programación imperativa.
					
					\paragraph{Ejemplo 1:}
					Un caso cotidiano de selección es determinar si una persona es mayor de edad. La decisión depende de una condición: si la edad es mayor o igual a 18 años. Esto se modela mediante la estructura \texttt{if-else} en el listado de código \ref{alg:mayoriaEdad}:
					
					\begin{lstlisting}[caption={Determinación de mayoría de edad}, label={alg:mayoriaEdad}]
	Algoritmo DeterminarMayoriaEdad
	1. Leer edad
	2. Si edad >= 18 entonces
	3.     Escribir "Es mayor de edad"
	4. SiNo
	5.     Escribir "Es menor de edad"
	6. FinSi
	FinAlgoritmo \end{lstlisting}
					
					Este algoritmo refleja cómo una única condición puede modificar el flujo del proceso para producir una salida coherente con los datos ingresados.
					
					\paragraph{Ejemplo 2:}
					Otro ejemplo común de selección es verificar si un número es par utilizando la operación módulo. Si el residuo de dividir entre 2 es cero, el número es par. El algoritmo se muestra en el listado de código \ref{alg:numeroPar}.
					
					\begin{lstlisting}[caption={Verificación de número par}, label={alg:numeroPar}]
	Algoritmo VerificarPar
	1. Leer n
	2. Si n mod 2 = 0 entonces
	3.     Escribir "El número es par"
	4. SiNo
	5.     Escribir "El número es impar"
	6. FinSi
	FinAlgoritmo \end{lstlisting}
					
					Este ejemplo muestra el uso de condiciones basadas en operaciones aritméticas, fundamentales para muchos algoritmos numéricos.
					
					\paragraph{Ejercicio 1:}
					Diseñe un algoritmo que determine si una persona puede ingresar a una función de cine según su edad mínima permitida (>= 15 años). Una de las soluciones en la que se muestra en el listado de código \ref{alg:accesoCine}.
					
					\begin{lstlisting}[caption={Algoritmo para control de acceso al cine}, label={alg:accesoCine}]
	Algoritmo ControlCine
	1. Leer edad
	2. Si edad >= 15 entonces
	3.     Escribir "Acceso permitido"
	4. SiNo
	5.     Escribir "Acceso denegado"
	6. FinSi
	FinAlgoritmo \end{lstlisting}
					
					En el algoritmo (ver listado de código \ref{alg:accesoCine}) se evalúa una sola condición y se bifurca el proceso en dos respuestas posibles. Es un caso claro de selección simple.
					
					\paragraph{Ejercicio 2:}
					Diseñe un algoritmo que determine si un alimento puede consumirse según su fecha de caducidad.
					
					\begin{lstlisting}[caption={Verificación de caducidad de alimento}, label={alg:caducidad}]
	Algoritmo VerificarCaducidad
	1. Leer fechaActual
	2. Leer fechaCaducidad
	3. Si fechaActual <= fechaCaducidad entonces
	4.     Escribir "El alimento está en buen estado"
	5. SiNo
	6.     Escribir "El alimento está caducado"
	7. FinSi
	FinAlgoritmo \end{lstlisting}
					
					El algoritmo que muestra el listado de código \ref{alg:caducidad} refleja la comparación entre dos valores temporales, un caso típico de selección compuesta.
					
					\paragraph{Ejercicio 3:}
					Diseñe un algoritmo que determine el mayor de tres números usando selección múltiple.
					
					\begin{lstlisting}[caption={Mayor de tres números}, label={alg:mayor3}]
	Algoritmo MayorDeTres
	1. Leer a, b, c
	2. Si (a >= b) Y (a >= c) entonces
	3.     Escribir a
	4. SiNo
	5.     Si (b >= a) Y (b >= c) entonces
	6.         Escribir b
	7.     SiNo
	8.         Escribir c
	9.     FinSi
	10. FinSi
	FinAlgoritmo \end{lstlisting}
					
					Se evalúan condiciones anidadas para identificar el mayor valor entre tres números (ver listado de código \ref{alg:mayor3}).
					
					\paragraph{Ejercicio 5:}
					Diseñe un algoritmo que valide un usuario y contraseña simples.
					
					\begin{lstlisting}[caption={Algoritmo de validación de usuario}, label={alg:login}]
	Algoritmo ValidarLogin
	1. Leer usuario
	2. Leer clave
	3. Si (usuario = "admin") Y (clave = "1234") entonces
	4.     Escribir "Acceso permitido"
	5. SiNo
	6.     Escribir "Acceso denegado"
	7. FinSi
	FinAlgoritmo \end{lstlisting}
					
					El algoritmo utiliza una condición compuesta para verificar dos criterios simultáneos: usuario y contraseña correctos.
					
					\paragraph{Ejercicio (venta con descuento).}
					\textbf{Enunciado:} Diseñe un algoritmo que calcule el total a pagar por la compra de un artículo. Si la cantidad adquirida es mayor a 3 unidades, se debe aplicar un descuento del 25\% sobre el subtotal.
					
					\begin{lstlisting}[caption={Algoritmo de venta con descuento por cantidad}, label={alg:descuentoVenta}]
	Algoritmo VentaConDescuento
	Entrada: precioUnitario, cantidad
	Salida: totalPagar
	
	1. Escribir "Ingrese el precio unitario del artículo:"
	2. Leer precioUnitario
	
	3. Escribir "Ingrese la cantidad solicitada:"
	4. Leer cantidad
	
	5. subtotal <- precioUnitario * cantidad
	
	6. Si cantidad > 3 entonces
	7.     descuento <- subtotal * 0.25
	8.     totalPagar <- subtotal - descuento
	9. SiNo
	10.    totalPagar <- subtotal
	11. FinSi
	
	12. Escribir "Subtotal: ", subtotal
	13. Escribir "Total a pagar: ", totalPagar
	
	FinAlgoritmo \end{lstlisting}
					
					El algoritmo del listado de código \ref{alg:descuentoVenta} inicia solicitando el precio unitario del artículo y la cantidad deseada. A partir de estos valores se calcula el \texttt{subtotal}. Luego se emplea una estructura de selección para determinar si la cantidad adquirida supera las tres unidades. Si la condición es verdadera, se aplica un descuento del 25\% y se obtiene el valor final a pagar. En caso contrario, el total corresponde simplemente al subtotal. Este tipo de decisión es común en sistemas comerciales que implementan promociones basadas en volumen de compra.
					
				\subsection{Iteración}
					La iteración constituye uno de los mecanismos esenciales de control en el diseño algorítmico, ya que permite repetir un conjunto de instrucciones mientras se cumpla una condición específica o durante un número determinado de veces. Esta estructura es fundamental para resolver problemas que requieren procesamiento repetitivo, tales como recorridos de datos, acumulaciones, cálculos secuenciales y simulaciones. Según Cormen et al. \cite{Cormen2022Introduction}, la iteración es un elemento central en la computación porque reduce la complejidad del diseño, evita la duplicación de instrucciones y proporciona soluciones escalables para problemas de cualquier tamaño.
					
					Knuth \cite{Knuth1997Art} señala que las estructuras iterativas como \texttt{while}, \texttt{for} y \texttt{repeat-until} representan patrones recurrentes en el análisis de algoritmos y desempeñan un papel crucial en la eficiencia computacional. Asimismo, el uso adecuado de estas estructuras permite controlar la complejidad temporal y espacial del algoritmo, especialmente en tareas que involucran grandes colecciones de datos. La iteración no sólo automatiza procesos repetitivos, sino que también facilita la sistematización de cálculos que serían inviables de realizar de manera manual.
					
					Desde la perspectiva pedagógica, la iteración contribuye al desarrollo del pensamiento computacional al introducir el concepto de \emph{estado} cambiante durante la ejecución del algoritmo. Wing \cite{Wing2006Computational} enfatiza que las estructuras repetitivas ayudan a los estudiantes a comprender cómo los sistemas evolucionan paso a paso mediante actualizaciones sucesivas de variables. De forma complementaria, Joyanes Aguilar \cite{Joyanes2007Fundamentos} destaca que la comprensión de contadores, acumuladores y condiciones de parada sienta las bases para la construcción de programas correctos y robustos.
					
					La iteración también es indispensable para el tratamiento de datos en estructuras como listas, arreglos, matrices o flujos de entrada. Sedgewick y Wayne \cite{Sedgewick2011Algorithms} explican que gran parte de los algoritmos clásicos, incluyendo búsquedas, ordenamientos y recorridos estructurados, se fundamentan en patrones iterativos bien definidos. Por ello, dominar la iteración permite abordar problemas más avanzados dentro de la ingeniería del software, la ciencia de datos y la inteligencia artificial.
					
					En conclusión, el correcto uso de la iteración exige considerar aspectos como la inicialización adecuada, la actualización coherente del estado y la condición de salida que garantiza la finalización del proceso. Como señalan Dasgupta, Papadimitriou y Vazirani \cite{Dasgupta2008Algorithms}, una condición incorrecta puede conducir a bucles infinitos o comportamientos no deseados. La iteración, cuando se diseña apropiadamente, no solo resuelve problemas de manera eficiente, sino que permite construir software confiable y verificable.
					
					\paragraph{Ejemplo 1:}
					Un ejemplo clásico de iteración consiste en sumar los primeros $n$ números naturales:
					
					\begin{lstlisting}[caption={Suma iterativa de los primeros n números}, label={alg:sumaN}]
	Algoritmo SumarPrimerosN
	1. Leer n
	2. suma <- 0
	3. contador <- 1
	4. Mientras contador <= n hacer
	5.     suma <- suma + contador
	6.     contador <- contador + 1
	7. FinMientras
	8. Escribir suma
	FinAlgoritmo \end{lstlisting}
					
					Este ejemplo (ver listado de código \ref{alg:sumaN}) muestra cómo un contador se inicializa, se actualiza y determina la condición de parada.
					
					\paragraph{Ejemplo 2:}
					Otra aplicación común es calcular $a^b$ utilizando multiplicación iterativa:
					
					\begin{lstlisting}[caption={Potencia mediante iteración}, label={alg:potencia}]
	Algoritmo CalcularPotencia
	1. Leer a
	2. Leer b
	3. resultado <- 1
	4. contador <- 1
	5. Mientras contador <= b hacer
	6.     resultado <- resultado * a
	7.     contador <- contador + 1
	8. FinMientras
	9. Escribir resultado
	FinAlgoritmo \end{lstlisting}
					
					Se observa en el listado de código \ref{alg:potencia} cómo el valor intermedio evoluciona en cada iteración, representando el efecto acumulado.
					
					\paragraph{Ejercicio 1:}
					Diseñe un algoritmo que simule contar los pasos que una persona da para llegar a un destino, incrementando un contador hasta alcanzar el total deseado.
					
					\begin{lstlisting}[caption={Conteo de pasos}, label={alg:pasos}]
	Algoritmo ContarPasos
	1. Leer totalPasos
	2. contador <- 1
	3. Mientras contador <= totalPasos hacer
	4.     Escribir "Paso ", contador
	5.     contador <- contador + 1
	6. FinMientras
	FinAlgoritmo \end{lstlisting}
					
					La iteración permite simular un proceso repetitivo donde cada paso depende del anterior como se muestra en los pasos del 3 al 6 del listado de código \ref{alg:pasos}.
					
					\paragraph{Ejercicio 2:}
					Diseñe un algoritmo que simule llenar un recipiente utilizando vasos de agua, incrementando el nivel hasta alcanzar la capacidad máxima.
					
					\begin{lstlisting}[caption={Llenado de un recipiente en iteración}, label={alg:recipiente}]
	Algoritmo LlenarRecipiente
	1. Leer capacidad
	2. nivel <- 0
	3. Mientras nivel < capacidad hacer
	4.     nivel <- nivel + 1
	5.     Escribir "Nivel actual: ", nivel
	6. FinMientras
	FinAlgoritmo \end{lstlisting}
					
					El algoritmo del listado de código \ref{alg:recipiente} ilustra una condición estricta de parada basada en un límite físico (capacidad del recipiente).
					
					\paragraph{Ejercicio 3:}
					Diseñe un algoritmo que cuente cuántos números entre 1 y \texttt{n} son pares. El procedimiento descrito en el Algoritmo~\ref{alg:pares} permite recorrer secuencialmente cada valor dentro del rango y verificar su paridad mediante la operación módulo.
					
					\begin{lstlisting}[caption={Conteo de números pares}, label={alg:pares}]
	Algoritmo ContarPares
	1. Leer n
	2. contador <- 1
	3. totalPares <- 0
	4. Mientras contador <= n hacer
	5.     Si contador mod 2 = 0 entonces
	6.         totalPares <- totalPares + 1
	7.     FinSi
	8.     contador <- contador + 1
	9. FinMientras
	10. Escribir totalPares
	FinAlgoritmo \end{lstlisting}
					
					\textbf{Explicación:}  
					El Algoritmo~\ref{alg:pares} utiliza un contador que recorre uno a uno los números desde 1 hasta \texttt{n}. En cada paso se evalúa si el número actual es par usando la expresión \texttt{contador mod 2 = 0}. Si la condición se cumple, se incrementa la variable \texttt{totalPares}. Este enfoque permite comprender el funcionamiento básico de la iteración, ya que el estudiante observa cómo el valor de las variables cambia en cada ciclo.
					
					Desde una perspectiva introductoria, una optimización sencilla consiste en notar que no es necesario analizar todos los números uno por uno. Dado que los números pares aparecen cada dos unidades, podría iniciarse el contador en 2 e incrementar de 2 en 2, reduciendo a la mitad el número de iteraciones. Esta optimización mantiene la claridad del algoritmo y conserva la lógica original, pero permite al estudiante apreciar que existen distintas formas de resolver un mismo problema con un uso más eficiente de operaciones repetitivas.
					
					Además de recorrer los números de manera iterativa, como se muestra en el Algoritmo~\ref{alg:pares}, y como se menciona en el párrafo anterior, es posible optimizar completamente el cálculo utilizando una expresión matemática directa. Para determinar cuántos números pares existen entre 1 y \texttt{n}, basta observar que los números pares se obtienen multiplicando 2 por cada número natural: $2, 4, 6, \ldots, 2k$. 
					
					El último número par menor o igual que \texttt{n} es $2k = n$ (si \texttt{n} es par) o $2k = n - 1$ (si \texttt{n} es impar). En ambos casos, el valor de $k$ se obtiene aplicando la división entera:
					\[
					k = \left\lfloor \frac{n}{2} \right\rfloor.
					\]
					
					Esto significa que el total de números pares entre 1 y \texttt{n} es exactamente la parte entera de $n/2$. Por ejemplo, si $n = 10$, entonces $10/2 = 5$, por lo que hay cinco números pares; si $n = 11$, entonces $11/2 = 5.5$, cuya parte entera es 5, que corresponde a los pares $2,4,6,8,10$. 
					
					Este método elimina por completo la necesidad de iterar, ya que la respuesta puede calcularse con una sola operación. Para estudiantes principiantes, este resultado muestra que, aunque la iteración es útil para comprender la lógica paso a paso, muchos problemas pueden resolverse de manera más eficiente usando propiedades matemáticas básicas.
					
					\paragraph{Ejercicio 4:}
						Diseñe un algoritmo que incremente un ahorro inicial sumando un valor fijo en cada iteración durante un número de periodos. En el listado de código del Algoritmo~\ref{alg:ahorro} se presentan los pasos necesarios para incrementar el valor de \texttt{ahorro} mediante sumas sucesivas del valor \texttt{incremento} a lo largo de los \texttt{periodos} especificados por el usuario. Este enfoque permite modelar de manera sencilla un crecimiento acumulado, donde en cada iteración el ahorro se actualiza con el incremento definido, mostrando cómo una variable evoluciona progresivamente en un ciclo controlado por una condición de parada.
						
					\begin{lstlisting}[caption={Ahorro acumulado en iteración}, label={alg:ahorro}]
	Algoritmo AhorroAcumulado
	1. Leer ahorroInicial
	2. Leer incremento
	3. Leer periodos
	4. ahorro <- ahorroInicial
	5. contador <- 1
	6. Mientras contador <= periodos hacer
	7.     ahorro <- ahorro + incremento
	8.     contador <- contador + 1
	9. FinMientras
	10. Escribir ahorro
	FinAlgoritmo \end{lstlisting}
					
					El valor del ahorro evoluciona en cada iteración, reflejando un crecimiento lineal.
					
					\paragraph{Ejercicio 5:}
					Diseñe un algoritmo que cuente desde un número n hasta 0.
					
					\begin{lstlisting}[caption={Temporizador regresivo}, label={alg:temporizador}]
	Algoritmo Temporizador
	1. Leer n
	2. Mientras n >= 0 hacer
	3.     Escribir n
	4.     n <- n - 1
	5. FinMientras
	FinAlgoritmo \end{lstlisting}
					
					La iteración decreciente es útil para simulaciones temporales o control de eventos.
					
				\subsection{Estructura Entrada–Proceso–Salida}
					La estructura Entrada–Proceso–Salida (EPS) constituye uno de los modelos conceptuales más utilizados para describir el funcionamiento de un algoritmo o sistema computacional. Este modelo establece que cualquier transformación de información puede entenderse mediante tres componentes fundamentales: los datos que ingresan al sistema (entrada), las operaciones que se aplican sobre ellos (proceso) y los resultados generados (salida). Pressman y Maxim \cite{Pressman2019Software} señalan que esta organización es esencial no solo para comprender el comportamiento de un algoritmo, sino también para estructurar correctamente los sistemas de información en etapas tempranas del análisis.
					
					Desde la perspectiva pedagógica, el modelo EPS permite a los estudiantes distinguir claramente el rol de cada parte del algoritmo, lo cual es especialmente importante cuando se introducen los conceptos de variables, instrucciones y operaciones de transformación. Tal como plantea Sommerville \cite{Sommerville2015Software}, la claridad en la separación entre datos y procesamiento contribuye a reducir errores conceptuales y facilita el proceso de diseño. La estructura EPS actúa como un puente entre el razonamiento cotidiano y el pensamiento computacional, permitiendo que el estudiante identifique qué información es necesaria y cómo esta debe manipularse para resolver un problema.
					
					Además, el modelo EPS es ampliamente utilizado en metodologías de diseño algorítmico porque permite representar problemas complejos como composiciones de tareas más simples. Cormen et al. \cite{Cormen2022Introduction} explican que en la mayoría de los algoritmos, independientemente de su complejidad, puede reconocerse esta estructura básica, ya que todo procedimiento computacional implica recibir información, procesarla mediante reglas definidas y generar un resultado. Esta universalidad convierte al modelo EPS en una herramienta de análisis compatible con algoritmos secuenciales, iterativos, recursivos y modulares.
					
					En resumen, la estructura EPS facilita la documentación y validación del diseño algorítmico, pues permite representar de forma gráfica o textual cómo fluye la información a través del sistema. Como indican Dennis, Wixom y Tegarden \cite{Dennis2022Systems}, los modelos de entrada, proceso y salida se utilizan ampliamente en ingeniería de software y análisis de requerimientos para identificar funciones, establecer límites del sistema y garantizar consistencia en el flujo de datos. De esta manera, el modelo EPS no solo constituye una guía conceptual, sino que también es una herramienta práctica para el desarrollo disciplinado de soluciones computacionales.
					
					\begin{figure}[htbp]
						\centering
						\begin{tikzpicture}[
							font=\small,
							box/.style={
								draw,
								rounded corners,
								minimum width=3.2cm,
								minimum height=1.2cm,
								align=center
							},
							>=Latex
							]
							
							% Nodos colocados por coordenadas absolutas
							\node[box, fill=blue!10]   (entrada) at (0,0)   {\shortstack{Entrada\\(Datos iniciales)}};
							\node[box, fill=green!10]  (proceso) at (5,0)   {\shortstack{Proceso\\(Transformación)}};
							\node[box, fill=orange!10] (salida)  at (10,0)  {\shortstack{Salida\\(Resultado)}};
							
							% Flechas simples
							\draw[->, thick] (entrada) -- (proceso);
							\draw[->, thick] (proceso) -- (salida);
							
						\end{tikzpicture}
						\caption{Modelo conceptual Entrada–Proceso–Salida utilizado en el diseño de algoritmos.}
						\label{fig:eps}
					\end{figure}
					
					
			\section{Representación en lenguaje natural estructurado}
			% Pasos numerados, claridad, eliminación de ambigüedades.
				La representación en lenguaje natural estructurado constituye un punto intermedio entre la descripción informal de un problema y su especificación algorítmica formal. A diferencia del lenguaje natural convencional, este enfoque restringe las expresiones utilizadas, organiza la información en pasos claramente delimitados y prioriza la ausencia de ambigüedades. Su objetivo es facilitar el razonamiento secuencial, manteniendo la expresividad adecuada para que el algoritmo pueda ser comprendido por personas sin conocimientos avanzados de programación, lo cual es coherente con el propósito formativo de esta etapa del libro.
				
				En concordancia con la estructura Entrada–Proceso–Salida (EPS) previamente desarrollada, el lenguaje natural estructurado permite describir la transformación de datos de forma ordenada y verificable antes de traducirla a pseudocódigo. Esta aproximación ha sido utilizada históricamente en metodologías de diseño algorítmico, pues permite identificar errores conceptuales, inconsistencias y omisiones antes de avanzar hacia representaciones más formales. Tal como ocurre en el análisis de algoritmos descrito por Cormen et al. [19], la claridad en las descripciones previas constituye un requisito para cualquier especificación computacional rigurosa.
				
				En el ejemplo que se muestra en el listado de código \ref{alg:imcLengNat}, que funciona como referencia central para las subsecciones posteriores, presenta un algoritmo expresado íntegramente en lenguaje natural estructurado. Su extensión permite ilustrar decisiones secuenciales, condiciones y validaciones básicas, las mismas que se examinarán en cada apartado.
				
				\begin{lstlisting}[language={},caption={Algoritmo en lenguaje natural estructurado para calcular el índice de masa corporal (IMC)},label={alg:imcLengNat}]
	Algoritmo CalcularIMC
	
	Entrada:
	- peso (kilogramos)
	- estatura (metros)
	
	Proceso:
	1. Verificar que peso sea mayor que 0.
	2. Verificar que estatura sea mayor que 0.
	3. Calcular imc como peso entre estatura al cuadrado: imc <- peso / (estatura^2)
	4. Si imc < 18.5, entonces categoría <- "Bajo peso".
	5. Si imc está entre 18.5 y 24.9, entonces categoría <- "Normal".
	6. Si imc está entre 25 y 29.9, entonces categoría <- "Sobrepeso".
	7. Si imc >= 30, entonces categoría <- "Obesidad".
	
	Salida:
	- Mostrar imc.
	- Mostrar categoría.
	
	FinAlgoritmo \end{lstlisting}
	
				\subsection{Pasos numerados}
					El empleo de pasos numerados, como se muestra en el algoritmo del listado \ref{alg:imcLengNat}, permite organizar el razonamiento del estudiante mediante una secuencia explícita y ordenada de acciones. La numeración evita interpretaciones múltiples acerca del orden de ejecución y facilita la correlación posterior con las estructuras secuenciales del pseudocódigo. Además, constituye una práctica alineada con la descripción operacional de algoritmos presentada en secciones anteriores, donde cada acción representa una transición clara del estado del sistema.
					
					Otra ventaja de la numeración consiste en su capacidad para descomponer problemas complejos en unidades más simples y verificables. En el ejemplo del IMC, cada validación y cada cálculo aparecen como pasos independientes, permitiendo identificar fácilmente qué ocurre si un dato de entrada es incorrecto o si una condición no se cumple. La literatura sobre diseño algorítmico destaca esta modularidad como un elemento clave para el análisis y depuración temprana de procedimientos \cite{Pressman2019Software}, [53].
					
					Finalmente, la numeración establece una relación directa con las estructuras de control estudiadas previamente, en particular la secuencia. Cada número indica un avance lineal en el flujo de ejecución, lo que permite a los estudiantes establecer paralelos entre el lenguaje natural estructurado y los bloques de código que implementarán más adelante. Esta transición gradual reduce la dificultad cognitiva y fortalece la comprensión del proceso algorítmico.
					
				\subsection{Precisión y claridad}
					La claridad en la redacción es un componente esencial del lenguaje natural estructurado. Tal como se observa en el listado \ref{alg:imcLengNat}, cada paso debe contener únicamente la información necesaria, evitando descripciones redundantes o informales. Una instrucción precisa permite que distintos lectores interpreten la misma acción de manera idéntica, reduciendo la ambigüedad y aumentando la reproducibilidad del algoritmo, principio central en la ingeniería del software según Pressman y Maxim \cite{Pressman2019Software}.
					
					La precisión también implica nombrar explícitamente las variables, operaciones y comparaciones involucradas. Por ejemplo, en el cálculo del IMC se indican claramente las restricciones de entrada y los rangos asociados a cada categoría. Estas expresiones eliminan posibles confusiones respecto a cómo se realiza la operación o qué intervalos determinan la clasificación. Como se enfatiza en Sommerville [53], esta especificación rigurosa es indispensable para garantizar la coherencia entre el diseño conceptual y la futura implementación.
					
					Otro aspecto relevante es el uso consistente de conectores y palabras clave. Expresiones como “si”, “entonces”, “verificar” o “calcular” deben emplearse siempre con el mismo significado y en contextos controlados. La estandarización terminológica permite que los estudiantes desarrollen un vocabulario compartido, facilitando el trabajo colaborativo y la revisión entre pares. Además, esta práctica es coherente con los estándares utilizados en notaciones semiformales de requisitos.
					
					Finalmente, la claridad del algoritmo también depende de la estructura visual. Separar entradas, procesos y salidas; emplear listas; y organizar las condiciones de manera explícita, como se aprecia en el ejemplo del IMC, mejora la legibilidad y hace posible identificar errores lógicos antes de convertir el algoritmo en pseudocódigo o en un lenguaje de programación.
					
				\subsection{Evitar ambigüedades}
					Uno de los propósitos fundamentales del lenguaje natural estructurado es eliminar la ambigüedad inherente al lenguaje cotidiano. Expresiones informales como “aproximadamente”, “más o menos”, “grande”, “pequeño” o “rápido” deben evitarse por completo, pues no tienen un significado operativo dentro del diseño algorítmico. El ejemplo del listado \ref{alg:imcLengNat} ilustra esta precisión al utilizar comparaciones numéricas claramente definidas para cada rango de clasificación.
					
					Asimismo, las decisiones condicionales deben diferenciarse explícitamente. Frases como “si es necesario” o “en caso contrario” solo deben utilizarse cuando el contexto está plenamente determinado. La falta de precisión puede conducir a implementaciones inconsistentes o incompatibles con el objetivo del algoritmo. La claridad en los límites del problema es un requisito destacado por Cormen et al. \cite{Cormen2022Introduction}, quienes enfatizan la necesidad de definir comportamientos específicos en cada situación posible.
					
			\section{Pseudocódigo}
			% Convenciones, instrucciones básicas, independencia del lenguaje.
				El pseudocódigo constituye una representación formalizada del algoritmo que, sin pertenecer a un lenguaje de programación real, adopta convenciones precisas que permiten describir con exactitud la lógica del procedimiento. A diferencia del lenguaje natural estructurado, el pseudocódigo utiliza palabras reservadas, bloques anidados y notaciones estandarizadas que favorecen la posterior traducción a un lenguaje de programación. Su función es, por tanto, actuar como puente entre el diseño conceptual y la implementación concreta.
				
				La figura \ref{fig:pseudobasico} muestra la estructura general de un algoritmo en pseudocódigo, destacando los bloques fundamentales: encabezado, entrada, proceso y salida. Esta estructura es coherente con el modelo EPS desarrollado previamente y se vincula directamente con la construcción de programas reales.
				
				\begin{figure}[h]
					\centering
					\begin{tikzpicture}[node distance=.8cm,rounded corners=3pt]
						\node[draw,fill=blue!10,text width=6cm,align=center] (a) {Encabezado del algoritmo};
						\node[draw,fill=green!10,text width=6cm,align=center,below=of a] (b) {Entrada: variables requeridas};
						\node[draw,fill=yellow!15,text width=6cm,align=center,below=of b] (c) {Proceso: pasos del algoritmo};
						\node[draw,fill=orange!15,text width=6cm,align=center,below=of c] (d) {Salida: resultados generados};
						\draw[->] (a) -- (b);
						\draw[->] (b) -- (c);
						\draw[->] (c) -- (d);
					\end{tikzpicture}
					\caption{Estructura básica de un algoritmo expresado en pseudocódigo.}
					\label{fig:pseudobasico}
				\end{figure}
				
				\subsection{Convenciones de escritura}
					El pseudocódigo utiliza un conjunto de convenciones que permiten representar algoritmos de forma independiente del lenguaje. Entre estas se encuentran las palabras reservadas (p.~ej., \texttt{Algoritmo}, \texttt{FinAlgoritmo}, \texttt{Si}, \texttt{Entonces}, \texttt{Mientras}), la indentación para marcar bloques y el uso explícito de operaciones básicas. El objetivo es garantizar que cualquier lector pueda comprender el algoritmo sin conocer un lenguaje específico.
					
					Por ejemplo, la instrucción que se muestra en el listado de código \ref{alg:segmentoLengNat}, representa de manera clara la estructura condicional, independientemente del lenguaje de implementación.
					
					\begin{lstlisting}[language={},caption={Algoritmo en lenguaje natural estructurado para calcular el índice de masa corporal (IMC)},label={alg:segmentoLengNat}]
	Si x > 0 Entonces
		escribir "Número positivo"
	FinSi \end{lstlisting}
					
					\subsubsection{Palabras reservadas}
						Las palabras reservadas constituyen el vocabulario fundamental del pseudocódigo, ya que cada una representa una operación o estructura de control específica. Su uso permite establecer una correspondencia directa con los lenguajes reales. Entre las más utilizadas se encuentran:
						
						Algoritmo / FinAlgoritmo — delimitan el inicio y fin del procedimiento.
						
						Si / Entonces / SiNo / FinSi — expresan decisiones.
						
						Mientras (hacer) / FinMientras — definen ciclos condicionales.
						
						Para / FinPara — definen ciclos contados.
						
						Escribir, Leer — representan operaciones de entrada/salida.
						
						<- — operador de asignación.
						
						Estas palabras se emplean cuando el algoritmo requiere expresar control del flujo, iteraciones o decisiones lógicas, y su propósito es eliminar variaciones posibles del lenguaje natural. Al mantener este conjunto reducido, el pseudocódigo preserva claridad y evita interpretaciones ambiguas, alineándose con las recomendaciones formales de representación descritas en la sección \ref{sec:estructuraAlgoritmo}.
						
					\subsubsection{Indentación}
						La indentación es una convención visual esencial para identificar bloques lógicos, anidamientos y alcances dentro del algoritmo. Su propósito es facilitar la lectura y permitir que el lector distinga rápidamente qué instrucciones pertenecen a qué estructura de control. Se utiliza siempre que se inicia una estructura como \texttt{Si}, \texttt{Mientras}, \texttt{Para}, entre otras.
						
						Desde la perspectiva pedagógica, la indentación ayuda al estudiante a internalizar los niveles jerárquicos dentro de un algoritmo, lo cual será fundamental cuando trabaje con lenguajes reales donde la organización del código influye en la mantenibilidad y comprensión general del programa.
						
				\subsection{Construcción de sentencias}
					Las sentencias en pseudocódigo permiten expresar operaciones básicas tales como asignación, entrada/salida, decisiones y ciclos. Su finalidad es representar el comportamiento del algoritmo de manera explícita, manteniendo correspondencia con los lenguajes reales de programación. A continuación se presentan ejemplos de cada tipo, vinculados lógicamente con el algoritmo del listado de código \ref{alg:imcLengNat}.
					
					\subsubsection{Asignación}
						La asignación permite establecer o actualizar el valor de una variable. En pseudocódigo se escribe mediante el operador \texttt{<-}. Existen asignaciones simples, matemáticas como la asignación del paso 3, y dependientes de condiciones previas como las que se muestran en los pasos 4, 5, 6 y 7 del listado de código \ref{alg:imcLengNat}. Según el mencionado algoritmo, en el segmento de código \ref{alg:segmento2LengNat} se muestran las dos asignaciones, sin y con restricción:
						
						\begin{lstlisting} [language={},caption={Algoritmo en lenguaje natural estructurado para calcular el índice de masa corporal (IMC)},label={alg:segmento2LengNat}]
	3. imc <- peso / (estatura^2)
	.....
	5. categoria <- "Normal" \end{lstlisting}
						
						En algoritmos más complejos, la asignación puede expresar actualizaciones dentro de ciclos o acumulaciones progresivas. A continuación se presentan dos ejercicios matemáticos.
						
						\textbf{Ejercicio 1:} El objetivo de este ejercicio es calcular la suma de los primeros diez números enteros positivos utilizando un acumulador. Esta actividad permite comprender cómo una variable puede modificarse progresivamente dentro de un ciclo y muestra el rol fundamental de la asignación en procesos iterativos. El estudiante debe identificar cómo el valor inicial del acumulador evoluciona en función del índice del ciclo, reforzando la noción de actualización de estado.
						
						La solución implementa un ciclo contado que recorre los valores del 1 al 10 y acumula cada uno de ellos en la variable \texttt{total}. El algoritmo \ref{alg:SumaAcumulada} ejemplifica adecuadamente el uso combinado de asignación inicial, actualización progresiva y salida final, permitiendo visualizar cómo la estructura de control dirige la transformación paso a paso del valor acumulado.
						
						\begin{lstlisting}[caption={Cálculo de una suma acumulada},label={alg:SumaAcumulada}]
	Algoritmo SumaAcumulada
	1. total <- 0
	2. Para i desde 1 hasta 10 hacer
	total <- total + i
	FinPara
	3. Escribir total
	FinAlgoritmo \end{lstlisting}
						
						\textbf{Ejercicio 2:} En este ejercicio se requiere evaluar una expresión polinómica para un valor específico de \texttt{x}. El propósito es mostrar cómo las asignaciones pueden utilizar operaciones aritméticas más complejas, incorporando exponentes, productos y sumas. Este tipo de cálculo es común en problemas físicos, económicos y matemáticos donde se necesita evaluar funciones de forma programática.
						
						El algoritmo \ref{alg:OperacionesMatematicas} presenta una asignación inicial para la variable \texttt{x} y posteriormente calcula el valor del polinomio mediante una expresión matemática directa. La solución refuerza el uso de la asignación como mecanismo para almacenar tanto valores iniciales como resultados intermedios y finales.
						
						\begin{lstlisting}[caption={Asignación con potencias y productos},label={alg:OperacionesMatematicas}]
	Algoritmo OperacionesMatematicas
	1. x <- 3
	2. y <- 2*x^2 + 5*x - 8
	3. Escribir y
	FinAlgoritmo \end{lstlisting}
						
					\subsubsection{Entrada/Salida}
						Las sentencias de entrada y salida permiten la comunicación entre el usuario y el algoritmo. Se expresan mediante \texttt{Leer} y \texttt{Escribir}. Su diseño en pseudocódigo debe ser explícito, indicando qué datos se solicitan y qué valores se presentan.
						
						El propósito de este ejercicio es solicitar al usuario un número entero y posteriormente mostrarlo por pantalla (ver listado de código \ref{alg:LecturaEscritura}). Esta actividad constituye el caso más elemental del flujo de entrada y salida, y permite comprender cómo un algoritmo interactúa con el usuario final. También puede introducir la necesidad de validar que el dato ingresado sea adecuado para su posterior procesamiento.
						
						\begin{lstlisting}[caption={Instrucciónes de: lectura t escritura},label={alg:LecturaEscritura}]
						Leer peso
						Escribir "El IMC es:", imc \end{lstlisting}
						
					\subsubsection{Condicionales}
						Las estructuras condicionales permiten que un algoritmo seleccione un camino de ejecución dependiendo del resultado de una evaluación lógica. Su función es controlar el flujo del programa ante situaciones donde el comportamiento no puede ser lineal, lo cual es esencial para modelar decisiones. La literatura coincide en que la selección es uno de los tres pilares fundamentales de la computación algorítmica \cite{Cormen2022Introduction,Kelly2015Programming}.
						
						El ejemplo principal presentado en el listado \ref{lst:imcLengNat} evidencia cómo un conjunto de decisiones encadenadas permite clasificar un valor numérico dentro de rangos bien definidos. Este tipo de estructura se fundamenta en dividir el dominio de entrada en subconjuntos lógicos, asignando un comportamiento explícito a cada uno. Esta técnica es ampliamente utilizada en sistemas de decisión expertos y en validación de datos en aplicaciones reales \cite{Pressman2019Software,Sommerville2015Software}.
						
						Las condicionales pueden ser simples, dobles o anidadas. Una condicional simple ejecuta una acción únicamente si se cumple la condición. En la condicional doble se introduce una ruta alternativa para cuando esta no se cumple, y en las condicionales anidadas se permite evaluar condiciones adicionales dentro de otras evaluaciones. Esta clasificación ha sido utilizada ampliamente en la enseñanza inicial de programación por su progresión cognitiva clara \cite{Ghezzi2003Fundamentals,Joyanes2007Fundamentos}.
						
						La claridad en la definición de cada condición es imprescindible para reducir ambigüedades. Las buenas prácticas recomiendan evitar expresiones vagas, rangos indefinidos o comparaciones incompletas, pues dificultan la futura implementación. Estudios en ingeniería del software señalan que gran parte de los errores en el código fuente provienen de especificaciones ambiguas o mal definidas en fases tempranas \cite{Fitzpatrick2004Software,Li2025SpecLLM}.
						
						Finalmente, las estructuras condicionales constituyen un puente conceptual que facilita al estudiante la transición hacia lenguajes como Python, Java o C, los cuales emplean operadores y sintaxis específicas pero basadas en los mismos principios. Este vínculo conceptual es clave en el desarrollo de habilidades de pensamiento computacional \cite{Wing2006Computational,Perkovic2010Framework,Duckworth2025Computational}
						
						\textbf{Ejercicio 1:} Se desea diseñar un algoritmo que determine si un número ingresado por el usuario es positivo, negativo o cero. Este tipo de clasificación numérica permite introducir el uso de condicionales anidadas, las cuales son necesarias cuando un problema requiere múltiples comparaciones secuenciales dentro de un mismo proceso de decisión.
						
						El algoritmo mostrado en el listado \ref{alg:ClasificarNumero} aplica una estructura condicional doble con una anidación interna para evaluar los tres casos posibles. Esta solución refleja fielmente cómo las rutas alternativas dependen jerárquicamente de la condición original, reforzando la idea de bifurcación controlada del flujo.
						
						\begin{lstlisting}[caption={Clasificación de un número},label={alg:ClasificarNumero}]
	Algoritmo ClasificarNumero
	1. Leer n
	2. Si n > 0 Entonces
	3. 	Escribir "Positivo"
	4. SiNo
	5. 		Si n = 0 Entonces
	6. 			Escribir "Cero"
	7. 		SiNo
	8. 			Escribir "Negativo"
	9. 		FinSi
	10. FinSi
	FinAlgoritmo \end{lstlisting}
						
						\textbf{Ejercicio 2:} Se requiere determinar si un número entero es divisible por 3. Este ejercicio permite comprender la relación entre operaciones aritméticas y decisiones lógicas, mostrando cómo el operador módulo (\texttt{mod}) facilita verificar residuales en problemas de divisibilidad, ampliamente utilizados en análisis numérico y validación de datos.
						
						\textbf{Ejercicio 2:} Se requiere determinar si un número entero es divisible por 3. Este ejercicio permite comprender la relación entre operaciones aritméticas y decisiones lógicas, mostrando cómo el operador módulo (\texttt{mod}) facilita verificar residuales en problemas de divisibilidad, ampliamente utilizados en análisis numérico y validación de datos.
						
						El algoritmo del listado \ref{alg:VerificarDivisibilidad} evalúa si el residuo de dividir el número entre 3 es igual a cero. Esta verificación determina qué mensaje se imprime, lo cual ejemplifica el uso de condicionales simples y fortalece la comprensión del vínculo entre evaluación numérica y ramificación lógica.
						
						\begin{lstlisting}[caption={Verificación de divisibilidad},label={alg:VerificarDivisibilidad}]
	Algoritmo VerificarDivisibilidad
	1. Leer n
	2. Si n mod 3 = 0 Entonces
	3. 		Escribir "Es divisible por 3"
	4. SiNo
	5. 		Escribir "No es divisible por 3"
	6. FinSi
	FinAlgoritmo \end{lstlisting}
						
					\subsubsection{Ciclos}
						Los ciclos permiten repetir un conjunto de instrucciones mientras una condición sea verdadera o durante un número determinado de iteraciones. Esta estructura resulta esencial para resolver problemas que requieren procesamiento repetitivo o acumulativo, como sumas parciales, recorridos de listas o simulaciones computacionales \cite{Cormen2022Introduction,Joyanes2007Fundamentos}.
						
						En su forma general, un ciclo puede controlarse mediante un contador (ciclo determinado) o mediante una condición lógica (ciclo indeterminado). Esta distinción responde a necesidades distintas: cuando se conoce el número de iteraciones, se emplea un ciclo contado; cuando se desconoce y depende del estado del sistema, se usa un ciclo condicionado \cite{Sommerville2015Software,Pressman2019Software}.
						
						El uso adecuado de ciclos favorece la eficiencia algorítmica al evitar repeticiones innecesarias. De hecho, una gestión incorrecta de las condiciones de parada es responsable de errores comunes como ciclos infinitos, lo cual constituye una de las fallas típicas en la programación inicial \cite{Ghezzi2003Fundamentals,Fitzpatrick2004Software}.
						
						Los ciclos también permiten estructurar cálculos iterativos que dependen de valores ingresados por el usuario. Esto facilita desarrollar algoritmos interactivos que ajustan su comportamiento dinámicamente según las entradas recibidas, un aspecto clave en aplicaciones prácticas y simulaciones computacionales \cite{Wing2006Computational,Perkovic2010Framework,Duckworth2025Computational}.
						
						Finalmente, los ciclos constituyen una herramienta expresiva indispensable para representar procesos repetitivos de la vida real, tales como sumatorias, barridos, comprobaciones sucesivas o acumulaciones. Su comprensión prepara al estudiante para estructuras avanzadas como iteradores, generadores o recorridos de colecciones en lenguajes modernos \cite{Aho2007Compilers,Kernighan1988C}.
						
						\textbf{Ejercicio 1:} El objetivo es imprimir los números del 1 al 10 utilizando un ciclo contado. Este tipo de estructura permite que el estudiante aprenda cómo el algoritmo controla el avance del índice, asegurando que el número de iteraciones sea conocido desde el inicio.
						
						\textbf{Presentación de la solución.}  
						El algoritmo \ref{alg:ImprimirNumeros} utiliza un ciclo \texttt{Para} que incrementa automáticamente la variable de control \texttt{i}. Cada iteración imprime su valor, lo que permite observar el comportamiento secuencial del ciclo contado.
						
						\begin{lstlisting}[caption={Ciclo contado para imprimir números},label={alg:ImprimirNumeros}]
	Algoritmo ImprimirNumeros
	1. Para i desde 1 hasta 10 hacer
	2. 		Escribir i
	3. FinPara
	FinAlgoritmo \end{lstlisting}
				
						\textbf{Ejercicio 2:} Se requiere construir un algoritmo que permita sumar números ingresados por el usuario hasta que la suma total alcance o supere el valor límite de 50. Este ejercicio enfatiza el uso de ciclos controlados por condición, donde la cantidad de iteraciones no es conocida de antemano.
						
						El algoritmo \ref{alg:SumaHastaLimite} emplea un ciclo \texttt{Mientras}, repitiendo la lectura y el proceso de acumulación hasta cumplir la condición. Este enfoque refleja el carácter dinámico de los ciclos condicionados.
						
						\begin{lstlisting}[caption={Ciclo condicional para sumar hasta superar un límite},label={alg:SumaHastaLimite}]
	Algoritmo SumaHastaLimite
	1. total <- 0
	2. Mientras total < 50 hacer
	3. 		Escribir "Ingrese un número:"
	4. 		Leer x
	5. 		total <- total + x
	6. FinMientras
	7. Escribir "Suma final:", total
	FinAlgoritmo \end{lstlisting}
			
			\textbf{Ejercicio 2:} Se desea diseñar un algoritmo que permita calcular el promedio de \( n \) valores ingresados por el usuario. Para ello, el programa debe solicitar primero la cantidad total de datos y luego leer cada uno de los valores dentro de un ciclo contado. Este ejercicio permite comprender el uso de acumuladores y el control del flujo mediante un ciclo \texttt{Para}, reforzando la importancia de la estructura iterativa en tareas de agregación numérica.
			
			El algoritmo presentado en el listado de código \ref{alg:PromedioNValores} utiliza un acumulador para sumar los valores ingresados y, posteriormente, divide la suma total entre la cantidad de datos registrados. El uso del ciclo \texttt{Para} garantiza que el algoritmo ejecute exactamente \( n \) iteraciones, lo cual facilita el control del proceso y evita condiciones indeterminadas.
			
			\begin{lstlisting}[caption={Cálculo del promedio de n valores},label={alg:PromedioNValores}]
	Algoritmo PromedioNValores
	1.  Escribir "Ingrese la cantidad de valores:"
	2.  Leer n
	3.  suma <- 0
	4.  Para i desde 1 hasta n hacer
	5. 		Escribir "Ingrese el valor ", i, ":"
	6. 		Leer x
	7. 		suma <- suma + x
	8.  FinPara
	0.  promedio <- suma / n
	10. Escribir "El promedio es:", promedio
	FinAlgoritmo \end{lstlisting}		
			
			\textbf{Ejercicio 3:} Se desea diseñar un algoritmo que simule un cronómetro de cuenta regresiva. El usuario ingresa un número entero \( n \) que representa los segundos iniciales. El algoritmo debe mostrar cada segundo restante y, adicionalmente, emitir mensajes especiales cuando falten exactamente 10, 5 y 1 segundo. Este problema \textbf{solo puede resolverse adecuadamente con un ciclo decremental}, ya que los eventos dependen de la cercanía al final de la cuenta y no del progreso ascendente. Usar un ciclo ascendente generaría una lógica antinatural y obligaría a cálculos inversos innecesarios.
			
			El algoritmo del listado \ref{alg:TemporizadorConEventos} utiliza un ciclo \texttt{Para} que inicia en \( n \) y decrementa hasta 0. En cada iteración se evalúan los segundos restantes y, cuando coinciden con los puntos críticos definidos, se muestra la advertencia correspondiente. Gracias al recorrido descendente, la lógica se expresa de manera directa, clara y coherente con el funcionamiento real de un temporizador.
			
			\begin{lstlisting}[caption={Cuenta regresiva con avisos en tiempos críticos},label={alg:TemporizadorConEventos}]
	Algoritmo TemporizadorConEventos
	1.  Escribir "Ingrese el número de segundos iniciales:"
	2.  Leer n
	3.  Para i desde n hasta 0 hacer paso -1
	4.  	Escribir "Tiempo restante:", i, " segundos"
	5.  	Si i = 10 Entonces
	6.  		Escribir "¡Advertencia: quedan 10 segundos!"
	7.  	FinSi
	8.  	Si i = 5 Entonces
	9.  		Escribir "¡Atención: solo 5 segundos restantes!"
	10. 	FinSi
	11. 	Si i = 1 Entonces
	12. 		Escribir "¡Último segundo!"
	13. 	FinSi
	14. FinPara
	15. Escribir "Fin de la cuenta regresiva."
	FinAlgoritmo \end{lstlisting}
			
			\section{Diagramas de flujo}
			% Símbolos, construcción y lectura de diagramas.
				Los diagramas de flujo son representaciones gráficas del comportamiento lógico de un algoritmo mediante símbolos estandarizados y conectores que permiten visualizar el flujo de control. Su finalidad es clarificar la estructura del procedimiento, facilitar la comprensión del proceso y establecer una transición natural entre el análisis del problema y la implementación formal. Diversas fuentes coinciden en que los diagramas de flujo constituyen una herramienta pedagógica fundamental para reforzar el pensamiento computacional y el razonamiento algorítmico \cite{Joyanes2007Fundamentos,Wirth1976Algorithms}.
				
				La utilidad de los diagramas de flujo reside en su capacidad para eliminar ambigüedades al representar operaciones, decisiones y secuencias de forma visual. Esta característica facilita la revisión entre pares, el análisis de errores y la validación de la lógica antes de escribir pseudocódigo o código real en un lenguaje de programación. Además, permiten identificar estructuras como ciclos y condicionales de manera inmediata, lo cual favorece la comprensión del flujo de ejecución.
				
				En consecuencia, los diagramas de flujo sirven como documentación técnica, facilitando la comunicación entre equipos de desarrollo o entre docentes y estudiantes. Su estandarización ha permitido que se mantengan como un recurso esencial en el aprendizaje inicial de algoritmos, complementando otras representaciones formales como el pseudocódigo \cite{Pressman2019Software,Sommerville2015Software}.
				
				\subsection{Símbolos básicos}
					Los símbolos básicos constituyen el vocabulario visual fundamental de los diagramas de flujo, permitiendo representar las acciones, decisiones y operaciones que conforman un algoritmo. Cada símbolo posee una semántica particular y una forma estandarizada, lo cual contribuye a que la interpretación del diagrama sea clara e inequívoca, independientemente del lector o del contexto. La estandarización de estos símbolos facilita la enseñanza inicial de la programación y reduce la ambigüedad durante el análisis de sistemas \cite{Joyanes2007Fundamentos,Wirth1976Algorithms}.
					
					El uso correcto de los símbolos garantiza que el flujo del algoritmo sea comprensible tanto para estudiantes como para profesionales, actuando como una herramienta intermedia entre el lenguaje natural estructurado y el pseudocódigo. Asimismo, los diagramas de flujo permiten identificar de forma visual estructuras como secuencias, decisiones y ciclos, lo que resulta útil al validar la lógica del procedimiento antes de su codificación \cite{Pressman2019Software,Sommerville2015Software}.
					
					Además, los símbolos básicos facilitan la construcción modular de algoritmos más complejos, debido a que cada componente puede combinarse con otros para representar procesos iterativos o ramificados. Esta modularidad gráfica favorece la depuración conceptual en etapas tempranas del diseño, previniendo errores de interpretación o inconsistencias lógicas \cite{Ghezzi2003Fundamentals}.
					
					Finalmente, la correcta disposición de los símbolos promueve la legibilidad del diagrama, permitiendo un flujo natural generalmente descendente y de izquierda a derecha. Seguir las convenciones visuales internacionales asegura que los diagramas puedan ser interpretados de manera uniforme, incluso por lectores externos al entorno académico o profesional del autor \cite{Fitzpatrick2004Software}.
					
					\subsubsection{Inicio/fin}
						El inicio y el fin de un diagrama de flujo se representan mediante un óvalo o un rectángulo con bordes redondeados. En su interior se escribe la palabra correspondiente a la función del símbolo, ya sea \textit{Inicio} o \textit{Fin}. Este elemento indica los límites del algoritmo y asegura que el flujo esté correctamente definido desde su punto de entrada hasta su terminación. Su presencia es obligatoria en cualquier diagrama y constituye la base estructural sobre la cual se desarrolla el resto del flujo \cite{Wirth1976Algorithms}.
						
						La Figura~\ref{fig:InicioFin} ilustra el símbolo estándar para inicio/fin utilizado en diagramas de flujo, siguiendo la notación más empleada en textos de ingeniería y ciencias de la computación.
						
						\begin{figure}[h]
							\centering
							\begin{tikzpicture}
								\node[draw,rounded corners=14pt,minimum width=4.5cm,minimum height=1.2cm,fill=blue!10] {Inicio / Fin};
							\end{tikzpicture}
							\caption{Símbolo estándar de inicio y fin en un diagrama de flujo.}
							\label{fig:InicioFin}
						\end{figure}
						
					\subsubsection{Proceso}
						El símbolo de proceso se representa mediante un rectángulo de bordes rectos y se utiliza para indicar una operación que el algoritmo debe ejecutar de forma determinista. Estas operaciones pueden incluir asignaciones, cálculos aritméticos, transformaciones o cualquier instrucción interna que no implique bifurcación del flujo. Su uso es esencial para expresar la secuencia lógica del procedimiento y constituye la base de la ejecución operacional del algoritmo \cite{Aho2007Compilers,Kernighan1988C}.
						
						Como ejemplo, en la Figura~\ref{fig:Proceso}, se muestra el símbolo de proceso ejecutando una operación de incremento:
						
						\begin{figure}[h]
							\centering
							\begin{tikzpicture}
								\node[draw,rectangle,minimum width=4.5cm,minimum height=1.2cm,fill=green!10] {x ← x + 1};
							\end{tikzpicture}
							\caption{Símbolo de proceso para representar una operación interna.}
							\label{fig:Proceso}
						\end{figure}
						
					\subsubsection{Decisión}
						El símbolo de decisión se representa mediante un rombo y permite expresar bifurcaciones en el flujo del algoritmo. En su interior se escribe una condición lógica cuya evaluación determinará qué camino seguirá el flujo. Este símbolo es fundamental para modelar estructuras selectivas y tomar decisiones basadas en valores de entrada o estados intermedios. Los estudios sobre pensamiento computacional destacan que la bifurcación es un concepto clave para comprender la lógica condicional \cite{Wing2006Computational,Perkovic2010Framework,Duckworth2025Computational}.
						
						\paragraph{Caso 1: Rama verdadera.}
						Cuando la condición se evalúa como verdadera, el flujo continúa por la rama etiquetada como \textit{Sí}. Esta ruta contiene las acciones que deben ejecutarse únicamente cuando la condición se cumple. La Figura~\ref{fig:DecisionVerdadera} ilustra un ejemplo simple.
						
						\begin{figure}[h]
							\centering
							\begin{tikzpicture}
								\node[draw,diamond,aspect=2,fill=yellow!20] (dec) {x > 0?};
								\draw[->] (dec.east) -- ++(1,0) node[right]{Sí};
							\end{tikzpicture}
							\caption{Rama verdadera del símbolo de decisión.}
							\label{fig:DecisionVerdadera}
						\end{figure}
						
						\paragraph{Caso 2: Rama falsa.}
						Si la condición se evalúa como falsa, el flujo continúa por la rama \textit{No}. Esto permite definir acciones alternativas que solo deben ejecutarse en ausencia del cumplimiento de la condición. La Figura~\ref{fig:DecisionFalsa} representa este comportamiento.
						
						\begin{figure}[h]
							\centering
							\begin{tikzpicture}
								\node[draw,diamond,aspect=2,fill=yellow!20] (dec) {x > 0?};
								\draw[->] (dec.west) -- ++(-1,0) node[left]{No};
							\end{tikzpicture}
							\caption{Rama falsa del símbolo de decisión.}
							\label{fig:DecisionFalsa}
						\end{figure}
						
						\paragraph{Unión de ambas ramas y continuación del flujo.}
						En muchos algoritmos, independientemente de si la condición evaluada resulta verdadera o falsa, ambas ramas deben converger posteriormente para continuar con un mismo conjunto de instrucciones. Esta convergencia representa el cierre lógico de una estructura condicional del tipo \textit{Si–SiNo} y permite retomar el flujo secuencial del algoritmo. Desde el punto de vista conceptual, esta unión garantiza que el proceso no quede fragmentado y que todas las posibles rutas de ejecución conduzcan a un estado común, lo cual es esencial para la corrección y completitud del algoritmo \cite{Perkovic2010Framework,Duckworth2025Computational}.
						
						La Figura~\ref{fig:DecisionUnion} muestra un ejemplo completo de un símbolo de decisión con sus dos ramas —verdadera y falsa— que, tras ejecutar acciones distintas, se unen nuevamente para continuar con el flujo normal del diagrama. Este patrón es uno de los más utilizados en la construcción de diagramas de flujo y tiene una correspondencia directa con las estructuras condicionales utilizadas en pseudocódigo y lenguajes de programación.
						
						\begin{figure}[h]
							\centering
							\begin{tikzpicture}[node distance=1.5cm]
								% Nodos
								\node[draw,diamond,aspect=2,fill=yellow!20] (dec) {x > 0?};
								
								\node[draw,rectangle,fill=green!10,below left=of dec] (true) {Proceso A};
								\node[draw,rectangle,fill=green!10,below right=of dec] (false) {Proceso B};
								
								\node[draw,rectangle,fill=green!10,below=2.5cm of dec] (cont) {Continuar proceso};
								
								% Flechas
								\draw[->] (dec) -- node[left]{Sí} (true);
								\draw[->] (dec) -- node[right]{No} (false);
								
								\draw[->] (true) |- (cont);
								\draw[->] (false) |- (cont);
							\end{tikzpicture}
							\caption{Decisión con ramas verdadera y falsa que convergen para continuar el flujo del algoritmo.}
							\label{fig:DecisionUnion}
						\end{figure}
						
						
					\subsubsection{Entrada/salida}
						El símbolo de entrada/salida se representa mediante un paralelogramo y se utiliza para indicar tanto la captura de datos desde el usuario como la presentación de resultados. Este símbolo permite incorporar la interacción dentro del algoritmo y es esencial en aplicaciones que requieren comunicación con el entorno. La teoría de interacción humano–computadora destaca su importancia para representar interfaces básicas en modelos algorítmicos \cite{Dix2004HCI}.
						
						\paragraph{Caso 1: Lectura de datos.}
						Cuando el símbolo representa una operación de entrada, se especifica dentro de él la acción de lectura, indicando el dato que debe ser proporcionado por el usuario. La Figura~\ref{fig:Entrada} muestra un ejemplo de lectura.
						
						\begin{figure}[h]
							\centering
							\begin{tikzpicture}
								\node[draw,trapezium,trapezium left angle=70,trapezium right angle=110,
								minimum width=4.5cm,minimum height=1.2cm,fill=orange!20] {Leer n};
							\end{tikzpicture}
							\caption{Símbolo de entrada para captura de datos.}
							\label{fig:Entrada}
						\end{figure}
						
						\paragraph{Caso 2: Escritura de datos.}
						Cuando representa una salida, el símbolo contiene el mensaje o dato que se desea mostrar al usuario. La Figura~\ref{fig:Salida} ilustra este uso.
						
						\begin{figure}[h]
							\centering
							\begin{tikzpicture}
								\node[draw,trapezium,trapezium left angle=110,trapezium right angle=70,
								minimum width=4.5cm,minimum height=1.2cm,fill=orange!20] {Mostrar resultado};
							\end{tikzpicture}
							\caption{Símbolo de salida para presentación de información.}
							\label{fig:Salida}
						\end{figure}
						
						\paragraph{Entradas especializadas según el origen de los datos.}
						En los diagramas de flujo, además de indicar la lectura de datos de forma genérica, es posible especificar el \textit{origen} desde el cual se obtienen dichos datos. Esta diferenciación resulta especialmente relevante en algoritmos que interactúan con distintos medios de entrada, como dispositivos físicos o fuentes de almacenamiento. Representar explícitamente el origen de los datos mejora la comprensión del algoritmo y facilita su posterior implementación en sistemas reales \cite{Manzano2017Programacion,Pressman2019Software}.
						
						\paragraph{Entrada manual (teclado).}
						La entrada manual representa la introducción de datos realizada directamente por una persona, generalmente mediante el uso del teclado u otro dispositivo de entrada manual. En los diagramas de flujo, este tipo de entrada se representa mediante el símbolo de \textit{entrada manual}, caracterizado por tener la forma de un polígono similar a un rectángulo, pero con el borde superior inclinado y de menor longitud que el inferior. Esta forma distingue claramente la entrada manual de otras fuentes de datos, como archivos o dispositivos automáticos. La Figura~\ref{fig:EntradaManual} muestra el símbolo estándar utilizado para representar la entrada manual en diagramas de flujo, de acuerdo con la simbología ampliamente aceptada.
						
						\begin{figure}[h]
							\centering
							\begin{tikzpicture}
								% --- Símbolo de Entrada manual (Manual Input) ---
								\draw[draw=black, fill=orange!25]
								(0,0) -- (6,0) -- (6,1.8) -- (0,1.2) -- cycle;
								
								% Texto centrado
								\node at (3,0.7) {Introducir dato};
								
							\end{tikzpicture}
							\caption{Símbolo de entrada manual (teclado) en un diagrama de flujo.}
							\label{fig:EntradaManual}
						\end{figure}
						
						% ============================================================
						% Símbolos de diagramas de flujo 
						% ============================================================
						
						\tikzset{
							dfshape/.style={draw=black, line width=0.6pt, fill=orange!12},
							dflabel/.style={font=\small}
						}
						
						\paragraph{Salida por pantalla (visualización).}
						La salida por pantalla representa una operación mediante la cual el sistema muestra información directamente al usuario a través de un dispositivo de visualización, como un monitor o una interfaz gráfica. En los diagramas de flujo, este tipo de salida no se representa con el símbolo genérico de entrada/salida, sino mediante el \textit{símbolo de visualización} (\textit{display}), el cual permite distinguir la presentación visual de información de otros tipos de salida, como la impresión de documentos o el almacenamiento en archivos. Esta diferenciación resulta fundamental para una correcta interpretación del flujo de información dentro del sistema.
						
						El símbolo de visualización se caracteriza por una forma similar a un rectángulo con uno de sus lados curvado, lo que indica que la información es mostrada al usuario de manera directa y no almacenada ni transmitida a otro medio. De acuerdo con la simbología empleada en herramientas de diagramación ampliamente aceptadas, como SmartDraw, este símbolo se utiliza específicamente para representar operaciones de salida visual, tales como mostrar resultados, mensajes o datos procesados en pantalla \cite{SmartDrawFlowchartSymbols}.
						
						Desde el punto de vista del análisis y diseño de sistemas, la separación entre salidas visuales y otros tipos de salida contribuye a una mayor claridad del modelo y facilita la transición del diagrama de flujo hacia su implementación en software. Autores clásicos en el área de sistemas de información y programación estructurada recomiendan el uso explícito del símbolo de visualización cuando la interacción con el usuario se produce a través de la pantalla, ya que esto mejora la legibilidad del diagrama y reduce ambigüedades durante el desarrollo y mantenimiento del sistema \cite{Kendall2014Systems,Manzano2017Programacion}.
						
						La Figura~\ref{fig:simbolo-visualizacion} muestra el símbolo de visualización empleado en los diagramas de flujo para representar la salida de información por pantalla, el cual será utilizado de forma consistente a lo largo de los ejemplos y ejercicios desarrollados en este capítulo.
						
						% Símbolo "Pantalla / Display" (como el de tu imagen)
						\begin{figure}[h]
							\centering
							\begin{tikzpicture}
								% Parámetros (ajusta si quieres)
								\def\W{5.2}   % ancho total
								\def\H{1.6}   % alto
								\def\L{1.1}   % “punta” izquierda (inclinación)
								\def\R{0.8}   % radio del semicírculo derecho
								\def\XR{\W-\R} % x donde inicia el semicírculo
								
								% Relleno opcional (comenta si lo quieres solo con borde)
								\fill[blue!15]
								(-\L,0) -- (0,\H/2) -- (\XR,\H/2)
								arc[start angle=90, end angle=-90, radius=\R]
								-- (0,-\H/2) -- cycle;
								
								% Borde
								\draw[blue, line width=1.2pt]
								(-\L,0) -- (0,\H/2) -- (\XR,\H/2)
								arc[start angle=90, end angle=-90, radius=\R]
								-- (0,-\H/2) -- cycle;
								
								% Texto centrado (opcional)
								%\node at (\W/2-\R/2,0) {Pantalla};
							\end{tikzpicture}
							\captionof{figure}{Símbolo de visualización utilizado para representar la salida de información por pantalla en los diagramas de flujo.}
							\label{fig:simbolo-visualizacion}
						\end{figure}
						
						\paragraph{Salida por impresora (documento impreso).}
						La salida por impresora representa una operación mediante la cual el sistema genera información en un soporte físico, generalmente en forma de documentos impresos como reportes, comprobantes, listados o formularios \cite{Joyanes2007Fundamentos,Kendall2014Systems}. A diferencia de la salida por pantalla, este tipo de salida implica la materialización permanente de la información, lo que resulta especialmente relevante en contextos administrativos, legales o contables donde se requiere evidencia tangible de los resultados procesados por el sistema \cite{Kendall2014Systems,Pressman2019Software}.
						
						En los diagramas de flujo, la salida por impresora no se representa mediante el símbolo de visualización, sino a través del \textit{símbolo de documento}, el cual permite identificar de manera explícita que la información producida será impresa o generada como un archivo con estructura de documento \cite{Joyanes2007Fundamentos,SmartDrawFlowchartSymbols}. Este símbolo facilita la distinción entre salidas transitorias (visualización) y salidas persistentes (documentos), contribuyendo a una interpretación más precisa del flujo de información dentro del sistema \cite{Manzano2017Programacion}.
						
						La Figura~\ref{fig:DFSimpleDocumento} muestra el símbolo de documento utilizado en los diagramas de flujo para representar la salida de información destinada a impresión o generación de documentos, el cual será empleado de forma consistente en los ejemplos y ejercicios desarrollados en este capítulo \cite{Joyanes2007Fundamentos,Kendall2014Systems}.
						% ------------------------------------------------------------
						% 3) Documento impreso (SmartDraw)
						% ------------------------------------------------------------
						\begin{figure}[h]
							\centering
							% Símbolo Documento / Salida por impresora
							% Borde inferior SOLO con arcos suaves (sin línea recta)
							\begin{tikzpicture}
								% Parámetros
								\def\W{6.0}     % ancho total
								\def\H{2.0}     % alto
								\def\sL{0.10}   % curvatura izquierda (saliente, hacia abajo) -> pequeña
								\def\sR{0.22}   % curvatura derecha (entrante, hacia arriba) -> mayor (derecha más alta)
								
								% Puntos clave
								\coordinate (A) at (0,0);
								\coordinate (B) at (\W/2,0);
								\coordinate (C) at (\W,0);
								
								% Borde superior y lateral derecho
								\draw[blue, line width=1.2pt]
								(0,\H) -- (\W,\H) -- (\W,0);
								
								% Borde inferior: dos arcos suaves (sin línea recta inferior)
								\draw[blue, line width=1.2pt]
								(A) .. controls (\W/4,-\sL) .. (B)
								(B) .. controls (3*\W/4,\sR) .. (C);
								
								% Lateral izquierdo
								\draw[blue, line width=1.2pt]
								(0,0) -- (0,\H);
								
								% Texto opcional
								%\node at (\W/2,\H/2) {Documento};
							\end{tikzpicture}
							\captionof{figure}{Símbolo de documento utilizado para representar la salida de información impresa o generada como documento en los diagramas de flujo.}
							\label{fig:DFSimpleDocumento}
						\end{figure}
						
						\paragraph{Salida de múltiples documentos.}
						La salida de múltiples documentos representa una operación mediante la cual el sistema genera simultáneamente más de un documento como resultado de un mismo proceso \cite{Joyanes2007Fundamentos,Kendall2014Systems}. Este tipo de salida es común en sistemas de información administrativos y organizacionales, por ejemplo, cuando se producen varios reportes, listados, comprobantes o formularios asociados a una misma transacción o evento \cite{Kendall2014Systems,Pressman2019Software}. A diferencia de la salida de un único documento, este caso implica el manejo conjunto de un conjunto de documentos que deben ser considerados como una unidad lógica dentro del flujo del sistema \cite{Manzano2017Programacion}.
						
						En los diagramas de flujo, la salida de múltiples documentos se representa mediante el \textit{símbolo de múltiples documentos}, el cual se construye a partir del símbolo de documento básico dispuesto de forma superpuesta \cite{SmartDrawFlowchartSymbols}. Esta representación gráfica permite identificar de manera inmediata que la operación produce o utiliza varios documentos, evitando ambigüedades con respecto a salidas simples y facilitando la correcta interpretación del proceso modelado \cite{Joyanes2007Fundamentos,Manzano2017Programacion}.
						
						La Figura~\ref{fig:DFMultiDocumento} muestra el símbolo de múltiples documentos utilizado en los diagramas de flujo para representar la generación o tratamiento simultáneo de varios documentos impresos o estructurados. Este símbolo será empleado de manera consistente en los ejemplos y ejercicios desarrollados en este capítulo, contribuyendo a una lectura clara y precisa de los flujos de información en los sistemas analizados \cite{Kendall2014Systems,Pressman2019Software}.
						% ------------------------------------------------------------
						% 4) Multidocumento (SmartDraw)
						% ------------------------------------------------------------
						\begin{figure}[h]
							\centering
							\begin{tikzpicture}
								% Parámetros
								\def\W{6.4}      % ancho
								\def\H{3.6}      % alto (más alto como en tu imagen)
								\def\sDown{0.35} % profundidad (hacia abajo) en el tramo izquierdo (más notoria)
								\def\sUp{0.18}   % elevación (hacia arriba) en el tramo derecho (más sutil)
								\def\d{0.35}     % desplazamiento entre documentos
								
								% --- Macro: contorno del documento (sin línea inferior recta) ---
								% Arriba y laterales rectos; base con una curva suave continua
								\newcommand{\docpath}{%
									(0,\H) -- (\W,\H) -- (\W,0)
									.. controls (\W*0.33,-\sDown) and (\W*0.75,\sUp) .. (0,0)
									-- cycle
								}
								
								% ---------------- Documento trasero ----------------
								\begin{scope}[shift={(\d*2,\d*2)}]
									\draw[blue, line width=1.2pt] \docpath;
								\end{scope}
								
								% ---------------- Documento intermedio ----------------
								\begin{scope}[shift={(\d,\d)}]
									\draw[blue, line width=1.2pt] \docpath;
								\end{scope}
								
								% ---------------- Documento frontal (máscara exacta) ----------------
								% Máscara usando EXACTAMENTE el mismo contorno del documento
								\fill[white] \docpath;
								
								% Contorno del documento frontal
								\draw[blue, line width=1.2pt] \docpath;
								
							\end{tikzpicture}\caption{Símbolo de Multidocumento.}
							\label{fig:DFMultiDocumento}
						\end{figure}
						
						\paragraph{Subproceso (proceso predefinido).}
						El subproceso, también denominado \textit{proceso predefinido}, representa una operación cuya lógica interna se encuentra especificada en otro lugar del algoritmo o del sistema, y que es invocada como una unidad reutilizable dentro del flujo principal \cite{Joyanes2007Fundamentos,Manzano2017Programacion}. En programación básica, este símbolo se utiliza para modelar funciones, procedimientos o módulos ya definidos, de modo que el diagrama de flujo se mantenga legible sin perder precisión, delegando los detalles de implementación a una descripción separada \cite{Pressman2019Software}.
						
						En los diagramas de flujo, el subproceso se distingue del símbolo de proceso estándar mediante un rectángulo con doble borde vertical (líneas paralelas a ambos lados) \cite{SmartDrawFlowchartSymbols,Joyanes2007Fundamentos}. Esta convención permite identificar visualmente que la actividad no se desarrolla paso a paso en el diagrama actual, sino que corresponde a una rutina invocada, cuya ejecución produce un resultado coherente y controlado antes de retornar al flujo principal \cite{Kendall2014Systems}. Esta diferenciación resulta especialmente útil cuando el algoritmo incorpora tareas repetitivas o de complejidad moderada que conviene encapsular para facilitar mantenimiento y comprensión \cite{Pressman2019Software}.
						
						La Figura~\ref{fig:simbolo-subproceso} muestra el símbolo de subproceso utilizado en los diagramas de flujo para representar procesos predefinidos que se ejecutan como módulos reutilizables. Este símbolo será empleado de manera consistente en los ejemplos y ejercicios desarrollados en este capítulo, particularmente en aquellos donde se estructuran algoritmos mediante funciones o procedimientos claramente delimitados \cite{Joyanes2007Fundamentos,Manzano2017Programacion}.
						
						% ------------------------------------------------------------
						% 8) Subproceso / Proceso predefinido (doble línea vertical)
						% ------------------------------------------------------------
						\begin{figure}[h]
							\centering
							\begin{tikzpicture}
								\draw[dfshape] (0,0) rectangle (5,1.6);
								\draw[draw=black, line width=0.6pt] (0.35,0) -- (0.35,1.6);
								\draw[draw=black, line width=0.6pt] (4.65,0) -- (4.65,1.6);
								\node[dflabel] at (2.5,0.8) {Subproceso};
							\end{tikzpicture}
							\captionof{figure}{Símbolo de subproceso (proceso predefinido) utilizado para representar una rutina o módulo invocado desde el flujo principal.}
							\label{fig:simbolo-subproceso}
						\end{figure}
						
						\paragraph{Almacenamiento interno.}
						El almacenamiento interno representa una operación mediante la cual el sistema guarda datos de forma temporal o permanente dentro de su propia memoria o en estructuras internas de almacenamiento, tales como variables, arreglos, registros o áreas de memoria gestionadas por el programa \cite{Joyanes2007Fundamentos,Manzano2017Programacion}. Este tipo de almacenamiento se utiliza para conservar información necesaria durante la ejecución del algoritmo, permitiendo su posterior recuperación y manipulación sin requerir interacción externa ni acceso a dispositivos físicos de entrada o salida \cite{Silberschatz2018Operating}.
						
						En los diagramas de flujo, el símbolo de almacenamiento interno se emplea para indicar explícitamente que los datos permanecen dentro del sistema y son utilizados como parte del procesamiento lógico \cite{Joyanes2007Fundamentos,SmartDrawFlowchartSymbols}. Su uso resulta fundamental para distinguir entre información que se conserva internamente durante la ejecución del programa y aquella que se envía a medios externos, como archivos o dispositivos de salida \cite{Manzano2017Programacion}. Esta diferenciación contribuye a una mejor comprensión del ciclo de vida de los datos dentro del algoritmo y facilita el análisis del flujo de información \cite{Kendall2014Systems}.
						
						Desde el punto de vista del análisis y diseño de sistemas, la identificación clara de las operaciones de almacenamiento interno permite modelar con mayor precisión el comportamiento del sistema, especialmente en algoritmos que dependen del manejo de estados, acumuladores o estructuras de datos intermedias \cite{Pressman2019Software}. En este sentido, la Figura~\ref{fig:DFAlmacenInterno} presenta el símbolo de almacenamiento interno utilizado en los diagramas de flujo para representar la retención y gestión de datos en memoria, el cual será empleado de manera consistente en los ejemplos y ejercicios desarrollados en este capítulo.
						
						% ------------------------------------------------------------
						% 9) Almacenamiento interno (doble línea: superior e izquierda)
						% ------------------------------------------------------------
						\begin{figure}[h]
							\centering
							\begin{tikzpicture}
								\draw[dfshape] (0,0) rectangle (5,1.6);
								\draw[draw=black, line width=0.6pt] (0.35,0) -- (0.35,1.6);
								\draw[draw=black, line width=0.6pt] (0,1.25) -- (5,1.25);
								\node[dflabel] at (2.5,0.65) {Almacenamiento interno};
							\end{tikzpicture}
							\caption{Símbolo de Almacenamiento interno.}
							\label{fig:DFAlmacenInterno}
						\end{figure}
						
						\paragraph{Base de datos (almacenamiento en base de datos).}
						La base de datos representa un mecanismo de almacenamiento estructurado y persistente mediante el cual el sistema conserva grandes volúmenes de información de forma organizada, coherente y accesible a lo largo del tiempo \cite{Elmasri2016Database,Silberschatz2020Database}. A diferencia del almacenamiento interno, que suele emplearse para datos temporales o de uso inmediato durante la ejecución del algoritmo, la base de datos está diseñada para garantizar la permanencia de la información, su integridad y su disponibilidad para múltiples procesos o usuarios \cite{Elmasri2016Database,Date2019Database}.
						
						En los diagramas de flujo, el símbolo de base de datos se utiliza para indicar operaciones de almacenamiento o recuperación de información desde un repositorio persistente gestionado por un sistema de gestión de bases de datos \cite{Kendall2014Systems,SmartDrawFlowchartSymbols}. Este símbolo permite diferenciar claramente las acciones que involucran memoria interna del programa de aquellas que implican acceso a datos almacenados de manera estructurada y duradera, como registros de clientes, transacciones, historiales académicos o inventarios \cite{Elmasri2016Database,Silberschatz2020Database}. Su correcta identificación resulta esencial para comprender la arquitectura lógica del sistema y el flujo de datos entre los distintos componentes \cite{Kendall2014Systems}.
						
						Desde la perspectiva del análisis y diseño de sistemas de información, el uso explícito del símbolo de base de datos contribuye a una modelación más precisa de los procesos que dependen de información persistente y compartida \cite{Kendall2014Systems,Pressman2019Software}. La Figura~\ref{fig:DFBaseDatos} presenta el símbolo de base de datos empleado en los diagramas de flujo para representar el almacenamiento y acceso a datos persistentes, el cual será utilizado de manera consistente en los ejemplos y ejercicios desarrollados en este capítulo.
						
						% ------------------------------------------------------------
						% 10) Base de datos (cilindro)
						% ------------------------------------------------------------
						\begin{figure}[h]
							\centering
							\begin{tikzpicture}
								% cilindro
								\draw[dfshape] (0,0.35) ellipse (2.2 and 0.35);
								\draw[dfshape] (-2.2,0.35) -- (-2.2,2.2) arc (180:360:2.2 and 0.35) -- (2.2,0.35) -- cycle;
								\draw[draw=black, line width=0.6pt] (0,2.2) ellipse (2.2 and 0.35);
								\node[dflabel] at (0,1.25) {Base de datos};
							\end{tikzpicture}
							\caption{Símbolo de Base de datos (almacenamiento persistente).}
							\label{fig:DFBaseDatos}
						\end{figure}
						
						\paragraph{Datos externos.}
						Los datos externos representan información que no es creada, almacenada ni gestionada directamente por el programa que se está modelando, pero que resulta necesaria para su funcionamiento o que es producida por él para ser utilizada fuera del sistema. En el contexto del análisis y diseño de sistemas, estos datos pertenecen a entidades, sistemas o fuentes externas al límite lógico del programa, aunque interactúan con él durante su ejecución \cite{Dennis2022Systems}.
						
						En los diagramas de flujo, el símbolo de datos externos se emplea para indicar operaciones en las que el programa obtiene información desde fuentes externas o envía resultados hacia otros sistemas, sin asumir la responsabilidad sobre el almacenamiento, la persistencia o la administración de dichos datos. Desde una perspectiva introductoria, los estudiantes pueden comprender los datos externos como información que el algoritmo recibe o entrega, pero sobre la cual no tiene control directo, limitándose únicamente a su uso dentro del flujo lógico del programa \cite{Kelly2015Programming}.
						
						Ejemplos comunes de datos externos incluyen información obtenida desde servicios web, aplicaciones remotas, plataformas externas o sistemas de información distintos, así como datos que el programa proporciona a otros sistemas mediante interfaces de comunicación. En estos casos, el algoritmo no describe cómo se almacenan o mantienen esos datos fuera del sistema, sino únicamente cómo se integran en el proceso de cálculo o decisión \cite{Dennis2022Systems,SmartDrawFlowchartSymbols}.
						
						La Figura~\ref{fig:DFDatosExternos} presenta el símbolo de datos externos utilizado en los diagramas de flujo. La forma con lados curvos hacia el interior sugiere gráficamente que la información atraviesa el límite del sistema, destacando que los datos no permanecen dentro del programa. El uso adecuado de este símbolo contribuye a que los estudiantes diferencien claramente entre datos internos del programa y datos que provienen de, o se dirigen hacia, otros sistemas, favoreciendo una comprensión más precisa del alcance y las responsabilidades del algoritmo \cite{SmartDrawFlowchartSymbols}.
						
						% ------------------------------------------------------------
						% 11) Datos externos (lados curvos hacia adentro)
						% ------------------------------------------------------------
						\begin{figure}[h]
							\centering
							\begin{tikzpicture}
								\path[dfshape]
								(0,0) .. controls (0.9,0.4) and (0.9,1.2) .. (0,1.6)
								-- (5,1.6)
								.. controls (4.1,1.2) and (4.1,0.4) .. (5,0)
								-- cycle;
								\node[dflabel] at (2.5,0.8) {Datos externos};
							\end{tikzpicture}
							\caption{Símbolo de Datos externos.}
							\label{fig:DFDatosExternos}
						\end{figure}
						
						\paragraph{Tira (paper tape).}
						El símbolo de \emph{tira} (también denominado \emph{paper tape}) se emplea en diagramas de flujo para representar el manejo de información en un medio \emph{secuencial}, históricamente asociado a la cinta de papel perforada utilizada como soporte de entrada/salida en los primeros sistemas de cómputo. En términos didácticos, este símbolo permite enfatizar que los datos se registran o se leen siguiendo un orden lineal, sin acceso directo a posiciones arbitrarias, a diferencia de estructuras como memoria principal o bases de datos \cite{Kelly2015Programming,Joyanes2007Fundamentos}.
						
						En un curso de fundamentos de programación, la utilidad principal de este símbolo no radica en el dispositivo histórico, sino en la idea algorítmica que introduce: existen fuentes o destinos de datos cuyo acceso es predominantemente \emph{por recorrido} (por ejemplo, una secuencia de registros, una lista de eventos, un flujo de lectura o un conjunto de resultados que se generan en orden). En consecuencia, cuando el estudiante modela un algoritmo que procesa elementos uno tras otro (lectura secuencial, acumulación progresiva, generación ordenada de salidas), la tira ayuda a reforzar la noción de \emph{procesamiento secuencial} y a distinguirla de operaciones donde se consulta o actualiza información de manera aleatoria \cite{Kelly2015Programming,SmartDrawFlowchartSymbols}.
						
						Asimismo, en diagramas de flujo contemporáneos, el símbolo de tira puede interpretarse como una convención gráfica para señalar salidas impresas o registros generados en serie, así como entradas provenientes de un flujo continuo de información, siempre que se busque remarcar el carácter secuencial del manejo de datos. Esta interpretación resulta especialmente apropiada en ejercicios introductorios donde el objetivo es comprender el flujo de control y el recorrido de datos, más que modelar detalles de infraestructura \cite{SmartDrawFlowchartSymbols,Joyanes2007Fundamentos}.
						
						La Figura~\ref{fig:DFTira} presenta el símbolo de tira utilizado en los diagramas de flujo para representar el manejo secuencial de datos, el cual será empleado de manera consistente en los ejemplos y ejercicios desarrollados en este capítulo.
						
						% ------------------------------------------------------------
						% 12) Tira (paper tape): contorno completo con ondulación superior e inferior
						% (ajustado para que coincida con la imagen renderizada)
						% ------------------------------------------------------------
						\begin{figure}[h]
							\centering
							\begin{tikzpicture}
								% Contorno del símbolo (incluye los lados y las ondulaciones)
								\draw[dfshape]
								(0,0.25)
								.. controls (1.10,0.00) and (2.40,0.50) .. (3.60,0.25)
								.. controls (4.20,0.12) and (4.60,0.25) .. (5,0.25)
								-- (5,1.55)
								.. controls (4.60,1.55) and (4.20,1.68) .. (3.60,1.55)
								.. controls (2.40,1.30) and (1.10,1.80) .. (0,1.55)
								-- cycle;
								
								% Etiqueta
								\node[dflabel] at (2.5,0.9) {Tira};
							\end{tikzpicture}
							\caption{Símbolo de Tira (paper tape).}
							\label{fig:DFTira}
						\end{figure}
						
						\paragraph{Operación manual.}
						La operación manual representa una actividad dentro del proceso que es realizada directamente por una persona y no por el sistema computacional. A diferencia de las operaciones automáticas, que son ejecutadas por el programa mediante instrucciones precisas, una operación manual requiere intervención humana para completar una tarea específica, como clasificar información, revisar resultados, tomar una decisión externa al algoritmo o realizar una acción física fuera del sistema \cite{Joyanes2007Fundamentos,Manzano2017Programacion}.
						
						En los diagramas de flujo, este símbolo se utiliza para indicar que el control del proceso se transfiere temporalmente al usuario u operador humano. Desde una perspectiva introductoria, resulta importante que el estudiante comprenda que no todas las actividades asociadas a un algoritmo pueden o deben ser automatizadas. Existen situaciones en las que el programa depende de acciones humanas, ya sea por razones de validación, supervisión, seguridad o simplemente porque la tarea no puede ser resuelta de forma automática \cite{Kendall2014Systems}.
						
						En el contexto de la programación básica, la operación manual permite modelar correctamente procesos mixtos, en los cuales interactúan tanto el sistema como las personas. Por ejemplo, un algoritmo puede calcular resultados automáticamente, pero requerir que un usuario los interprete, los apruebe o introduzca ajustes antes de continuar. Representar estas acciones mediante el símbolo de operación manual ayuda a delimitar claramente las responsabilidades del programa y del usuario, favoreciendo una comprensión más realista del funcionamiento de los sistemas de información \cite{Joyanes2007Fundamentos,SmartDrawFlowchartSymbols}.
						
						\textbf{La Figura~\ref{fig:DFOperacionManual} presenta el símbolo de operación manual empleado en los diagramas de flujo para indicar actividades que deben ser realizadas por una persona y no por el sistema computacional. Este símbolo será utilizado de manera consistente en los ejemplos y ejercicios desarrollados en este capítulo, con el fin de reforzar la distinción entre procesos automáticos y acciones humanas dentro de un algoritmo.}
						
						% ------------------------------------------------------------
						% 13) Operación manual (trapecio)
						% ------------------------------------------------------------
						\begin{figure}[h]
							\centering
							\begin{tikzpicture}
								\draw[dfshape] (0.6,0) -- (4.4,0) -- (5,1.6) -- (0,1.6) -- cycle;
								\node[dflabel] at (2.5,0.85) {Operación manual};
							\end{tikzpicture}
							\caption{Símbolo de Operación manual.}
							\label{fig:DFOperacionManual}
						\end{figure}
						
						\paragraph{Preparación.}
						El símbolo de \emph{preparación} se utiliza en los diagramas de flujo para representar operaciones de inicialización o configuración previa que deben realizarse antes de ejecutar un proceso principal o una estructura repetitiva. Estas operaciones establecen el estado inicial del algoritmo, definiendo valores de variables, contadores o acumuladores que serán utilizados posteriormente durante la ejecución del programa. En programación básica, este paso resulta fundamental para garantizar el correcto funcionamiento del algoritmo y evitar errores derivados de variables no inicializadas \cite{Joyanes2007Fundamentos}.
						
						Desde una perspectiva didáctica, el símbolo de preparación permite al estudiante identificar claramente aquellas acciones que no forman parte del procesamiento repetitivo o del cálculo central, pero que son necesarias para preparar el entorno de ejecución. Por ejemplo, asignar un valor inicial a un contador, establecer el valor inicial de una suma acumulada o definir límites iniciales para un recorrido son acciones típicas que se representan mediante este símbolo. De este modo, el diagrama de flujo refleja de forma explícita la secuencia lógica que sigue el algoritmo desde su estado inicial hasta su ejecución normal \cite{Joyanes2007Fundamentos,Manzano2017Programacion}.
						
						Es importante destacar que el símbolo de preparación no representa por sí mismo una estructura iterativa como el ciclo \texttt{for}, sino que modela la fase de inicialización que suele preceder a este tipo de estructuras. En un ciclo \texttt{for}, por ejemplo, la asignación inicial del índice se representa mediante el símbolo de preparación, mientras que la condición de repetición y la actualización del contador se modelan con otros símbolos del diagrama. Esta diferenciación ayuda a los estudiantes a comprender que una estructura iterativa está compuesta por varias partes lógicas y no por un único símbolo \cite{Joyanes2007Fundamentos,Kendall2014Systems}.
						
						\textbf{La Figura~\ref{fig:DFPreparacion} presenta el símbolo de preparación empleado en los diagramas de flujo para representar operaciones de inicialización o configuración previa, el cual será utilizado de manera consistente en los ejemplos y ejercicios desarrollados en este capítulo, especialmente en aquellos que incluyen estructuras repetitivas y control de variables.}
						
						% ------------------------------------------------------------
						% 14) Preparación (hexágono)
						% ------------------------------------------------------------
						\begin{figure}[h]
							\centering
							\begin{tikzpicture}
								\draw[dfshape]
								(1,0) -- (4,0) -- (5,0.8) -- (4,1.6) -- (1,1.6) -- (0,0.8) -- cycle;
								\node[dflabel] at (2.5,0.8) {Preparación};
							\end{tikzpicture}
							\caption{Símbolo de Preparación.}
							\label{fig:DFPreparacion}
						\end{figure}
						
						\paragraph{Conectores.}
						Los conectores se emplean en los diagramas de flujo para indicar la continuidad lógica del proceso cuando el flujo no puede representarse de manera completamente lineal o cuando resulta conveniente interrumpirlo y retomarlo en otro punto del diagrama (ver Figura \ref{fig:DFConectores}). Su uso permite evitar cruces innecesarios de líneas, mejorar la claridad visual y facilitar la comprensión del algoritmo, especialmente en procesos extensos o con múltiples ramificaciones \cite{Joyanes2007Fundamentos,Manzano2017Programacion}.
						
						Los conectores ayudan al diseñador a comprender que el flujo de control de un algoritmo puede continuar en otra ubicación sin que ello implique una ruptura lógica. La Figura~\ref{fig:DFConectorInterno} muestra el \emph{conector en la misma página}, representado por un pequeño círculo, el cual se utiliza cuando el flujo se retoma dentro del mismo diagrama. Este tipo de conector se identifica mediante una letra o número que debe coincidir exactamente con el punto de continuidad correspondiente.
						
						Por su parte, la Figura~\ref{fig:DFConectorExterno} presenta el \emph{conector fuera de página}, empleado cuando el flujo continúa en otra página del diagrama. Este símbolo permite mantener la legibilidad del algoritmo cuando su extensión excede el espacio disponible, asegurando que la secuencia lógica se preserve de forma clara y ordenada. El uso correcto de ambos tipos de conectores contribuye a que los estudiantes diseñen diagramas más estructurados y comprendan mejor el recorrido del control en un programa \cite{Joyanes2007Fundamentos,Kendall2014Systems}.
						
						% ------------------------------------------------------------
						% 15) Conectores (misma página y fuera de página)
						% ------------------------------------------------------------
						\begin{figure}[h]
							\centering
							
							\begin{subfigure}[b]{0.45\textwidth}
								\centering
								\begin{tikzpicture}
									\draw[dfshape] (0,0) circle (0.8);
									\node[dflabel] at (0,0) {A};
								\end{tikzpicture}
								\label{fig:DFConectorInterno}
								\caption{Conector en la misma página.}
							\end{subfigure}
							\hfill
							\begin{subfigure}[b]{0.45\textwidth}
								\centering
								\begin{tikzpicture}
									\begin{scope}[yscale=0.74]
										\draw[dfshape]
										(0,1.2) -- (2.2,1.2) -- (3,0)
										-- (2.2,-1.2) -- (0,-1.2) -- cycle;
										\node[dflabel] at (1.5,0) {B};
									\end{scope}
								\end{tikzpicture}
								\caption{Conector fuera de página.}
								\label{fig:DFConectorExterno}
							\end{subfigure}
							\caption{Símbolos de conectores utilizados en diagramas de flujo.}
							\label{fig:DFConectores}
						\end{figure}
						
				\subsection{Construcción de diagramas}
					Los diagramas de flujo constituyen una herramienta fundamental para la representación gráfica de algoritmos, ya que permiten describir de manera clara y ordenada la secuencia de operaciones necesarias para resolver un problema. Su principal ventaja radica en que facilitan la comprensión del flujo lógico de un proceso, independientemente del lenguaje de programación que se utilice posteriormente para su implementación. En el contexto de la programación básica, los diagramas de flujo actúan como un puente entre el análisis del problema y la codificación de la solución, ayudando al estudiante a estructurar el pensamiento algorítmico antes de enfrentarse al código fuente \cite{Joyanes2007Fundamentos,Manzano2017Programacion}.
					
					Desde el punto de vista del análisis de sistemas, los diagramas de flujo permiten identificar entradas, procesos, decisiones, salidas y almacenamiento de datos de forma visual, lo que reduce ambigüedades y errores conceptuales en etapas tempranas del desarrollo. Esta representación gráfica resulta especialmente útil para validar la lógica del algoritmo, comunicar la solución a otros integrantes del equipo y documentar el funcionamiento del sistema. Autores clásicos destacan que un diagrama de flujo bien construido contribuye a mejorar la calidad del software, al facilitar su revisión, mantenimiento y comprensión a lo largo del tiempo \cite{Kendall2014Systems,Pressman2019Software}.
					
					En entornos educativos, el uso sistemático de diagramas de flujo favorece el aprendizaje progresivo de la programación, ya que permite a los estudiantes centrarse primero en la lógica del problema y no en la sintaxis de un lenguaje específico. De este modo, el estudiante desarrolla habilidades de análisis, descomposición de problemas y razonamiento secuencial, competencias esenciales para la formación en ingeniería y sistemas de información \cite{Joyanes2007Fundamentos}.
					
				% =========================================================
				\subsection{Elementos del lenguaje algorítmico (UPSAM 2.0)}
				% =========================================================
					El lenguaje algorítmico UPSAM 2.0 \cite{Joyanes2007Fundamentos} define un conjunto de elementos fundamentales que permiten describir algoritmos de manera precisa, estructurada y comprensible, independientemente del lenguaje de programación en el que posteriormente se implementen. Estos elementos constituyen la base conceptual para el aprendizaje de la programación, ya que permiten modelar soluciones de forma lógica antes de enfrentarse a detalles sintácticos propios de lenguajes formales.
					
					Desde un enfoque didáctico, la especificación de estos elementos facilita el desarrollo del pensamiento algorítmico, al promover la correcta identificación de datos, operaciones y estructuras de control \cite{Futschek2006Algorithmic}. A diferencia de una descripción informal en lenguaje natural, UPSAM 2.0 proporciona reglas claras que evitan ambigüedades y favorecen la transición progresiva hacia lenguajes de programación reales.
					
					\subsubsection{Identificadores}
						Los identificadores son nombres simbólicos que representan entidades del algoritmo como variables, constantes, funciones o procedimientos \cite{Sebesta2018Concepts}. En UPSAM 2.0, un identificador debe comenzar con una letra, puede contener dígitos y el carácter de subrayado, y no debe coincidir con palabras reservadas del lenguaje. Esta restricción garantiza claridad y evita conflictos semánticos durante la interpretación del algoritmo.
					
						El uso de identificadores significativos es una recomendación central en la programación estructurada, ya que mejora la legibilidad del algoritmo y facilita su mantenimiento \cite{Martin2008Clean}. Por ejemplo, un identificador como \texttt{total\_pagar} transmite de forma inmediata su propósito, a diferencia de nombres genéricos como \texttt{x} o \texttt{aux}. Como ejemplo de uso, un algoritmo que calcula el promedio de notas puede emplear \texttt{nota1}, \texttt{nota2}, \texttt{nota3} y \texttt{promedio\_final}, haciendo explícito el significado de cada dato manejado.
					
					\subsubsection{Comentarios}
						Los comentarios permiten documentar el algoritmo sin afectar su ejecución lógica \cite{Sebesta2018Concepts,Martin2008Clean}. UPSAM 2.0 admite comentarios de una sola línea mediante \texttt{//} y comentarios multilínea delimitados por \texttt{\{} y \texttt{\}}. Estos comentarios son ignorados por el intérprete del algoritmo, pero resultan fundamentales para explicar decisiones de diseño, aclarar cálculos o describir el propósito de un bloque de instrucciones. Por ejemplo, puede indicarse mediante comentarios que una fórmula corresponde a un cálculo financiero o que una condición valida una restricción del problema planteado.
					
					\subsubsection{Tipos de datos básicos}
						Antes de presentar los tipos de datos, conviene recordar que la elección del tipo determina qué operaciones son válidas y cómo deben interpretarse los valores. En programación básica, esto permite evitar errores conceptuales (por ejemplo, intentar realizar operaciones aritméticas sobre cadenas) y mejora la claridad de los algoritmos al documentar la naturaleza de cada variable \cite{Farrell2018Programming,Gaddis2022Starting}. En la práctica, los tipos de datos se evidencian en tareas cotidianas: contar elementos requiere enteros, promedios suelen requerir reales y las decisiones se modelan con valores lógicos.
					
						\begin{table}[h]
							\centering
							\caption{Tipos de datos en UPSAM 2.0 (ampliado con ejemplos)}
							\label{tab:upsam_tipos_datos}
							\begin{tabular}{lll}
								\hline
								\textbf{Tipo} & \textbf{Definición mejorada} & \textbf{Ejemplo de uso} \\
								\hline
								Entero & Número sin decimales (conteos, índices, control de ciclos) & \texttt{contador $\leftarrow$ 0} \\
								Real & Número con decimales (mediciones, promedios, finanzas) & \texttt{promedio $\leftarrow$ 8.75} \\
								Lógico & Valor de verdad (condiciones y decisiones) & \texttt{aprobado $\leftarrow$ verdadero} \\
								Carácter & Un símbolo (códigos, sexo, opciones) & \texttt{op $\leftarrow$ 'A'} \\
								Cadena & Texto (nombres, mensajes, descripciones) & \texttt{nombre $\leftarrow$ "Ana"} \\
								\hline
							\end{tabular}
						\end{table}
					
					% =========================================================
					\subsection{Operadores del lenguaje algorítmico}
					% =========================================================
						Los operadores permiten construir expresiones y constituyen el núcleo del procesamiento algorítmico\cite{Sebesta2018Concepts,Cormen2022Introduction,Farrell2018Programming}. En UPSAM 2.0, los operadores se agrupan de forma clásica en aritméticos, relacionales y lógicos, lo que permite expresar cálculos, comparaciones y condiciones de control \cite{Joyanes2007Fundamentos}. En programación básica, esta clasificación es esencial porque facilita identificar qué se está calculando (aritmética), qué se está comparando (relacional) y cómo se combinan decisiones (lógica) \cite{Cormen2022Introduction,Farrell2018Programming,Wentworth2012How}.
					
						\subsubsection{Operadores aritméticos.}
							Antes de listar los operadores aritméticos, es útil notar que estos aparecen de manera recurrente en problemas matemáticos y financieros: sumatorias, promedios, porcentajes y tasas \cite{Gaddis2022Starting,Cormen2022Introduction,Farrell2018Programming,Miller2011Problem}. Por ejemplo, un descuento comercial puede modelarse con multiplicación, y la validación de paridad se apoya en el operador residuo.
					
							\begin{table}[h]
								\centering
								\caption{Operadores aritméticos (UPSAM 2.0) con ejemplos}
								\label{tab:upsam_op_arit}
								\begin{tabular}{lll}
									\hline
									\textbf{Operador} & \textbf{Definición} & \textbf{Ejemplo de uso} \\
									\hline
									\texttt{-} & Menos unitario (cambio de signo) & \texttt{a $\leftarrow$ - b} \\
									\texttt{+} & Suma dos valores & \texttt{suma $\leftarrow$ a + b} \\
									\texttt{-} & Resta dos valores & \texttt{dif $\leftarrow$ a - b} \\
									\texttt{*} & Multiplica valores & \texttt{area $\leftarrow$ base * altura} \\
									\texttt{/} & División real & \texttt{prom $\leftarrow$ total / n} \\
									\texttt{div} & División entera & \texttt{coc $\leftarrow$ 7 div 2} \\
									\texttt{mod} & Residuo de división & \texttt{res $\leftarrow$ 7 mod 2} \\
									\texttt{**} & Exponenciación & \texttt{potencia $\leftarrow$ base ** exponente} \\
									\hline
								\end{tabular}
							\end{table}
					
						\subsubsection{Operadores relacionales.}
							Los operadores relacionales producen resultados lógicos y se usan principalmente en decisiones (\texttt{si... entonces}) y en el control de ciclos \cite{Cormen2022Introduction,Farrell2018Programming,Miller2011Problem}. Un ejemplo típico es verificar rangos válidos, como \texttt{0 <= nota <= 10}, o validar restricciones de negocio, como \texttt{monto > 100} para aplicar un descuento.
						
							\begin{table}[h]
								\centering
								\caption{Operadores relacionales (UPSAM 2.0) con ejemplos}
								\label{tab:upsam_op_rel}
								\begin{tabular}{lll}
									\hline
									\textbf{Operador} & \textbf{Definición} & \textbf{Ejemplo de uso} \\
									\hline
									\texttt{=} & Igualdad & \texttt{a = b} \\
									\texttt{<>} & Diferente & \texttt{x <> 0} \\
									\texttt{<} & Menor que & \texttt{edad < 18} \\
									\texttt{<=} & Menor o igual & \texttt{nota <= 10} \\
									\texttt{>} & Mayor que & \texttt{ventas > 1000} \\
									\texttt{>=} & Mayor o igual & \texttt{prom >= 7} \\
									\hline
								\end{tabular}
							\end{table}
						
						\subsubsection{Operadores lógicos.}
							Los operadores lógicos permiten combinar condiciones simples para formar reglas de decisión compuestas. Esto es habitual al validar entradas (por ejemplo, que una nota esté en un rango) o al evaluar reglas institucionales (por ejemplo, matrícula permitida si no hay deudas y si cumple requisitos) \cite{Sebesta2018Concepts,Gaddis2022Starting,Farrell2018Programming}.
						
							\begin{table}[h]
								\centering
								\caption{Operadores lógicos (UPSAM 2.0) con ejemplos}
								\label{tab:upsam_op_log}
								\begin{tabular}{lll}
									\hline
									\textbf{Operador} & \textbf{Definición} & \textbf{Ejemplo de uso} \\
									\hline
									\texttt{no} & Negación lógica & \texttt{no aprobado} \\
									\texttt{y} & Conjunción (AND) & \texttt{(a>0) y (b>0)} \\
									\texttt{o} & Disyunción (OR) & \texttt{(x=0) o (y=0)} \\
									\hline
								\end{tabular}
							\end{table}
					
					% =========================================================
					\subsection{Estructura general de un programa en UPSAM 2.0}
					% =========================================================
						La estructura de un programa en UPSAM 2.0 separa, de forma explícita, las declaraciones del cuerpo de instrucciones. Esta separación mejora la claridad, porque permite identificar primero los datos (constantes y variables) y luego el flujo de acciones (entrada, procesamiento y salida). En programación básica, esto ayuda a que el estudiante distinga entre el ``qué datos existen'' y el ``qué hace el algoritmo'' \cite{Joyanes2007Fundamentos}.
					
						\subsubsection{Forma general.}
							A continuación se presenta una forma general y didáctica de organizar un algoritmo, donde se define el nombre, se declaran constantes y variables, y finalmente se especifican instrucciones entre \texttt{inicio} y \texttt{fin} \cite{Joyanes2007Fundamentos}. Por ejemplo, un algoritmo de cálculo de interés simple declarará variables como \texttt{capital}, \texttt{tasa} y \texttt{tiempo}, y luego realizará el cálculo dentro del bloque principal.
							
							\begin{verbatim}
								algoritmo NombreAlgoritmo
								const
								// Declaración de constantes
								var
								// Declaración de variables
								inicio
								// Instrucciones del algoritmo
								fin
							\end{verbatim}
						\subsubsection{Declaración de constantes.}
							Las constantes representan valores que no cambian durante la ejecución del algoritmo. Su uso resulta esencial para mejorar la claridad del algoritmo y evitar la repetición de valores ``mágicos'' en múltiples expresiones. Además, cuando un valor fijo debe modificarse (por ejemplo, una tasa institucional o un umbral de aprobación), basta con actualizarlo en un solo lugar, lo cual reduce errores y mejora la mantenibilidad \cite{Martin2008Clean,McConnell2004Code}. Como ejemplo de uso, \texttt{PI = 3.1416} se utiliza como constante para cálculos geométricos, por ejemplo al calcular áreas o perímetros de circunferencias.
							
						\subsubsection{Declaración de variables.}
							Las variables almacenan datos cuyo valor puede modificarse durante la ejecución del algoritmo \cite{Path2019Introduction}. En UPSAM 2.0, las variables se emplean para conservar entradas del usuario, resultados intermedios (sumas, acumuladores, contadores) y resultados finales. Por ejemplo, en un algoritmo de promedio, las calificaciones se almacenan en variables y la suma total se mantiene en un acumulador. La declaración explícita (cuando se usa le añade calidad a la solución) y el uso consistente de variables favorece la legibilidad y evita confusiones entre datos de distinta naturaleza.
							
							Antes de mostrar ejemplos, conviene recalcar que los tipos de variables deben elegirse según el tipo de información: \texttt{entero} para conteos, \texttt{real} para mediciones y promedios, y \texttt{cadena} para texto. Como ejemplo contextualizado, un algoritmo de nómina puede declarar \texttt{real : salario} y \texttt{real : descuento}, mientras que un algoritmo de inventarios podría declarar \texttt{entero : unidades}.
							
							\begin{table}[h]
								\centering
								\caption{Ejemplos de declaración de variables en UPSAM 2.0}
								\label{tab:upsam_decl_vars}
								\begin{tabular}{ll}
									\hline
									\textbf{Tipo} & \textbf{Ejemplo} \\
									\hline
									entero & \texttt{entero : contador} \\
									real & \texttt{real : salario} \\
									cadena & \texttt{cadena : mensaje $\leftarrow$ "Hola"} \\
									\hline
								\end{tabular}
							\end{table}
							
						\subsubsection{Funciones predefinidas.}
							UPSAM 2.0 incorpora una biblioteca de funciones que facilitan cálculos y manipulaciones comunes, reduciendo la necesidad de expresar procedimientos rutinarios paso a paso. En programación básica, estas funciones permiten concentrarse en la lógica general de la solución, manteniendo algoritmos más cortos y legibles. Por ejemplo, para calcular distancias o desviaciones se requiere raíz cuadrada, y para validaciones numéricas resulta útil el valor absoluto o la truncación de decimales \cite{Cormen2022Introduction}.
							
						\subsubsection{Funciones aritméticas.}
							Antes de presentar la tabla, nótese que estas funciones son especialmente relevantes en problemas matemáticos, estadísticos y financieros \cite{Joyanes2007Fundamentos,Chapra2014Numerical}. Por ejemplo, \texttt{abs(x)} puede emplearse para medir error absoluto, \texttt{raiz2(x)} aparece en varianza y desviación estándar, y \texttt{trunc(x)} resulta útil al trabajar con valores monetarios o partes enteras de cantidades reales.
							
							\begin{table}[h]
								\centering
								\caption{Funciones aritméticas predefinidas en UPSAM 2.0}
								\label{tab:upsam_func_arit}
								\begin{tabular}{lll}
									\hline
									\textbf{Función} & \textbf{Descripción} & \textbf{Ejemplo} \\
									\hline
									\texttt{abs(x)} & Devuelve el valor absoluto de un número & \texttt{abs(-5)} \\
									\texttt{raiz2(x)} & Calcula la raíz cuadrada de un número & \texttt{raiz2(16)} \\
									\texttt{exp(x)} & Calcula la función exponencial $e^x$ & \texttt{exp(1)} \\
									\texttt{ln(x)} & Calcula el logaritmo natural de un número & \texttt{ln(10)} \\
									\texttt{log10(x)} & Calcula el logaritmo en base 10 & \texttt{log10(100)} \\
									\texttt{trunc(x)} & Elimina la parte decimal de un número & \texttt{trunc(8.9)} \\
									\texttt{redondear(x)} & Redondea un número al entero más cercano & \texttt{redondear(3.6)} \\
									\texttt{sen(x)} & Calcula el seno de un ángulo (en radianes) & \texttt{sen(1.57)} \\
									\texttt{cos(x)} & Calcula el coseno de un ángulo (en radianes) & \texttt{cos(0)} \\
									\texttt{tan(x)} & Calcula la tangente de un ángulo (en radianes) & \texttt{tan(0.78)} \\
									\texttt{arcsen(x)} & Calcula el arco seno & \texttt{arcsen(0.5)} \\
									\texttt{arccos(x)} & Calcula el arco coseno & \texttt{arccos(0.5)} \\
									\texttt{arctan(x)} & Calcula el arco tangente & \texttt{arctan(1)} \\
									\hline
								\end{tabular}
							\end{table}
							
							
						\subsubsection{Funciones de cadena.}
							Las funciones de cadena permiten manipular texto, algo muy frecuente en sistemas de información, por ejemplo al procesar nombres, códigos, mensajes, identificadores o entradas del usuario. En programación básica, estas funciones ayudan a introducir al estudiante en el tratamiento de datos no numéricos y en operaciones típicas como contar caracteres o extraer partes de un texto \cite{Farrell2018Programming,Joyanes2007Fundamentos}.
							
							\begin{table}[h]
								\centering
								\caption{Funciones de cadena predefinidas en UPSAM 2.0}
								\label{tab:upsam_func_cad}
								\renewcommand{\arraystretch}{1.2}
								
								% Definición de un tipo de columna X en modo monoespaciado y con salto de línea
								\newcolumntype{Y}{>{\raggedright\arraybackslash\ttfamily}X}
								
								\begin{tabularx}{\textwidth}{
										>{\raggedright\arraybackslash}p{3.0cm}
										>{\raggedright\arraybackslash}X
										>{\raggedright\arraybackslash}p{2.4cm}
										Y
									}
									\hline
									\textbf{Función} & \textbf{Descripción} & \textbf{Tipo de retorno} & \textbf{Ejemplo} \\
									\hline
									\texttt{longitud (c)}
									& Devuelve el número de caracteres de una cadena.
									& Entero
									& longitud (nombre) \\
									
									\texttt{subcadena (c, i, l)}
									& Extrae una subcadena a partir de la posición $i$ con longitud $l$.
									& Cadena
									& subcadena ("Hola", 1, 2) \\
									
									\texttt{concatenar (c1, c2)}
									& Une dos cadenas en una sola cadena resultante.
									& Cadena
									& concatenar ("Hola", " Mundo") \\
									
									\texttt{reemplazar (c, sub1, sub2)}
									& Reemplaza todas las apariciones de una subcadena por otra dentro de una cadena.
									& Cadena
									& reemplazar ("Hola mundo", "mundo", "UPSAM") \\
									
									\texttt{contar (c, sub)}
									& Cuenta cuántas veces aparece una subcadena o carácter dentro de una cadena.
									& Entero
									& contar ("banana", "a") \\
									
									\texttt{posicion (c, sub)}
									& Devuelve la posición de la primera aparición de una subcadena en una cadena.
									& Entero
									& posicion ("programacion", "gra") \\
									
									\texttt{ultimaPosicion(c,sub)}
									& Devuelve la posición de la última aparición de una subcadena en una cadena.
									& Entero
									& ultimaPosicion("banana","a") \\
									
									\texttt{mayusculas (c)}
									& Convierte todos los caracteres de una cadena a letras mayúsculas.
									& Cadena
									& mayusculas ("hola") \\
									
									\texttt{minusculas (c)}
									& Convierte todos los caracteres de una cadena a letras minúsculas.
									& Cadena
									& minusculas ("HOLA") \\
									
									\texttt{igual (c1, c2)}
									& Compara dos cadenas y devuelve verdadero si son idénticas.
									& Lógico
									& igual("abc", "abc") \\
									
									\texttt{empiezaCon (c, sub)}
									& Verifica si una cadena comienza con una subcadena dada.
									& Lógico
									& empiezaCon ("algoritmo", "algo") \\
									
									\texttt{terminaCon (c, sub)}
									& Verifica si una cadena finaliza con una subcadena dada.
									& Lógico
									& terminaCon ("algoritmo", "ritmo") \\
									\hline
								\end{tabularx}
							\end{table}
							
							
						\subsubsection{Entrada y salida.}
							Las operaciones de entrada y salida definen la interacción entre el algoritmo y su entorno. La entrada permite obtener datos desde el usuario o desde una fuente externa, mientras que la salida comunica resultados o mensajes. En programación básica, estas operaciones son esenciales porque conectan la lógica interna del algoritmo con el propósito práctico del programa: resolver un problema con datos reales. Como ejemplo, un algoritmo de cálculo de promedio primero lee las calificaciones y luego escribe el promedio final y el estado de aprobación \cite{Gaddis2022Starting}.
							
							\begin{table}[h]
								\centering
								\caption{Procedimientos de entrada y salida en UPSAM 2.0}
								\label{tab:upsam_io}
								\begin{tabular}{lll}
									\hline
									\textbf{Procedimiento} & \textbf{Uso} & \textbf{Ejemplo} \\
									\hline
									\texttt{leer} & Entrada de datos & \texttt{leer(edad)} \\
									\texttt{escribir} & Salida de datos & \texttt{escribir("Resultado:", total)} \\
									\hline
								\end{tabular}
							\end{table}
						
					\subsection{¿Cómo se construye un diagrama de flujo?}
						La construcción de un diagrama de flujo inicia con la comprensión completa del problema, identificando claramente qué se desea resolver y bajo qué condiciones. En esta etapa se determinan los datos de entrada, los resultados esperados y las restricciones del problema. A partir de esta información, se define la secuencia general de pasos que llevará desde las entradas hasta las salidas, empleando los símbolos normalizados descritos previamente en el documento \cite{Gaddis2022Starting,Farrell2018Programming,Hanly2015Problem}.
					
						Posteriormente, el diagrama se refina incorporando decisiones, cálculos intermedios, ciclos y subprocesos, según sea necesario. Cada paso debe representarse mediante el símbolo correspondiente, manteniendo una dirección clara del flujo y evitando cruces innecesarios de líneas \cite{Stevens1974Structured}. El objetivo es obtener un diagrama legible, coherente y fiel a la lógica del algoritmo que se implementará más adelante.
						
						\subsubsection{Consejos para la construcción de diagramas de flujo}
							\begin{itemize}
								\item Utilizar siempre los símbolos normalizados y definidos en el capítulo.
								\item Mantener el flujo del diagrama de arriba hacia abajo y de izquierda a derecha.
								\item Evitar diagramas excesivamente largos; emplear conectores o subprocesos cuando sea necesario.
								\item Etiquetar claramente las decisiones y condiciones lógicas.
								\item Usar nombres significativos para variables y procesos.
								\item Revisar el diagrama para verificar que toda entrada conduce a una salida.
								\item Asegurar que el diagrama pueda entenderse sin explicaciones adicionales.
							\end{itemize}
						\subsubsection{Ejercicios}
							
				\subsection{Correspondencia con pseudocódigo}
					2 PÁRRAFOS O LOS QUE ESTIMES CONVENIENTE PARA DAR GRAN DETALLE. Un problema, y los pasos para dar la solución, el pseudocódigo o algoritmo y el diagrama de flujo.
					
			\section{Refinamiento sucesivo y descomposición}
			% De problemas complejos a subproblemas, árboles de descomposición.
				3 PÁRRAFOS - AGREGAR FIGURA
				
				\subsection{De un problema grande a subproblemas}
					3 PÁRRAFOS - AGREGAR FIGURA
					
				\subsection{Construcción de un árbol de descomposición}
					5 PÁRRAFOS - AGREGAR FIGURA
						
				\subsection{Ventajas del diseño modular}
					LOS PÁRRAFOS QUE SEAN NECESARIOS. UNO POR CADA VENTAJA - AGREGAR LAS IMÁGENES NECESARIAS PARA EXPLICAR MEJOR SUS VENTAJAS.
				
			\section{Errores típicos en el diseño algorítmico}
			% Casos no considerados, bucles sin salida, inconsistencias.
				4 PÁRRAFOS
				
				\subsection{Casos no contemplados}
					1 PÁRRAFO PARA CADA CASO.
					
				\subsection{Condiciones incompletas}
					3 PÁRRAFOS
					
				\subsection{Ciclos sin salida}
					1 PÁRRAFO PARA CADA CASO QUE SE PUEDE PRESENTAR. AGREGAR LA FIGURA CORRESPONDIENTE 
					
				\subsection{Inconsistencias con el problema}
					1 PÁRRAFO PARA CADA TIPO DE INCONSISTENCIA QUE SE PUEDE PRESENTAR. AGREGAR LA FIGURA CORRESPONDIENTE
					
	%=========================================================
	\part{Programación Estructurada: Datos, Control y Estructuras}
	%=========================================================
	
		\chapter{Lenguajes de Programación e Introducción al Código}
	
			\section{Lenguajes de programación en el contexto de los sistemas de información}
			% Bajo nivel, alto nivel, propósito general, dominio específico.
				\subsection{Lenguajes de bajo nivel}
				\subsection{Lenguajes de alto nivel}
				\subsection{Paradigmas de programación}
					\subsubsection{Imperativo}
					\subsubsection{Funcional}
					\subsubsection{Orientado a objetos}
				
			\section{Compiladores, intérpretes y máquinas virtuales}
			% Proceso de compilación, interpretación, ciclo fuente–ejecutable.
				\subsection{Etapas del compilador}
					\subsubsection{Análisis léxico}
					\subsubsection{Análisis sintáctico}
					\subsubsection{Generación de código}
				\subsection{Ejecución interpretada}
				\subsection{Bytecode y máquinas virtuales}
				
			\section{Estructura mínima de un programa de computadora}
			% Encabezados, declaraciones, función principal, bloques.
				\subsection{Encabezados}
				\subsection{Declaraciones}
				\subsection{Bloques}
				\subsection{Función principal}
				
			\section{Entorno de desarrollo (IDE) y ciclo de trabajo}
			% Edición, compilación, ejecución, depuración.
				\subsection{Edición}
				\subsection{Compilación}
				\subsection{Ejecución}
				\subsection{Depuración}
				
			\section{Datos e información desde la perspectiva del programa}
			% Cómo se representan e ingresan los datos en un programa simple.
				\subsection{Entrada}
				\subsection{Procesamiento}
				\subsection{Salida}
				\subsection{La Retroalimentación en un istema de información}
				
		%-----------------------------------------
		\chapter{Tipos de Datos, Operadores, Variables y Expresiones}
		%-----------------------------------------
		
			\section{Correspondencia entre tipos lógicos y tipos del lenguaje}
			% Enteros, reales, caracteres, booleanos.
				\subsection{Enteros}
				\subsection{Reales}
				\subsection{Caracteres}
				\subsection{Booleanos}
				
			\section{Declaración, inicialización y ámbito de variables}
			% Alcance, tiempo de vida, buenas prácticas de nomenclatura.
				\subsection{Declaración}
				\subsection{Inicialización}
				\subsection{Ámbito}
					\subsubsection{Variables locales}
					\subsubsection{Variables globales}
				
			\section{Operadores aritméticos, relacionales y lógicos}
			% Significado, tablas de verdad, construcción de expresiones.
				\subsection{Aritméticos}
				\subsection{Relacionales}
				\subsection{Lógicos}
				\subsection{Asignación}
				\subsection{Precedencia y asociatividad}
				
			\section{Precedencia y asociatividad de operadores}
			% Reglas y ejemplos con paréntesis.
				\subsection{Concepto de precedencia de operadores}
					\subsubsection{Definición formal}
					\subsubsection{Relación entre precedencia y orden de evaluación}
					\subsubsection{Operadores de mayor y menor precedencia}
					\subsubsection{Importancia de la precedencia en expresiones complejas}
				
				\subsection{Jerarquía típica de operadores}
					\subsubsection{Operadores unarios}
					\subsubsection{Operadores aritméticos}
					\subsubsection{Operadores relacionales}
					\subsubsection{Operadores lógicos}
					\subsubsection{Operadores de asignación}
					\subsubsection{Variaciones según el lenguaje de programación}
					
				\subsection{Asociatividad de operadores}
					\subsubsection{Asociatividad de izquierda a derecha}
					\subsubsection{Asociatividad de derecha a izquierda}
					\subsubsection{Operadores sin asociatividad permitida}
					\subsubsection{Errores comunes al ignorar la asociatividad}
					
				\subsection{Precedencia y asociatividad combinadas}
					\subsubsection{Resolución de expresiones mixtas}
					\subsubsection{Interacción entre operadores aritméticos y lógicos}
					\subsubsection{Efecto en expresiones de comparación encadenada}
					\subsubsection{Evaluación corta en operadores lógicos (short-circuit)}
					
				\subsection{Uso de paréntesis para controlar la evaluación}
					\subsubsection{Regla: lo explícito prevalece sobre la precedencia}
					\subsubsection{Paréntesis para claridad de lectura}
					\subsubsection{Prevención de errores de interpretación}
					\subsubsection{Buenas prácticas: siempre agrupar expresiones complejas}
					
				\subsection{Ejemplos clásicos de precedencia problemática}
					\subsubsection{Expresiones aritméticas ambiguas}
					\subsubsection{Comparaciones múltiples mal interpretadas}
					\subsubsection{Errores combinando =, == y operadores lógicos}
					\subsubsection{Expresiones booleanas con AND y OR sin paréntesis}
					
				\subsection{Errores típicos en principiantes}
					\subsubsection{Asumir que la evaluación es secuencial de izquierda a derecha}
					\subsubsection{Confundir orden de lectura con orden de cálculo}
					\subsubsection{Usar asignación (=) en vez de comparación (==)}
					\subsubsection{Subestimar la importancia de paréntesis en condicionales}
					
				\subsection{Buenas prácticas para el uso de operadores}
					\subsubsection{Uso moderado de expresiones demasiado largas}
					\subsubsection{Agrupar siempre condiciones lógicas complejas}
					\subsubsection{Preferencia por claridad sobre concisión}
					\subsubsection{Verificación manual de expresiones antes de ejecutar}
			
			\section{Expresiones}
				\subsection{Concepto y función de una expresión}
					\subsubsection{Definición formal}
					\subsubsection{Rol de las expresiones en un programa}
					\subsubsection{Expresión vs. instrucción}
					\subsubsection{Evaluación y producción de un valor}
					
				\subsection{Componentes de una expresión}
					\subsubsection{Operadores}
					\subsubsection{Operandos}
					\subsubsection{Funciones como componentes de expresiones}
					
					\subsubsection{Constantes y literales}
					\subsubsection{Subexpresiones}
				\subsection{Tipos de expresiones}
					\subsubsection{Expresiones aritméticas}
					\subsubsection{Expresiones relacionales}
					\subsubsection{Expresiones lógicas o booleanas}
					\subsubsection{Expresiones de caracteres y cadenas}
					\subsubsection{Expresiones mixtas}
					\subsubsection{Expresiones con llamadas a funciones}
					
				\subsection{Expresiones aritméticas en detalle}
					\subsubsection{Operaciones básicas: suma, resta, multiplicación, división}
					\subsubsection{Módulo y cociente entero}
					\subsubsection{Expresiones anidadas}
					\subsubsection{Errores comunes: división entera, división por cero}
					
				\subsection{Expresiones lógicas o booleanas}
					\subsubsection{Conectores lógicos: AND, OR, NOT}
					\subsubsection{Operadores lógicos de cortocircuito (short-circuit)}
					\subsubsection{Negación y doble negación}
					\subsubsection{Expresiones booleanas en decisiones de control}
					
				\subsection{Expresiones relacionales}
					\subsubsection{Igualdad y desigualdad}
					\subsubsection{Comparación de enteros}
					\subsubsection{Comparación de reales: uso de tolerancia}
					\subsubsection{Comparación de caracteres y cadenas}
					
				\subsection{Expresiones con mezclas de tipos}
					\subsubsection{Coerción implícita}
					\subsubsection{Conversión explícita (casting)}
					\subsubsection{Promoción de tipos en operaciones}
					\subsubsection{Riesgos de las mezclas de tipos}
					
				\subsection{Expresiones con efectos laterales}
					\subsubsection{Operadores de incremento y decremento (++ y --)}
					\subsubsection{Asignación compuesta (+=, -=, *=, /=)}
					\subsubsection{Expresiones que modifican variables}
					\subsubsection{Peligros y malas prácticas}
					
				\subsection{Evaluación de expresiones}
					\subsubsection{Orden de evaluación e impacto en el resultado}
					\subsubsection{Precedencia de operadores}
					\subsubsection{Asociatividad}
					\subsubsection{Reglas del lenguaje específico}
					
				\subsection{Expresiones ambiguas y uso de paréntesis}
					\subsubsection{Cuándo son necesarios los paréntesis}
					\subsubsection{Expresiones de lectura difícil}
					\subsubsection{Estrategias para evitar ambigüedad}
					\subsubsection{Buenas prácticas para expresiones complejas}
					
				\subsection{Errores típicos en el uso de expresiones}
					\subsubsection{Confundir asignación con comparación}
					\subsubsection{Comparación de cadenas con el operador incorrecto}
					\subsubsection{Comparaciones múltiples sin paréntesis}
					\subsubsection{Expresiones lógicas mal agrupadas}
					\subsubsection{Uso de variables no inicializadas}
					
				\subsection{Buenas prácticas en la construcción de expresiones}
				\subsubsection{Preferir claridad a concisión}
				\subsubsection{Comentar expresiones complejas}
				\subsubsection{Evitar efectos laterales innecesarios}
				\subsubsection{Verificación manual antes de la ejecución}
				
			\section{Errores de tipo y problemas de representación}
			% Desbordamiento, truncamiento, comparaciones de reales.
				\subsection{Errores de tipo (Type Errors)}
					\subsubsection{Operaciones con tipos incompatibles}
					\subsubsection{Asignación de valores a variables de tipo diferente}
					\subsubsection{Comparaciones inválidas entre tipos heterogéneos}
					\subsubsection{Errores de conversión implícita}
					\subsubsection{Errores de conversión explícita (casting) incorrecta}
				
				\subsection{Conversión de tipos (Type Casting) y coerción}
					\subsubsection{Coerción implícita: riesgos y usos}
					\subsubsection{Conversión explícita: truncamiento y redondeo}
					\subsubsection{Pérdida de información en conversiones numéricas}
					\subsubsection{Conversión entre caracteres y números}
					\subsubsection{Conversión entre booleanos y otros tipos (si aplica)}
					
				\subsection{Problemas de representación de enteros}
					\subsubsection{Rangos de representación de enteros}
					\subsubsection{Desbordamiento (overflow)}
					\subsubsection{Subdesbordamiento (underflow)}
					\subsubsection{Signo y representación en complemento a dos}
					\subsubsection{Errores al mezclar enteros con tipos más grandes o pequeños}
					
				\subsection{Problemas de representación de números reales}
					\subsubsection{Punto flotante y precisión limitada}
					\subsubsection{Errores de redondeo}
					\subsubsection{Errores de cancelación}
					\subsubsection{Comparación de números reales: tolerancia y epsilon}
					\subsubsection{Conversión entre enteros y reales}
					
				\subsection{Problemas con caracteres y cadenas}
					\subsubsection{Representación ASCII vs Unicode}
					\subsubsection{Conversión entre caracteres y números}
					\subsubsection{Errores al interpretar codificaciones}
					\subsubsection{Problemas con tildes y caracteres especiales}
					
				\subsection{Errores lógicos derivados de la representación}
					\subsubsection{Evaluaciones booleanas incorrectas}
					\subsubsection{Comparaciones que siempre son verdaderas o falsas}
					\subsubsection{Efectos de desbordamientos en decisiones lógicas}
					\subsubsection{Errores en condiciones compuestas debido a conversiones automáticas}
					
				\subsection{Buenas prácticas para evitar errores de tipo}
					\subsubsection{Declarar tipos adecuados según la naturaleza de los datos}
					\subsubsection{Realizar conversiones explícitas cuando sea necesario}
					\subsubsection{Validación de rangos y tipos de entrada}
					\subsubsection{Evitar comparaciones directas con números reales}
					\subsubsection{Uso de constantes simbólicas y tipos definidos}
					
			\section{Entrada y salida de datos}
				
				\subsection{Conceptos fundamentales}
					\subsubsection{Dispositivos de entrada y salida}
					\subsubsection{Flujos de datos (streams)}
					\subsubsection{Entrada estándar, salida estándar y error estándar}
					\subsubsection{Interacción humano–computadora en programas de consola}
				
				\subsection{Lectura por consola}
					\subsubsection{Métodos básicos de lectura según el lenguaje}
					\subsubsection{Lectura de enteros, reales, caracteres y cadenas}
					\subsubsection{Entrada de datos con espacios (tokens vs líneas completas)}
					\subsubsection{Problemas comunes: retorno de carro, salto de línea, buffer}
					\subsubsection{Validación mínima de la entrada}
					
				\subsection{Salida por consola}
					\subsubsection{Impresión estándar de datos}
					\subsubsection{Combinación de texto y variables}
					\subsubsection{Escapes comunes (tab, salto de línea, retorno)}
					\subsubsection{Salida como retroalimentación para el usuario}
					
				\subsection{Salida formateada}
					\subsubsection{Control de precisión en números reales}
					\subsubsection{Alineación de columnas y formatos tabulares}
					\subsubsection{Formatos de salida predeterminados del lenguaje}
					\subsubsection{Uso de especificadores de formato (según lenguaje)}
					\subsubsection{Buenas prácticas de presentación de información}
					
				\subsection{Errores en entrada y salida}
					\subsubsection{Lectura de tipo incorrecto}
					\subsubsection{Entrada vacía o nula}
					\subsubsection{Conversión fallida de cadenas a números}
					\subsubsection{Desbordamiento de buffer (según lenguaje)}
					\subsubsection{Errores de codificación en caracteres especiales}
				
				\subsection{Manejo básico de errores}
					\subsubsection{Verificación del tipo de dato ingresado}
					\subsubsection{Reintentos y mensajes informativos al usuario}
					\subsubsection{Uso de estructuras de control para validar la entrada}
					\subsubsection{Conversión segura (try/except o equivalentes)}
					\subsubsection{Prevención de finalizaciones inesperadas}
					
				\subsection{Buenas prácticas en entrada y salida}
					\subsubsection{Mensajes claros y simples para el usuario}
					\subsubsection{Evitar solicitar datos que no serán usados}
					\subsubsection{Estandarizar el formato de salida}
					\subsubsection{Mantener coherencia entre lo que se pide y lo que se imprime}
					\subsubsection{Construcción progresiva del programa mediante pruebas I/O}

		%-----------------------------------------
		\chapter{Estructuras de Control: Selección y Repetición}
		%-----------------------------------------
	
			\section{Estructuras condicionales}
			% if, if-else, condicionales anidadas; opcionalmente switch/case.
				\subsection{If simple}
				\subsection{If–else}
				\subsection{If anidado}
				\subsection{Switch/case}
				
			\section{Estructuras de repetición}
			% while, do-while, for, control de iteración con break/continue.
				\subsection{While}
				\subsection{Do–while}
				\subsection{For}
				\subsection{Control de iteración (break/continue)}
				
			\section{Diseño de algoritmos condicionales frecuentes}
			% Clasificación, decisiones por rangos, validación de datos.
				\subsection{Decisiones por rangos}
				\subsection{Validación de datos}
				\subsection{Selección múltiple}
				
			\section{Diseño de algoritmos iterativos frecuentes}
			% Sumas, conteos, búsqueda en rangos, menús iterativos.
				\subsection{Cálculo de series}
				\subsection{Conteos y acumuladores}
				\subsection{Menús interactivos}
				
			\section{Estructuras de control anidadas}
			% Combinar condicionales y ciclos, impacto en legibilidad.
				\subsection{Condicionales dentro de ciclos}
				\subsection{Ciclos dentro de condicionales}
				\subsection{Condicionales dentro de condiciones - Condiciones dentro de condiciones}
				\subsection{Ciclos anidados - ciclos dentro de ciclos}	
			\section{Complejidad intuitiva de bucles}
			% Idea de coste lineal y cuadrático sin formalismo matemático.
				\subsection{Tiempo lineal}
				\subsection{Tiempo cuadrático}
		%-----------------------------------------
		\chapter{Arreglos y Datos Estructurados}
		%-----------------------------------------
	
			\section{Arreglos unidimensionales}
			% Declaración, inicialización, recorrido, ejemplos numéricos.
				\subsection{Definición}
				\subsection{Declaración}
				\subsection{Inicialización}
				\subsection{Recorrido}
				\subsection{Modificación}
				
			\section{Arreglos bidimensionales}
			% Tablas y matrices, acceso por índices, aplicaciones sencillas.
				\subsection{Tablas}
				\subsection{Matrices}
				\subsection{Procesamiento fila–columna}
				
			\section{Operaciones típicas sobre colecciones}
			% Búsqueda, conteo, modificación simple.
				\subsection{Búsqueda lineal}
				\subsection{Conteo}
				\subsection{Modificación simple}
				
			\section{Introducción intuitiva a ordenamiento y búsqueda}
			% Algoritmos sencillos (burbuja, búsqueda lineal) a modo de contexto.
				\subsection{Intercambio de valores entre variables}
				\subsection{Algoritmos de búsqueda}
					\subsubsection{Burbuja}
					\subsection{Búsqueda lineal}
					\subsubsection{Otros algoritmos}
			
			\section{Registros o estructuras}
			% Agrupación lógica de datos heterogéneos.
				\subsection{Definición}
				\subsection{Analogía con tablas}
				\subsection{Acceso a campos}
				
			\section{Arreglos de estructuras}
			% Ejemplo: lista de estudiantes, productos, clientes.
				\subsection{Listas de objetos agrupados}
				\subsection{Procesamiento de colecciones}
				\subsection{Ejemplos: Lista de estudiantes, productos, clientes}


	%=========================================================
	\part{Modularidad, Abstracción y Proyecto Integrador}
	%=========================================================
	
		\chapter{Funciones, Procedimientos y Modularidad}
		
			\section{Motivación de la modularidad}
			% Reutilización, legibilidad, pruebas, mantenimiento.
				\subsection{Limitaciones de los programas monolíticos}
				\subsection{Ventajas de dividir el programa en módulos}
					\subsubsection{Separación de responsabilidades}
					\subsubsection{Aislamiento de errores y facilidad de depuración}
					\subsubsection{Facilidad de actualización y mantenimiento}
				\subsection{Relación entre modularidad y calidad del software}
					\subsubsection{Legibilidad del código}
					\subsubsection{Reutilización en proyectos futuros}
					\subsubsection{Favorecer el trabajo colaborativo}
				\subsection{Modularidad en distintos paradigmas de programación}
					\subsubsection{Modularidad en programación estructurada}
					\subsubsection{Modularidad en programación orientada a objetos}
					\subsubsection{Modularidad en programación funcional}
					
			\section{Definición y sintaxis de funciones y procedimientos}
			% Parámetros, valor de retorno, cabecera y cuerpo.
				\subsection{Conceptos fundamentales}
					\subsubsection{Función: definición y propósito}
					\subsubsection{Procedimiento: definición y diferencias con la función}
					\subsubsection{Subrutinas en lenguajes clásicos}
				\subsection{Estructura formal de una función}
					\subsubsection{Cabecera o firma}
					\subsubsection{Bloque o cuerpo de la función}
					\subsubsection{Declaraciones internas}
				\subsection{Sintaxis en lenguajes comunes}
					\subsubsection{Ejemplo en Python}
					\subsubsection{Ejemplo en C/C++}
					\subsubsection{Ejemplo en Java}
				\subsection{Tipos de funciones según su comportamiento}
					\subsubsection{Funciones puras vs funciones con efectos laterales}
					\subsubsection{Funciones void o sin retorno}
					\subsubsection{Funciones generadoras y recursivas (visión preliminar)}
			
			\section{Parámetros y paso de argumentos}
			% Por valor, por referencia (según lenguaje), efectos laterales.
				\subsection{Concepto de parámetro y argumento}
				\subsection{Paso por valor}
					\subsubsection{Ventajas y limitaciones}
					\subsubsection{Comportamiento con tipos primitivos}
				\subsection{Paso por referencia}
					\subsubsection{Implicaciones en la modificación de datos}
					\subsubsection{Problemas comunes con efectos colaterales}
				\subsection{Paso de estructuras y arreglos}
					\subsubsection{Costos de copia}
					\subsubsection{Alias y referencias implícitas}
				\subsection{Parámetros por defecto y parámetros nombrados}
					\subsubsection{Flexibilidad en la llamada}
					\subsubsection{Ejemplos en lenguajes modernos}
				\subsection{Errores típicos al trabajar con parámetros}
					\subsubsection{Desbordes conceptuales: paso incorrecto de índices}
					\subsubsection{Problemas con tipos incompatibles}
				
			\section{Alcance de variables en programas modulares}
			% Variables locales, globales, estáticas.
				\subsection{Ámbito léxico y temporal de las variables}
				\subsection{Variables locales}
					\subsubsection{Duración y ciclo de vida}
					\subsubsection{Ventajas de su uso}
				\subsection{Variables globales}
					\subsubsection{Uso responsable y riesgos}
					\subsubsection{Condiciones de carrera en entornos concurrentes (visión general)}
				\subsection{Variables estáticas}
					\subsubsection{Persistencia entre llamadas}
					\subsubsection{Ejemplos prácticos y advertencias}
				\subsection{Sombra de variables (shadowing)}
					\subsubsection{Problemas de legibilidad}
					\subsubsection{Errores difíciles de detectar}
				
			\section{Diseño descendente y descomposición funcional}
				% Del problema a un conjunto de funciones; diagramas de jerarquía.
				\subsection{Principios del diseño descendente}
					\subsubsection{Del problema general a subproblemas}
					\subsubsection{Criterios de división funcional}
				\subsection{Descomposición por niveles}
					\subsubsection{Funciones de alto nivel}
					\subsubsection{Funciones de mediano nivel}
					\subsubsection{Funciones auxiliares}
				\subsection{Diagramas de jerarquía}
					\subsubsection{Representación gráfica de módulos}
					\subsubsection{Relaciones entre funciones}
				\subsection{Cohesión y acoplamiento}
					\subsubsection{Cohesión funcional y lógica}
					\subsubsection{Acoplamiento débil vs acoplamiento fuerte}
				\subsection{Errores comunes en la descomposición funcional}
					\subsubsection{Funciones demasiado grandes}
					\subsubsection{Funciones que hacen más de una tarea}
					\subsubsection{Dependencias innecesarias}
			
			\section{Introducción a la recursividad (opcional)}
			% Caso base, llamada recursiva, ejemplos simples.
				\subsection{Concepto de función recursiva}
				\subsection{Estructura de una solución recursiva}
					\subsubsection{Caso base}
					\subsubsection{Caso recursivo}
				\subsection{Ejemplos fundamentales}
					\subsubsection{Factorial}
					\subsubsection{Fibonacci}
					\subsubsection{Búsqueda en estructuras simples}
				\subsection{Comparación entre recursividad e iteración}
					\subsubsection{Costos en memoria}
					\subsubsection{Ventajas expresivas}
				\subsection{Errores comunes}
					\subsubsection{Caso base incorrecto o inexistente}
					\subsubsection{Recursividad infinita}
					
			\section{Documentación y pruebas de funciones}
				% Comentarios, casos de prueba, ejemplos de uso.
				\subsection{Documentación interna}
					\subsubsection{Comentarios descriptivos}
					\subsubsection{Convención de docstrings (según lenguaje)}
				\subsection{Documentación externa}
					\subsubsection{Especificación de interfaces}
					\subsubsection{Explicación del comportamiento esperado}
				\subsection{Pruebas de funciones}
					\subsubsection{Casos de prueba básicos}
					\subsubsection{Pruebas de frontera}
					\subsubsection{Pruebas con datos inválidos}
				\subsection{Ejemplos de uso o casos ilustrativos}
					\subsubsection{Ejemplos simples}
					\subsubsection{Ejemplos integrados en aplicaciones pequeñas}
				\subsection{Errores frecuentes al usar funciones}
					\subsubsection{Llamada con parámetros incorrectos}
					\subsubsection{No manejar valores de retorno}
					\subsubsection{Dependencia excesiva de variables globales}

		%-----------------------------------------
		\chapter{Proyecto Integrador de Programación Básica}
		%-----------------------------------------
					
			\section{Planteamiento del proyecto}
			% Descripción general en el ámbito de sistemas de información.
				\subsection{Contexto del proyecto}
					\subsubsection{Importancia de resolver problemas reales}
					\subsubsection{Relación con áreas típicas de sistemas de información}
					\subsubsection{Dominios recomendados: académico, comercial, administrativo}
				\subsection{Justificación del proyecto}
					\subsubsection{Necesidad de integrar todo lo aprendido}
					\subsubsection{Desarrollo de competencias profesionales}
					\subsubsection{Simulación del trabajo real del programador}
				\subsection{Propuesta de escenarios de proyecto}
					\subsubsection{Sistema simple de inventarios}
					\subsubsection{Gestor de estudiantes o calificaciones}
					\subsubsection{Agenda o sistema de turnos}
					\subsubsection{Simulaciones interactivas por consola}
				\subsection{Alcance esperado del proyecto}
					\subsubsection{Nivel de complejidad apropiado para programación básica}
					\subsubsection{Requisitos obligatorios y opcionales}
					\subsubsection{Productos mínimos esperados}
					
			\section{Análisis del problema y especificación}
			% Entradas, salidas, reglas de negocio, restricciones.
				\subsection{Identificación del problema}
					\subsubsection{Descripción narrativa del caso}
					\subsubsection{Actores involucrados}
					\subsubsection{Proceso que se busca automatizar}
				\subsection{Entradas del sistema}
					\subsubsection{Tipos de datos requeridos}
					\subsubsection{Formato y validación de la entrada}
					\subsubsection{Frecuencia y origen de los datos}
				\subsection{Salidas del sistema}
					\subsubsection{Información presentada al usuario}
					\subsubsection{Formatos de salida y reportes}
					\subsubsection{Interpretación de resultados por consola}
				\subsection{Reglas de negocio}
					\subsubsection{Condiciones obligatorias}
					\subsubsection{Restricciones operativas}
					\subsubsection{Casos especiales y excepciones}
				\subsection{Requisitos funcionales y no funcionales}
					\subsubsection{Requisitos funcionales básicos}
					\subsubsection{Eficiencia y simplicidad (no funcionales)}
					\subsubsection{Claridad y facilidad de uso}
				\subsection{Criterios de aceptación}
					\subsubsection{Qué significa que el proyecto esté completo}
					\subsubsection{Pruebas mínimas para validar el comportamiento}
					
			\section{Diseño de algoritmos y estructuras de datos}
			% División en módulos, elección de estructuras.
				\subsection{Diseño modular}
					\subsubsection{Descomposición en funciones}
					\subsubsection{Relación entre módulos}
					\subsubsection{Identificación de responsabilidades}
				\subsection{Elección de estructuras de datos}
					\subsubsection{Uso de variables simples}
					\subsubsection{Arreglos unidimensionales y bidimensionales}
					\subsubsection{Registros o estructuras}
				\subsection{Diagramas y representaciones}
					\subsubsection{Diagramas de flujo para procesos principales}
					\subsubsection{Pseudocódigo detallado de funciones críticas}
					\subsubsection{Diagrama de jerarquía de módulos}
				\subsection{Modelación de casos especiales}
					\subsubsection{Condiciones límite}
					\subsubsection{Validaciones adicionales}
				\subsection{Errores comunes en el diseño}
					\subsubsection{Dependencias innecesarias entre módulos}
					\subsubsection{Datos mal estructurados}
					\subsubsection{Falta de cohesión en funciones}
					
			\section{Implementación incremental}
			% Planificación por etapas, versiones intermedias.
				\subsection{Principios de desarrollo incremental}
					\subsubsection{Construir desde lo simple hacia lo complejo}
					\subsubsection{Evitar codificar todo de una sola vez}
				\subsection{Planificación del desarrollo}
					\subsubsection{Versión base funcional (V1)}
					\subsubsection{Agregado de funciones adicionales (V2)}
					\subsubsection{Optimización y mejoras finales (V3)}
				\subsection{Integración de módulos}
					\subsubsection{Pruebas individuales de funciones}
					\subsubsection{Ensambles parciales del sistema}
					\subsubsection{Compatibilidad entre estructuras y tipos de datos}
				\subsection{Problemas típicos en la implementación}
					\subsubsection{Incompatibilidades entre módulos}
					\subsubsection{Variables no inicializadas o mal declaradas}
					\subsubsection{Errores por cambios no documentados}
					
			\section{Pruebas, depuración y validación}
			% Casos de prueba, pruebas de frontera, corrección de errores.
				\subsection{Tipos de pruebas}
					\subsubsection{Pruebas unitarias}
					\subsubsection{Pruebas de integración}
					\subsubsection{Pruebas funcionales finales}
				\subsection{Casos de prueba}
					\subsubsection{Pruebas con datos válidos}
					\subsubsection{Pruebas con datos inválidos}
					\subsubsection{Pruebas de frontera}
				\subsection{Depuración de errores}
					\subsubsection{Uso de mensajes de seguimiento (trace)}
					\subsubsection{Análisis de errores comunes}
					\subsubsection{Corrección sistemática}
				\subsection{Validación final del sistema}
					\subsubsection{Verificación de requisitos}
					\subsubsection{Comportamiento según la especificación}
					\subsubsection{Aceptación del usuario (según el caso)}
					
			\section{Documentación y presentación del proyecto}
			% Manual de usuario, descripción técnica, conclusiones del estudiante.
				\subsection{Documentación técnica}
					\subsubsection{Descripción general del sistema}
					\subsubsection{Funciones implementadas y su propósito}
					\subsubsection{Estructuras de datos utilizadas}
					\subsubsection{Diagrama de módulos}
				\subsection{Manual de usuario}
					\subsubsection{Requisitos previos}
					\subsubsection{Cómo ejecutar el programa}
					\subsubsection{Descripción paso a paso del funcionamiento}
				\subsection{Presentación final del proyecto}
					\subsubsection{Estructura recomendada de la exposición}
					\subsubsection{Demostración funcional}
					\subsubsection{Principales aprendizajes del estudiante}
				\subsection{Conclusiones}
					\subsubsection{Reflexión sobre el proceso de desarrollo}
					\subsubsection{Limitaciones del proyecto}
					\subsubsection{Ideas de mejora o ampliación futura}	
	%=========================================================
	\appendix
	%=========================================================
	
		\chapter{Introducción al control de versiones con Git}
		% Conceptos básicos, repositorios locales, confirmaciones (commits).
		
		\chapter{Recomendaciones para el trabajo autónomo en programación}
		% Estrategias de práctica, organización del tiempo, uso de recursos.
		
		\chapter{Glosario de términos fundamentales}
		% Definiciones de términos clave de computación y programación.
		
		\chapter{Bibliografía recomendada}
		% Libros clásicos y recursos abiertos de referencia.
		
	\backmatter
		\printbibliography		
	

\end{document}
